# JVM

## 1. JVM体系介绍

1. JVM体系介绍
   > 1. JVM介绍
   >
   >    JVM，具体的名称叫做Java虚拟机规范。常见的JVM版本，就是HotSpot
   >    
   > 2. JVM运行的位置
   >
   >    JVM运行在操作系统之上，它与硬件没有直接的交互
   >
   > 3. JVM的组成概念图：参见视频，非常重要
   >
   >     1. 图中，灰色部分，代表没有垃圾回收机制进行回收
   >
   >     2. ClassLoader是JVM的入口，ExecutionEngine是JVM出口。ClassLoader加载.java文件编译后的.class文件；ExecutionEngine将出来的指令，翻译给对应的操作系统，让操作系统调用具体的硬件完成操作。
   >
### 1. ClassLoader
1. ClassLoader   
   > 3. ClassLoader
   >
   >      1. 介绍
   >      
   >         类加载器，用来加载class文件。class文件在开头有特定的文件标识，ClassLoader只负责加载class文件，是否可以运行则由ExecutionEngine决定。
   >         
   >      2. 原理图
   >      
   >         参见视频，具体就是，将class文件，加载进入内存，成为具体的Class类模板。
   >         
   >      3. ClassLoader的种类：按照父类子类顺序来
   >      
   >          * 虚拟机自带的类加载器
   >          
   >              * 启动类加载器(Bootstrap)，C++编写
   >          
   >                  * 扩展类加载器(Extension)，Java编写
   >          
   >                      * 应用程序加载类(AppClassLoader)，Java编写，也叫系统类加载器，加载当前应用下ClassPath的所有类
   >          
   >                          * 用户自定义加载器。Java.lang.ClassLoader的子类，用户用来定制类的加载方式
   > 
### 2. ExecutionEngine  
2. ExecutionEngine
   > 1. 介绍
   >    
   >     执行引擎负责解释命令，提交给具体操作系统执行
   > 
   > 2. 简单的面试问题：我们使用new Thread().start()来启用一个线程时，问当程序执行到该行代码，线程是否启动。
   > 
   >    不确定，因为开启线程不是Java决定的，而是操作系统实现的。该行代码只是Java给操作系统发起一个启动线程的请求，线程是否启动不由Java决定
   >    
   >    通过追踪Thread()的源码可以看到，启动线程的start0()方法使用了native关键字修饰，并且没有方法体
   >    
### 3. native关键字
3. native关键字
   > 6. native关键字
   > 
   >     1. 介绍
   >     
   >        在Java中，使用了native关键字修饰的方法，都是没有方法体的
   >       
   >        使用native关键字修饰的方法，叫做本地方法，该方法不是Java能完成的，会交给操作系统完成。
   >       
   >        本地方法执行后，会入栈，进入的是本地方法栈(Native Method Stack)。本地方法栈只有native修饰的本地方法才能入栈
   >        
   >     2. 本地方法使用过程
   >     
   >        本地方法进入本地方法栈，
   >        
   >         然后调用本地接口(本地接口是操作系统提供的系统接口，C或C++编写的)，
   >        
   >         本地接口调用本地方法库中方法生成对应指令，
   >        
   >         对应指令再交给ExecutionEngine解释后，提交给操作系统运行
   >     
   > 2. 本地接口
   > 
   >     1. 介绍
   >     
   >        本地接口，是融合了不同语言为Java所用，它的初衷是融合C/C++程序，去调用C/C++程序。
   > 
### 4. PC寄存器
4. PC寄存器
   > 8. PC寄存器
   > 
   >     1. 介绍
   >     
   >        PC寄存器(Program Counter Register)，又叫程序计数器
   >        
   >        程序计数器，就是一个指针，是每个线程私有的，生命周期随线程而动，非常短，不需要垃圾回收。它指向了方法的字节码，用来存储指向下一个指令的地址，通过ExecutionEngine读取下一个指令，是一个小到忽略不计的内存空间
   > 
### 5. MethodArea
5. MethodArea
   > 9. MethodArea
   > 
   >     1. 介绍
   >     
   >        MethodArea，方法区，被所有线程共享。存储所有字段和方法字节码，以及一些特殊的方法如构造方法，接口代码也在此定义。所有定义的方法信息，都保存在此区域
   >        
   >        方法区存储的东西：静态变量+类信息(构造方法/接口定义)+运行时的常量池。注意，实例变量不存在于方法区
   >        
   >     2. MethodArea有垃圾回收机制，在JVM停止时回收垃圾
   >     
### 6. Java栈
6. Java栈
    > 1. 介绍
    > 
    >    栈，又叫做栈内存，主管Java程序的运行，在线程创建时被创建。栈的生命周期随着线程的生命周期，线程结束栈内存释放， 因此不存在垃圾回收的问题。
    >    
    >    8种基本数据类型+对象的引用+*<u>实例方法都是在栈内存中分配</u>*
    >    
    > 2. 栈存储什么？
    > 
    >    栈帧中主要保存了3类数据：
    >    
    >    1、本地变量：输入参数以及输出参数以及方法内的变量
    >    
    >    2、栈操作：记录出栈、入栈的操作
    >    
    >    3、栈帧数据：包括类文件、方法等
    >    
    > 3. 栈帧是什么
    > 
    >    每次执行一个方法，都会产生一个栈帧。栈帧根据栈的特性，压入栈顶，顶部栈帧就是当前方法，该方法执行完毕，弹栈。
    >    
### 7. 堆
7. 堆
    > 1. 介绍
    >
    >    Heap，堆，一个JVM的实例，只存在一个堆内存，堆内存的大小可以调节。
    >    
    >    类加载器加载了class文件后，将类、方法、常变量放入堆内存中，保证所有引用类型的真实信息，以方便执行器执行
    >    
    > 2. JDK7之前
    >
    >     1. 堆内存在**逻辑上**，分为3个部分
    >     
    >         1、Young Generation Space：新生区
    >     
    >         2、Tenure Generation Space：养老区
    >     
    >         3、Permanent Space：永久区
    >         
    >     2. 新生区
    >     
    >         1. 介绍
    >         
    >            新生区是类的诞生、成长、消亡的区域，一个类在这里被创建、使用、最后被垃圾回收。
    >            
    >         2. 新生区的三个部分
    >         
    >             * 伊甸区：
    >             
    >                所有的对象，都是在伊甸区被创建的。
    >                
    >                如果伊甸区空间使用完毕，但是有新对象需要创建，JVM垃圾回收器将对伊甸区进行轻量级GC(Minor GC)，将伊甸区不需要的对象销毁，将幸存对象放入幸存0区。
    >             
    >             * 幸存0区：
    >             
    >                存放幸存的对象，如果幸存0区空间使用完毕，但是有新幸存对象要进入，则JVM垃圾回收器进行轻量级GC(Minor GC)，将不需要对象销毁，幸存对象放入幸存1区。
    >             
    >             * 幸存1区
    >             
    >                存放幸存的对象，如果幸存1区空间使用完毕，但是有新幸存对象要进入，则JVM垃圾回收器进行轻量级GC(Minor GC)，将不需要对象销毁，幸存对象放入幸存0区。
    >             
    >        3. 幸存0区和幸存1区的幸存对象，在经历了15次交替轻量级GC后，才会将幸存对象从新生区，放入养老区
    >        
    >    3. 养老区
    >    
    >        1. 介绍
    >        
    >           养老区存放幸存0区和幸存1区经过多次轻量级GC都幸存的对象
    >           
    >        2. 养老区如果要存满后，JVM垃圾回收会进行重量级GC(Full GC)，进行养老区内存清理，销毁不需要的对象，留下幸存对象。
    >        
    >        3. 如果养老区经过重量级GC后，仍然无法进行对象的存储，就会报错OOM(OutOfMemoryError)
    >        
    >        4. **重要知识点：如果出现java.lang.OutOfMemoryError:Java Heap space异常，说明java虚拟机的内存不够用了原因有两点：**
    >        
    >            **1. Java虚拟机的内存设置不够，可以通过修改参数-Xms、-Xmx来调整**
    >            
    >            **2. 代码创建了大量的对象，并且长时间无法被垃圾回收器收集(说明这些对象都存在引用)**
    >        
    >    4. 永久区
    >    
    >        1. 介绍
    >        
    >           永久区和新生区和养老区都没有关联，是一块独立的内存区域
    >           
    >           永久区虽然在逻辑上，是堆内存的一块，但是它在真实的内存中就是方法区
    >           
    >           永久区就是一块常驻内存区域，用于存放JDK自身携带的Class，Interface的元数据，也就是说，它存储的是运行时必要的类信息，关闭JVM才会释放该区域所占用的内存
    >           
    >        2. 可见，堆内存和方法区之间，存在着关系，就是永久区在真实内存中，就是方法区
    >        
    >        3. **重点知识点：如果出现了java.lang.OutOfMemoryError: PermGen space，说明Java虚拟机对永久区Perm内存设置不够。一般这种情况，都是程序启动需要加载大量的第三方jar包。**
    >        
    >        4. **重要知识点：**
    >        
    >            **1. JDK1.6之前：有永久区，常量池1.6位于永久区**
    >            
    >            **2. JDK1.7：有永久区，但是在逐步去除永久区概念，常量池1.7位于堆中**
    >            
    >            **3. JDK1.8及以后：没有永久区的概念，常量池1.8在元空间**
    >            
## 2. JVM调优
2. JVM调优
    > 1. JVM调优，就是对堆内存大小进行调优。**JVM堆内存大小，默认最小内存为：本机内存 / 64 ；默认最大内存为：本机内存 / 4**
    > 
    > 2. JVM调优，最常用如下三个参数的调优：
    > 
    >     * -Xmn：新生区的大小(新生区包括伊甸区、幸存0区、幸存1区)   
    >     * -Xms：JVM堆最小内存(新生区大小+养老区大小)
    >     * -Xmx：JVM堆最大内存
    >     * 一般我们调整堆内存大小，都调整成一致的，防止多次垃圾回收
    >     
## 3. GC
3. GC
    > 1. 介绍
    > 
    >    GC是JVM的垃圾回收算法(分代收集算法)，它的特点是：频繁收集新生区、较少收集养老区，基本不动永久区(元空间)
    >    
    >    有两种GC，Minor GC和Full GC
    >    
    > 2. GC有四种算法：
    > 
    >     1. 引用计数法：JVM不用该算法，只是提一下有这个东西。不算在GC四种算法之内。
    >     
    >     2. 复制算法：
    >     
    >         1. 介绍
    >         
    >            新生区的Minor GC，采用的就是复制算法
    >           
    >         2. 原理：
    >         
    >            复制幸存的对象，到下一个区，如从幸存0区复制幸存对象到幸存1区；清空原本的区；交换两个身份，从From区变成To区 
    >            
    >            **复制-》清空-》交换**
    >            
    >            **复制必交换，谁空谁是To**
    >         
    >         3. 优点：
    >         
    >            没有标记和清除的过程，效率较高
    >            
    >            没有内存碎片。因为复制后的幸存对象，复制到新的区后内存是连续的，因此不会有内存碎片。
    >            
    >         4. 缺点
    >         
    >            需要双倍的内存空间，造成很大内存浪费
    >     
    >     3. 标记清除算法
    >     
    >         1. 介绍
    >         
    >            养老区的Full GC，一般是标记清除或者是标记清除和标记压缩的混合来实现的
    >            
    >         2. 原理
    >         
    >            对整个养老区扫描一遍，对存活对象进行标记。之后再次扫描一遍养老区，回收没有被标记的对象
    >            
    >         3. 优点
    >         
    >            不需要双倍的内存空间
    >            
    >         4. 缺点
    >         
    >            两次扫描，耗时严重
    >            	
    >            会产生内存碎片。因为如果清除对象后，存活对象之间有内存间隙，就会有内存碎片
    >            
    >            标记清除算法开始时，养老区的功能必须暂时停止
    >     
    >     4. 标记压缩算法
    >     
    >         1. 介绍
    >         
    >            养老区的Full GC，一般是标记清除或者是标记清除和标记压缩的混合来实现的
    >            
    >         2. 原理
    >         
    >            先扫描一次养老区，标记要压缩的对象；再次扫描养老区，往左滑动存活对象，将压缩对象滑动到右边，然后清理右边的压缩对象，空出右边一段空间。
    >            
    >         3. 优点
    >         
    >            不需要双倍空间
    >            
    >            没有内存碎片
    >            
    >         4. 缺点
    >         
    >            移动对象需要成本，效率不高
    >     
    >     5. 标记清除压缩算法
    >     
    >         1. 介绍
    >         
    >            将上述两个算法合在一起使用，真实情况的养老区就是采用这种算法较多
    >            
    >         2. 原理
    >         
    >            先进行多次标记清除，最终得到有内存碎片的养老区
    >            
    >            再进行一次标记压缩，将幸存对象滑动到左边，将内存碎片全部滑动到右边，这就没有内存碎片了
    >            
    >         3. 优点
    >         
    >            *减少了移动对象的成本*
    >     
    > 3. 没有最好的GC算法，只有针对新生区和养老区，采用最合适的GC算法。因此GC是分代收集算法。