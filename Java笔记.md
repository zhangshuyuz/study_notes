# Java基础
## day01
### 1. 类的介绍
   1. **类的介绍**
      
       > java源代码的基本组织单位
       >
       > ```java
       > public class ClassName {}
       > ```
       > 
### 2. main方法
   2. **main方法**
      
       > 程序的起点
       >
       >  ```java
       >  public static main(String[] args) {}
       >  ```
       >  
### 3. java保留关键字
   3. **java保留的关键字**
       > 关键字特点：
       > 
       >    1、完全小写  
       >
       >    2、在编译工具中有特定的颜色
### 4. 数据类型
   4. **数据类型**
       > * *基本数据类型*
       >
       >     1. 整数型
       >         > byte 1字节 -128~127 
       >         > 
       >     	 > short 2字节 -32768~32767  
       >         >
       >     	 > int 4字节  
       >         >
       >     	 > long
       >     2. 浮点型
       >         > float 4字节 
       >         >
       >         > double 8字节
       >        
       >     3. 字符型
       >        
       >         > char 2字节 0~65535
       >     4. 布尔型
       >        
       >         > boolean 1字节
       >     
       > * *引用数据类型*
       >
       >     1. 字符串
       >
       >         > String
       >     
       >     2. 数组
       >     
       >     3. 类
       >     
       >     4. 接口
       >     
       >     5. Lambda
       
       > *注意事项：*
       >
       > 1. 字符串是引用数据类型
       >
       > 2. 浮点值只是近似值，不是精确值
       >
       > 3. 数据范围与字节数不一定相关，如char
       >
       > 4. 浮点数默认类型为double，如果需要使用float类型则需要加后缀F；整型默认使用int，要想使用long，需要加后缀L
       > 
### 5. 变量的两种定义格式
   5. **变量的两种定义格式**
       > 数据类型 变量名1；  
       >
       > 变量名1 = 数据值1；
       >  
       > 数据类型 变量名2 = 数据值2；  
       > 
***
## day02
### 1. 数据类型转换
   1. **数据类型转换**
       > java要求参与计算的数据类型必须一致，如果不一致会发生数据类型的转换  
       > 
       > 1. *自动转换*   
       > 
       >     将取值方位小的类型转化为取值范围大的，如：   
       >
       >     byte类型和int类型相加，结果是int类型   
       >    
       > 2. *强制类型转换* 
       > 
       >     (要强制转化成的类型) 要转换类型的数据，如：
       > 
       >      ​    int a = (int) 100L; 
       > 
       > 3. *注意事项*  
       >
       >     > 1. 强制类型转换，可能会发生精度损失的情况，尽量不要使用  
       >     >
       >     > 2. byte/int/char都可以发生数学运算，加减乘除，他们会先被提升为int类型，然后进行运算（char数学运算会把字符的ASCII码进行运算）  
       >     >
       >     > 3. java中boolean类型不能发生数据转换
       >     >
       >     > 4. ASCII  
       >     >
       >     >    \'0' -- 48  
       >     >
       >     >    \'A' -- 65  
       >     >
       >     >    \'a' -- 97   
       >     > 
       >     > 5. \+的用法  
       >     >
       >     >    1. 数学运算的教号
       >     >
       >     >    2. 对于char类型，用\+会先把char类型转化成int类型，然后进行int类型的加法
       >     >
       >     >    3. 对于String类型，用\+表示连接字符串，注意，任意类型的数据和字符串用\+相连都会String类型 
       >     >
       > 6. 复合赋值运算符的注意事项 
       >
       >     1. 常量不能被赋值
       >
       >     2. 隐含了强制数据类型转换
       >
       >     ```   
       >     byte num;  
       >     num += 5;  
       >     //byte = byte + int  
       >     //byte = int + int
       >     //byte = int
       >     //byte = (byte) int
       >     ```
       >
       > 7. 三目运算符使用注意事项
       >
       >     1. 同时保证表达式A和表达式B满足左侧数据类型要求
       >
       >     2. 运算的结果必须被使用
       >
### 2. 方法入门
   2. **方法入门**
       > 1. 方法定义  
       >
       >    ```
       >    修饰符 返回值类型 方法名(参数类型 参数, ...) {
       >      代码;
       >      返回值;
       >    }
       >    ```
***

## day03
### 1. 流程控制语句
1. 流程控制语句
    > 1. if else 语句
    > 2. switch 语句
    > 3. for 语句
    > 4. while 语句
    > 5. do while 语句
    > 
## day04
### 1. 方法调用格式
1. 方法调用格式
    > 1. 单独调用
    > 2. 打印调用
    > 3. 赋值调用
    > 
### 2. 方法重载（OverLoad）
2. 方法重载（OverLoad）
    > 1. 使用方法重载的原因
    > 
    >    对于参数的数量或者类型或者数量和类型或者类型不同的参数顺序不同的情况，但是功能类似的方法使用重载
    >    
    > 2. 方法重载注意事项
    > 
    >    只有对于方法名称一样，方法的参数列表不同的才可以进行方法重载。
    >    
    >    参数列表不同，指的是参数的数量不同或者参数的类型不同或者参数的数量和类型都不同或者不同类型的参数顺序不同的情况
    >    
## day04
### 1. 数组（Array）
1. 数组（Array）
    > 1. 概念
    > 
    >    存放多个同一个类型数据的连续的存储空间
    >    
    > 2. 特点
    > 
    >    1、引用数据类型
    >   
    >    2、数组中的多个数据类型统一
    >   
    >    3、数组的长度在程序运行期间无法改变
    >   
    > 3. 数组的初始化
    > 
    >     1. 动态初始化：只指定长度，不指定其中的内容
    >     
    >        数据类型[] 数组名 = new 数据类型[数组长度];
    >        
              * *数组长度：int类型的的数字
              * 
    >     2. 静态初始化：指定内容的同时指定长度
    >     
    >        静态初始化标准格式：数据类型[] 数组名 = new 数据类型[]{元素1, ...};
    >        
    >        静态初始化简略格式：数据类型[] 数组名 = {元素1, ...};
    >        
    >     * **注意：**
    >     
    >         1. 静态初始化标准格式可以拆分为两个步骤：
    >         
    >            数据类型[] 数组名;
    >            
    >            数组名 = new 数据类型[] { 元素1, ... };
    >           
    >         2. 动态初始化可以拆分为两个步骤：
    >         
    >            数据类型[] 数组名;
    >            
    >            数组名 = new 数据类型[数组长度];
    >            
    >         3. 静态初始化简略格式不可以拆分
    >         
    >         4. 已知内容的情况下用静态初始化，否则用动态初始化
    >     
    > 4. 数组的打印
    > 
    >     1. 直接打印数组名，得到的是数组对应的内存地址值和哈希值
    >     
    >     2. 访问数组元素：数组名[索引值]
    >     
    > 5. 数组元素的赋值
    > 
    >     1. **动态初始化数组，数组元素会有默认值：**
    >     
    >        整型默认值：0
    >        
    >        浮点型默认值：0.0
    >        
    >        字符型默认值：'\u0000'
    >        
    >        布尔类型默认值：false
    >        
    >        引用类型默认值：null
    >        
    >     2. 数组元素赋值：数组名[索引] = 值
    >     
    >     3. 静态初始化实际也先有默认值，但计算机马上把大括号中的值赋给数组元素了
    >     
    > 6. 数组可以赋值为null，如：int[] a = null;，所有引用类型都可以赋值为null，代表什么内容都没有
    > 
    > 7. 获取数组长度
    > 
    >    数组名.length
    >    
    >     * 数组在创建后，程序运行期间长度不可以改变，即通过new在堆区申请的内存不变
    >    
    > 8. 数组遍历
    > 
    >    通过for和数组.length配合遍历，或者使用foreach遍历
    >    
    > 9. 数组作为方法的参数或返回值
    > 
    >    数组作为方法的参数或返回值都是传递的地址
    >    
    >     * **一切引用类型，作为方法的参数或返回值，都是传递的地址**
    >    
    >     * 任何数据类型都可以作为方法的参数或返回值
    >    
### 2. java内存划分
2. java内存划分
    > 1. java内存划分为5个部分：
    > 
    >    1、栈（Stack）：存放方法中的局部变量，局部变量超出作用域，立刻从栈中释放，方法在栈中运行
    >    
    >    2、堆（Heap）：所有new的东西，堆内存中的东西都有地址值，都有默认值
    >    
    >    3、方法区（Method Area）：存储.class的相关信息，即方法的模板；常量
    >    
    >    4、本地方法栈（Native Method Stack）：与操作系统相关
    >    
    >    5、寄存器（pc Register）：与CPU相关
    > 
## day05
### 1. 面向对象
1. 面向对象
    > 1. 类
    > 
    >    成员变量
    >    
    >    成员方法
    >    
    > 2. 对象
    > 
    >     1. 概念
    >     
    >        类的实例。引用数据路类型
    >        
    >     2. 实例化步骤
    >     
    >        1、导包
    >        
    >        2、创建：类名 对象名 = new 类();
    >        
    >        3、使用成员变量和成员方法
    >     
    > 3. 对象在内存中的表示
    > 
    >    见视频
    >    
    > 4. 成员变量和局部变量的区别
    > 
    >     1. 定义位置不同
    >     
    >        局部变量：方法的内部
    >        
    >        成员变量：方法外部，类的内部
    >        
    >     2. 作用范围不同
    >     
    >        局部变量：只有方法内有用
    >        
    >        成员变量：整个类中都有用
    >        
    >     3. 默认值
    >     
    >        局部变量：无默认值，使用必须赋值，否则报错
    >        
    >        成员变量：有默认值，默认值规则和数组一样
    >        
    >         * 注意：方法的参数也是局部变量，但在方法中直接输出不会报错，为什么？因为方法在被调用时，一定会传参的，所以参数一定会被赋值
    >        
    >     4. 存储的位置不同
    >     
    >        局部变量：存储在栈中
    >        
    >        成员变量：存储在堆中
    >        
    >     5. 生命周期不同
    >     
    >        局部变量：随着方法进栈诞生，出栈回收
    >        
    >        成员变量：随着对象的创建诞生，对象被垃圾回收而消失
    >        
    >         * 垃圾回收程序员无法控制，通常情况下局部变量生命周期短，成员变量生命周期长
    > 5. 构造方法
    > 
    >    public 类名(参数) {}
    >    
    >     * 构造方法也支持重载
    >    
## day06
### 1. 标准类（JavaBean）
1. 标准类
    > 标准的类有四个组成部分：
    > 1、所有的成员变量通过private修饰
    > 2、为每一个成员变量提供set和get的方法
    > 3、编写无参数的构造方法
    > 4、编写全参数的构造方法
    > 
### 2. Java封装好的类
#### 1. Scanner类
1. Scanner类  
    > 1. 介绍
    > 
    >    一款基本的文本扫描器，可以解析基本类型和字符串
    >    
    >    例如：从键盘录入一个数，System.in即键盘录入数据
    >    
    >     ```
    >     Scanner scanner = new Scanner(System.in)
    >     ```
    >    
    > 2. 使用步骤
    > 
    >    1、导包：Scanner类的包位于java.until包下
    >    
    >    2、实例化Scanner
    >    
    >    3、使用方法
    >    
    >     * **注意：位于java.lang包下的类都不需要导包即可使用**
    >    
    > 3. Scanner类中的部分方法
    > 
    >     ```
    >     String next() -- 将录入的数据扫描为字符串，返回录入的数据。
    >     ```
    >     
    >     ```
    >     int nextInt() -- 将录入的数据扫描为整形数据，返回录入的数字
    >     ```
    > 
#### 2. Random类
2. Random类
    > 1. 介绍
    > 
    >    专门用来产生随机数
    >    
    > 2. 部分方法
    > 
    >     ```
    >     int nextInt() -- 返回一个int范围（-2147483648~2147483647）的随机数
    >     ```
    >     ```
    >     int nextInt(int n) -- 返回[0, n)之间的随机数
    >     ```
    >     
#### 3. Math类
3. Math类
    > 1. 介绍
    > 
    >    数学类
    >    
    > 2. 常用的静态方法
    > 
    >     ```
    >     static double abs(double num) -- 获取绝对值
    >     static int abs(int num) -- 获取绝对值
    >     ...
    >     ```
    >     
    >     ```
    >     static double ceil(double num) -- 向上取整
    >     ```
    >     
    >     ```
    >     static double floor(double num) -- 向下取整
    >     ```
    >     
    >     ```
    >     static double round(double num) -- 四舍五入。底层是位运算，理解成传入的num + 0.5，然后向下取整
    >     ```
    >     
    >     ```
    >     static double random() -- 返回一个[0, 1)之间的浮点数
    >     ```
    > 
### 3. 匿名对象
3. 匿名对象
    > 1. 介绍
    > 
    >    new 类名();
    >    
    >    匿名对象每次使用都会开辟一块新内存，只能使用一次
    >    
    > 2. 所有数据类型都可以成为方法参数或返回值，匿名对象也可以
    > 
### 4. 对象数组
4. 对象数组
    > 1. 概念
    > 
    >    类名[] 数组名 = new 类名[int index];
    >    
    > 2. 数组缺点：数组一旦创建，数组长度在程序运行期间不会改变
    > 
### 5. ArrayList集合
5. ArrayList集合
    > 1. ArrayList集合和数组的区别
    >
    >    ArrayList集合长度可变，数组不可变
    >    
    > 2. 导包：ArrayList集合位于java.until包下
    >
    > 3. 创建
    >
    >    ArrayList<泛型> 对象名 = new ArrayList<>();
    >    
    >     * Java给ArrayList类重写了toString()方法，直接打印对象，得到的是集合中的内容[键值对, ...]，没内容则打印[]。
    >    
    > 4. ArrayList集合常用方法
    >
    >     ```
    >     boolean add(数据) -- 添加元素，数据类型必须为尖括号中的类型
    >     ```
    >     
    >     ```
    >     E get(int index) -- 从集合中获取元素，参数：索引编号
    >     ```
    >     
    >     ```
    >     boolean remove(int index) -- 从集合中删除元素，参数：索引编号
    >     ```
    >     
    >     ```
    >     int size() -- 获取集合的长度
    >     ```
    >     
    > 5. 泛型必须使用引用数据类型，因此对于基本数据类型我们要用他们的包装类
    >
    >    包装类地址：java.lang，所以不用导包
    >    
    >     * 基本类型 ->包装类：
    >    
    >         ```
    >         byte -> Byte
    >         short -> Short
    >         int -> Integer
    >         long -> Long
    >         float -> Float
    >         double -> Double
    >         char -> Character
    >         boolean -> Boolean
    >         ```
    >         
    >     * JDK1.7后支持自动拆箱和自动装箱
    >    
    >         自动装箱：基本类型自动变成包装类
    >         
    >         自动拆箱：包装类自动变成基本类型
    >         
## day07
### 1. String类
1. String类
    > 1. 介绍
    >
    >    字符串的类，String类位于java.lang包下，所有的"xxx"都是String类
    >    
    > 2. 特点
    >
    >    1.字符串一旦创建后不可改变，它是常量
    >    
    >    2.因为字符串不可改变，因此它可以做到共享，不用每次都开辟内存
    >    
    >    3.字符串在效果上类似于char[]数组，但是字符串底层是使用byte[]数组实现的
    >    
    > 3. 导包
    >
    >    不用
    >    
    > 4. 创建
    >
    >     1. "xxx"直接创建
    >     
    >     2. new String() -- 创建空白字符串
    >     
    >     3. new String(char[] array) -- 根据字符数组创建字符串
    >     
    >     4. new String(byte[] array) -- 根据byte数组创建字符串 
    >     
    > 5. 字符串常量池
    >
    >    程序中的任何"xxx"字符串都存在于字符串常量池中。new创建的String，如果在常量池中存在，则指向字符串在常量池中的地址；如果不存在，则在常量池中创建对应字符串，然后指向该地址。
    >    
    >     * 注意：基本数据类型使用==比较的是内容；引用数据类型用==比较的是地址值
    >    
    > 6. 字符串中的常用方法
    >
    >     1. 字符串内容比较的方法
    >     
    >         ```
    >         public boolean equals(Object obj) -- 判断两个字符串对象的内容是否相同，严格区分大小写，返回值：boolean
    >     **任何对象都能通过Object进行接收，在这里只能是字符串对象
    >         **如果一个常量和变量，如"abc"和str进行比较，我们通常这么写"abc".equals(str);
    >         ```
    >     
    >         ```
    >         public boolean equalsIgnoreCase(Object obj) -- 判断两个字符串对象的内容是否相同，不区分大小写，返回值：boolean
    >         ```
    >         
    >     2. 和获取有关的方法
    >        
    >         ```
    >         public int length() -- 获取字符串长度，返回值：字符串长度
    >         ```
    >         
    >         ```
    >         public String concat(String str) -- 拼接当前字符串和参数字符串，组成一个新的字符串，返回值：拼接后的字符串
    >         ```
    >         
    >         ```
    >         public char charAt(int index) -- 获取指定索引的字符，返回值：字符
    >         ```
    >         
    >         ```
    >         public int indexOf(String str) -- 查找参数字符串所在的索引位置，没有则返回-1，返回值：索引
    >         ```
    >         
    >     3. 字符串截取相关方法 
    >     
    >         ```
    >         public String substring(int index) -- 截取从索引到末尾的字符串，返回值：截取的字符串
    >         ```
    >         
    >         ```
    >         public String substring(int begin, int end) -- 截取[begin,end)的字符串，返回值：截取的字符串
    >         ```
    >         
    >     4. 转换方法
    >     
    >         ```
    >         public char[] toCharArray() -- 将当前字符串拆分为字符数组，返回值：字符数组
    >         ```
    >         
    >         ```
    >         public byte[] toByteArray() -- 将当前字符串转换为byte数组，返回值：byte数组
    >         ```
    >         
    >         ```
    >         public String replace(oldString, newString) -- 将字符对象中的老字符串替换为新字符串，返回值：替换完的字符对象
    >         ```
    >         
    >     5. 分割方法
    >     
    >         ```
    >         public String[] split(String regex) -- 按照正则表达式将字符串分割成若干部分，返回值：分割后的部分组成的数组
    >         **Java中正则表达式中，转义字符必须写成\\，如想要英文,，则必须写成\\,
    >         ```
    >         
    >     6. 其他常用方法
    >     
    >         ```
    >         public boolean endsWith(String str) -- 判断是否以某个字符串结尾
    >         ```
    >         
    >         ```
    >         public boolean startsWith(String str) -- 判断是否以某个字符串结尾
    >         ```
    >         
## day08
### 1. static关键字
1. static关键字
    > 1. 介绍
    >
    >    加上static，表明此方法或属性属于类。该类的对象，公用static关键字内存的数据
    >    
    > 2. 静态内容和构造器的先后
    >
    >    静态内容永远是第一个执行
    >    
    > 3. 静态代码块
    > 
    >     * 格式：
    >     
    >         ```
    >         static {
    >             内容;
    >         }
    >         ```
    >         
    >     * 特点：静态代码块中的内容永远是第一个执行，且只会执行这一次。
    >     
    >     * 用途：一次性的为静态变量赋值、初始化等操作
    >     
## day09
### 1. 继承
1. 继承
    > 1. 面向对象的三大特征
    > 
    >    封装、继承、多态
    >    
    > 2. 继承介绍
    > 
    >    继承主要解决了共性抽取的问题
    >    
    > 3. 格式
    > 
    >    public class 子类 extends 父类 {}
    >    
    > 4. 有继承关系的类中，成员变量的调用顺序
    > 
    >    直接调用：优先调用等号左边的类中成员变量，没有则向上找，找不到则报错
    >    
    >    方法中调用：该方法在哪个类中，调用哪个类的成员变量，没有则向上找，找不到则报错
    >    
    > 5. 局部变量、父类成员变量、本类成员变量重名问题
    > 
    >    局部变量：直接在局部调用
    >    
    >    父类成员变量：使用super.变量名调用
    >    
    >    本类成员变量：使用this.变量名调用
    >    
    > 6. 方法重写（Override）
    > 
    >    在有继承关系的类中，子类的方法和父类的方法名称、参数列表相同，则说子类重写了父类的方法
    >    
    >     * 注意和重载的区别
    >    
    > 7. 重写的注意事项
    > 
    >     1. 保证要重写的方法，父类和子类方法名、参数列表都相同
    >     
    >     2. 必须使用@Override注解
    >     
    >     3. 子类的返回值范围必须小于或者等于父类的返回值类型
    >     
    >     4. 子类的方法修饰符权限必须大于或者等于父类的方法修饰符权限
    >     
    >     * **权限修饰符范围：public>protected>(default)>private**
    >     
    >     * **default意思是留空，不写权限修饰符**
    >     
    > 8. 含继承关系的类，子类有重写方法时，方法的调用
    > 
    >    使用对象的调用，哪个对象调用的，就优先用谁的。
    >    
    > 9. 继承的应用场景
    > 
    >    当一个类被很多地方使用时，尽量不要直接改变这个类，使用继承
    >    
    > 10. 继承中构造方法的调用
    > 
    >     1. 父类构造方法先调用，子类构造方法后调用。子类构造方法中默认有一个super()方法去调用父类中的无参构造方法，所以是父类构造方法先调用
    >     
    >     2. 可以使用super关键字在子类构造中重载父类的构造，并且，该重载的super()方法必须是子类构造中的第一个语句。
    >     
    >     3. 只有子类的构造方法才能使用super()方法，并且在子类构造中super()方法只能有一个。
    > 11. super关键字用法
    > 
    >     1. 子类的成员方法中访问父类的成员变量
    >     
    >     2. 子类成员方法中访问父类的成员方法
    >     
    >     3. 子类构造中访问父类的构造
    >     
    > 12. this关键字用法
    > 
    >     1. 访问本类的成员变量
    >     
    >     2. 在本类的成员方法中访问另一个本类的成员方法
    >     
    >     3. 在本类的构造方法中，访问本类的另一个构造方法。这种用法必须把访问语句放在第一个，所以只能调用一次
    >     
    >     * **注意：构造方法中的this和super只能有一个被使用
    >     
    > 13. Java继承特点
    > 
    >     1. Java继承是单继承的（多继承语言：C++）
    >     
    >     2. 最高级的父类是java.lang.Object的Object类
    >     
### 2. 抽象
2. 抽象
    > 1. 抽象类
    > 
    >    权限 abstract class 类名 {}
    >    
    > 2. 抽象方法
    > 
    >    权限 abstract 返回值 方法名();
    >    
    >    * **抽象方法必须存在于抽象类**
    >    
    > 3. 使用抽象类和抽象方法
    > 
    >     1. 抽象类不允许被直接new
    >     
    >     2. 必须使用子类继承抽象父类，子类重写所有的抽象方法，重写的方法必须为非抽象方法。除非子类也是抽象类
    >     
    >     3. new子类来使用
    >     
    > 4. 抽象类使用时注意事项：
    > 
    >     1. 不允许直接new
    >     2. 允许有构造方法，这个构造方法是供子类创建对象时，初始化父类的成员时使用，可以理解为给子类构造中super()使用的
    >     3. 抽象类不一定需要抽象方法，空的抽象类也是可以的，这种类在以后的适配器模式中有用
    >     4. 子类必须重写抽象父类所有的抽象方法，除非子类也是抽象类
    >     5. 抽象类也是一个类，也可以有成员变量和成员方法等。但是必须保证抽象方法不是private的
    >     
## day10
### 1. 接口
1. 接口
    > 1. 介绍
    >
    >    接口是个引用数据类型
    >    
    > 2. 定义接口
    >
    >     public interface 接口名{}
    >     
    > 3. 接口中可以定义的内容
    >
    >     * Java7以上
    >     
    >        1、常量；2、抽象方法
    >        
    >     * Java8以上
    >     
    >        3、默认方法；4、静态方法
    >        
    >     * Java9以上
    >     
    >        5、私有方法
    >     
    > 4. 接口中的抽象方法
    >
    >    根据阿里手册开发原则，不带修饰符，如：int 方法名(参数列表);
    >    
    >    因为接口中，方法默认修饰符就是public
    >    
    > 5. 接口的使用
    >
    >     1. 必须有一个实现类实现接口
    >     
    >     2. 实现类必须重写接口的所有抽象方法
    >     
    >     3. 创建实现类的对象，调用该对象使用
    >     
    >     * **实现类必须重写接口所有方法，除非实现类是个抽象类**
    >     
    > 6. 接口中默认方法
    >
    >    使用default标识符表示默认方法，具体为：default 返回值类型 方法名(参数列表) {代码};
    >    
    >     * 作用：解决接口升级问题，防止原有的实现类无法实现新接口
    >    
    >     * 注意：接口的默认方法可以被实现类重写，但实现类不需要一定重写默认方法
    >    
    > 7. 接口中的静态方法
    >
    >    public static 返回值类型 方法名(参数,...) { 代码; }
    >    
    >     * **特别注意：接口中的静态方法只能通过接口名.静态方法名(参数,...)来调用，不能用实现类来调用**
    >    
    > 8. 接口中的私有方法
    >
    >    解决的问题：存储接口中**默认方法**的公共代码，但不会被接口外调用
    >    
    >    私有方法可以是普通的也可以是静态的
    >    
    > 9. 接口中的常量 
    >
    >    使用static关键字和final关键字修饰的属性，如：public static final 数据类型 常量名 = 值;
    >    
    >     * 注意：常量名必须为大写；常量必须赋值
    >    
    > 10. 接口中更多注意事项
    >
    >     1. 接口中不能有静态代码块
    >     
    >     2. 接口中不能有构造方法
    >     
    >     3. 一个类可以实现多个接口
    >     
    >     4. 实现类实现多个接口时，如果多个接口中的默认方法冲突，则必须重写默认方法
    >     
    >     5. 一个类中，如果他直接父类的方法和实现的接口中方法冲突，则优先使用父类的方法
    >     
### 3. 多态
3. 多态
    > 1. 介绍
    >
    >    面向对象三大特征之一。
    >    
    >    多态性：父类引用指向子类对象
    >    
    > 2. 多态写法格式 
    >
    >     1. 父类名 对象名 = new 子类();
    >     
    >     2. 接口名 对象名 = new 实现类();
    >     
    > 3. 成员变量在多态格式下的调用原则
    >
    >     * 多态写法不会改变之前说过的继承的变量访问规则：
    >     
    >        1、直接调用：等号左边的类是谁调用谁的，没有则向上查找
    >        
    >        2、间接用方法调用：方法属于谁用谁的，没有则向上查找
    >     
    > 4. 成员方法在多态格式下的调用
    >
    >     * 多态写法不会改变成员方法的访问规则：
    >     
    >        new的是哪个类，优先调用哪个类的方法，没有则向上查找
    >        
    >     * **特别注意**：
    >     
    >        如果等号左边的类没有这个方法，会编译报错，无法运行
    >        
    >        很重要的规则要记住：
    >        
    >        1、成员变量：编译看（等号）左边，运行也看（等号）左边
    >        
    >        2、成员方法：编译看（等号）左边，运行看（等号）右边
    >        
    >        因此，如果多态写法左边父类没有该方法，子类有，编译会失败，也是错误写法
    >     
    > 5. 多态写法的好处
    >
    >    多态写法可以做到不管等号右边是什么类，左边都是不变的，代码统一性高
    >    
    > 6. 对象的向上转型和对象的向下转型
    >
    >     1. 对象的向上转型
    >     
    >        其实就是多态写法：父类名称 对象名 = new 子类名称();
    >        
    >        含义：把右边的子类对象当作父类对象看待
    >        
    >         * 注意：
    >        
    >            1、向上转型一定是安全的，因为它是从小范围转向大范围，类似于基本数据类型转换时byte转换成int一定是没问题的
    >            
    >            2、向上转型也有弊端，即只能调用父类特有的方法和父子公共的方法，不能使用子类的特有方法
    >        
    >     2. 对象的向下转型
    >     
    >        用于还原向上转型，类似于基本数据类型中的强制类型转换
    >        
    >        子类名称 对象名 = (子类名称)父类对象名
    >        
    >         * 注意：
    >        
    >            1、没有经过向上转型的对象强行向下转型会报错
    >            
    >            2、向下转型成别的子类对象时会异常，类似于基本数据类型强制类型转换时会有精度损失的问题
    >            
    >         * **讨论：向下转型时，如何知道一个经过向上转型后变成的父类对象，是通过什么子类对象转型的呢？**
    >        
    >            通过instanceof做判断，具体用法：要判断的对象名 instanceof 子类名称，判断后返回boolean类型的值。因此，进行向下转型时，一定要进行instanceof判断
    >            
## day11
### 1. final关键字
1. final关键字
    > 1. 常见用法
    >
    >     1. 修饰类
    >     
    >        public final class {}
    >        
    >        作用：不允许被任何类继承
    >        
    >     2. 修饰方法
    >     
    >        public final 返回值类型 方法名() {}
    >        
    >        作用：不允许被重写
    >        
    >        * 注意：final和abstract有冲突，因为抽象类中的抽象方法必须重写，而final不允许重写
    >        
    >     3. 修饰局部变量
    >        final 数据类型 变量名 = 值
    >        用处：表明局部变量不可以被重新赋值
    >        
    >        * 注意：对于基本数据类型来说是值不变；对于引用数据类型指的是地址值不可以变
    >     4. 修饰成员变量
    >     
    >        由于成员变量有默认值，所以必须要进行手动赋值，要么直接赋值，要么构造方法对其赋值
    >        
    >        注意：如果用构造进行赋值，要保证所有的重载的构造都要对其赋值，否则报错，因为如果用别的构造结果会没赋值
    >        
### 2. 权限修饰符
2. 权限修饰符
    > 1. public -- 用public修饰，在所有位置都可以访问
    > 
    > 2. protected	-- 用protected修饰，在本类、同一个包的类、不同包的子类下可以访问，但在不同包的不同类中无法访问
    > 
    > 3. (default)不写修饰符 -- 不写权限修饰符，只在本类和同一个包的类中可以访问
    > 
    > 4. private -- 用private修饰，只在本类中可以使用
    > 
### 3. 内部类
3. 内部类
    > 1. 介绍
    > 
    >    一个类内部包含另一个类，二者关系是相互联系的，无法单独使用
    >    
    >    通过运行可以发现，编译文件有两个，一个是类名称.class文件，一个是类名称$内部类名称.class文件。
    >    
    >    可以看出$符号在java中很特殊，不要轻易用
    >    
    > 2. 内部类分类：
    > 
    >     1. 成员内部类：写在类中
    >     
    >     2. 局部内部类：写在方法中
    >     
    >     3. 匿名内部类（属于局部内部类的一种特殊形式）
    >     
    >        这是最重要的内部类，一定要记住。
    >        
    >        使用场景：如果接口的实现类或者父类的子类只需要使用一次，就可以使用匿名内部类
    > 4. 内部类和外部类的修饰符
    > 
    >    外部类可用：public、(default)
    >    
    >    成员内部类：public、protected、(default)、private
    >    
    >    局部内部类：无修饰符，什么都不写
    >    
    > 5. 内部类中final问题
    > 
    >    局部内部类，如果想要访问这个方法的局部变量，必须保证这个局部变量是有效final的
          * 有效final的意思是只赋值了一次，之后没有再改变的，不一定要加final关键字。有效final的概念是从Java8之后开始的，Java8之前必须要加final关键字
    >    
    >    

# Java进阶
## day01
### 1. Object类
1. Object类
    > 1. 介绍
    > 
    >    是所有类的父类，存在于java.lang包内，不用导包
    > 2. 方法
    > 
    >     ```
    >     equals(Object obj) -- 指示其他对象与此对象地址值是否相等，返回值：boolean类型
    >     ```
    >     
    >     * **注意：String类重写了equals()方法，因此String类的equals()方法作用不同**
    >     * equals()方法隐含了多态关系，即形参是Object，实参是其他类的对象，而其他类都是Object类的子类，多态有一个弊端，即无法使用子类特有的属性和方法，所以需要先对形参Object向下转型。
    >     
    >     ```
    >     toString() -- 返回该对象的字符串表示。返回值："对象的包路径.对象的地址值"这样形式的字符串。所有的对象，直接打印对象的名字相当于使用toString()方法
    >     ```
    >     
### 2. Objects类
2. Objects类
    > 1. 简介
    > 
    >    对象工具类，用来操作对象，由一系列静态方法构成，是**空指针安全的**。它存在于java.until包下。
    >    
    >     * 空指针安全：哪怕有空指针，也不会出异常
    >    
    > 2. 方法
    > 
    >     ```
    >     equals(Object a, Object b) -- 比较两个对象是否相等
    >     ```
    >     
### 3. 日期时间类
#### 1. Date类
1. Date类
    >
    > 1. 简介
    >    
    >    位于java.until包下，表示精确的时间，精确到毫秒
    >    
    > 2. 构造方法
    >    
    >     ```
    >     new Date()  -- 空参构造，获取当前系统的日期时间，返回值：系统日期时间
    >     ```
    >     
    >     ```
    >     new Date(long date)  -- 带参数构造，参数：毫秒值，返回值：参数的毫秒值转换的日期
    >     ```
    >     
    > 3. 方法
    >    
    >     ```
    >     getTime() -- 把日期转换为毫秒值，返回值：毫秒值
    >     ```
    >     
    >     *  功能和System.currentTimeMillis()一样
    >     
#### 2. DateFormat类
2. DateFormat类
    > 1.简介
    >
    > 位于java.text包下，格式化日期的抽象类，我们可以**使用它的子类SimpleDateFormat**
    >
    > 作用：第一，格式化日期（日期->文本）；第二，解析（文本->日期）
    >
    > 2. 构造方法
    >
    >     ```
    >     new SimpleDateFormat(String pattern) -- 指定对应的日期模式，参数：指定的模式
    >     ```
    >     
    >      * 日期模式字符如下：
    >     
    >          ```
    >          y - 年;M - 月;d - 日; H - 时;m - 分;s - 秒
    >          例子："yyyy/MM/dd HH:mm:ss"
    >          ```
    > 3. 成员方法
    >
    >     ```
    >     format(Date date) -- 按照构造器中给定格式，把Date日期格式化为文本，返回值：String对象
    >     ```
    >     
    >     ```
    >     parse(String text) -- 把指定日期模式的文本解析为Date日期，返回值：Date对象
    >     ```
    >     
    >     * parse()声明ParseException解析异常，如果字符串和构造方法中的模式不匹配，就会抛出这个异常，调用了一个声明异常的方法，必须解决这个异常，要么throws继续声明这个抛出异常的方法，要么try...catch自己解决这个异常
    >     
#### 3. Calendar类
3. Calendar类
    > 1. 简介
    >
    >    与日历相关，提供了许多操作日历字段的方法。它是一个抽象类，存在于java.until包下，不能直接new。
    >    
    > 2. 创建
    >
    >    Calendar类是抽象类，不能用new创建。需要使用Calendar类中提供的静态方法来获取Calendar的实例：
    >    
    >     ```
    >     Calendar 对象名 = Calendar.getInstance();//多态
    >     ```
    >    
    > 3. 常用的成员方法
    >
    >     ```
    >     void get(int field) -- 参数：日历字段，返回值：给定日历字段的int值
    >     ```
    >     
    >     ```
    >     void set(int field, int value) -- 帮给定的字段设置给定的值，参数1：日历字段，参数2：值，返回值：void
    >     ```
    >     
    >     * set()可以通过重载形式：set(年的值, 月的值, 天的值)来做到一次赋值多个的效果
    >     
    >     ```
    >     void add(int field, int amount) -- 根据给定的日历字段，添加或者减去时间量，参数1：日历字段，参数2：值，返回值：void
    >     ```
    >     
    >     ```
    >     Date getTime() -- 返回值：此Calendar时间值的Date对象
    >     ```
    >     
    >     * **int field可以通过Calendar类的静态成员变量直接获取：静态变量日历字段的名包括：YEAR, MONTH, DATE, DAY_OF_MONTH, HOUR, MINUTE, SECOND**
    >     
    >     * **注意：MONTH，西方日历中，月份是0~11**
    >     
### 4. System类
4. System类
    > 1. 简介
    >
    >    存在于java.lang包下，具有大量的静态方法，可以获取于系统相关的信息和系统级的操作
    > 2. 常用的方法
    >
    >     ```
    >     public static long currentTimeMillis() -- 返回值：当前时间的毫秒值。一般用此方法测试程序运行的效率
    >     ```
    >     
    >     ```
    >     public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length) -- 将源数组中指定数据拷贝到目标数组中。参数1：源数组，参数2：源数组起始位置，参数3：目标数组，参数4：目标数组起始位置，参数5：复制数据的长度
    >     ```
    >     
### 5. StringBuilder类
5. StringBuilder类
    > 1. 出现背景
    >
    >    我们已知，字符串是常量，一旦被创建就无法改变，因为字符串底层封装是这样的：private final byte[] value
    >    
    >    如果我们进行字符串的相加，则内存中会有多个字符串，资源占用率很高，效率低下，例如：```String s = "a" + "b" + "c";``，其内存中是这样："a","b","c"各占一个byte[]数组，先"a" + "b"变为的"ab"又占一个byte[]数组，最终的"abc"还占一个byte[]数组，最终，String s需要五个byte[]数组。
    >    
    >    为了提高效率，我们使用StringBuilder类，又称其为字符串缓冲区
    >    
    > 2. 简介
    >
    >    StringBuilder类，又称其为字符串缓冲区，它底层是一个没有被final修饰的byte[]数组，因此它的长度可以变化
    >    
    >    它的初始容量为16个字节，如果使用StringBuilder类完成上述的例子，则会仅用一个byte[]数组便可以完成，提升了效率，具体见视频。当然，如果需要的长度长于16，则它会自动扩容，变为32个字节。
    >    
    >    位于java.lang包下，不用导包
    >    
    > 3. 构造方法
    > 
    >     ```
    >     new StringBuilder() -- 创建一个空的StringBuilder容器
    >     ```
    >     
    >     ```
    >     new StringBuilder(String str) -- 创建一个空StringBuilder容器，将参数的字符串添加进去
    >     ```
    >     
    > 4. 常用成员方法
    > 
    >     ```
    >     public StringBuilder append(...) -- 参数：任意的数据类型，返回值：添加了参数数据的对象本身；由于返回值是对象本身，所以不需要接收返回值，也可以使用链式写法
    >     ```
    >     
    >     ```
    >      public Sting toString() -- 把StringBuilder对象转换成一个String对象，返回值：String对象
    >     ```
    >     
    >     ```
    >     public StringBuilder reverse() -- 将缓冲区内容反转，返回值：对象本身
    >     ```
    >
## day02
### 1. Collection集合
1. Collection集合
    > 1. 集合概述
    > 
    >    集合是存储数据的容器，和数组的区别：数组长度不可变，集合长度可变
    >    
    > 2. 集合框架
    > 
    >    集合按照存储结构可以分为两类：单列集合Collection，双列集合Map
    >    
    >     * Collection接口：定义了所有单列集合的共性方法，没有带索引的方法
    >    
    >         * List接口：继承自Collection集合。抽取了Vector集合、ArrayList集合、LinkedList集合共性形成的接口。List抽取的共性：1.允许重复元素；2.有序集合；3.带索引
    >         
    >             * Vector集合
    >             
    >             * ArrayList集合：底层由数组实现
    >             
    >             * LinkedList集合：底层由LinkedList实现
    >             
    >         * Set接口：继承自Collection接口。抽取了TreeSet集合、HashSet集合的共性形成的集合。共性如下：1.不允许存入相同元素；2.无索引。注意：Set下的集合有的有序，有的无序
    >         
    >             * TreeSet集合
    >             
    >             * HashSet集合：底层由哈希表+红黑树实现。无索引，不允许存储重复元素，无序。
    >             
    >                 * LinkedHashSet集合：是HashSet集合类的子类。底层由哈希表+链表实现。无索引，不允许存储重复元素，可以保证有序。
    >    
    > 3. Collection集合共性方法
    > 
    >     ```
    >     public boolean add(E e) -- 向集合中添加元素
    >     ```
    >     
    >     ```
    >     public boolean remove(E e) -- 删除集合中的指定元素 
    >     ```
    >     
    >     ```
    >     public void clear() -- 清空集合元素
    >     ```
    >     
    >     ```
    >     public boolean isEmpty() -- 判断集合是否为空
    >     ```
    >     
    >     ```
    >     public int size() -- 获取集合长度
    >     ```
    >     
    >     ```
    >     public Object[] toArray() -- 将集合转为一个Object对象数组
    >     ```
    >     
#### 1. Iterator迭代器
1. Iteratro迭代器
    > 1. Iteratro接口
    > 
    >     1. 简介
    >     
    >        如Set集合是无索引的，因此无法使用for循环遍历。JDK提供一个接口，可以做任意类型Collection接口下集合的遍历。
    >        
    >        **Iterator也是Java集合的一种，但是它不存数据，而是专门用于遍历Collection接口下的集合的**
    >        
    >    2. 集合迭代的概念
    >    
    >       先判断集合是否为空，不为空，则取出一个集合中的元素，继续上述过程指导集合为空
    >    3. Iterator迭代器
    >    
    >       Iterator接口的实现类的实例
    >       
    >    4. Iteratro迭代器的获取
    >    
    >       使用Collection接口中的一个方法iterator()，该方法返回Iterator接口实现类的对象：
    >        ```
    >        Iterator<泛型> 对象名 = 集合名.iterator();
    >        ```
    >        * 注意：Iterator迭代器的泛型和集合泛型保持一致
    >    5. Iterator接口的方法
    >    
    >        ```
    >        public boolean hasNext() -- 判断一个集合是否有元素
    >        ```
    >        
    >        ```
    >        public E next() -- 获取集合中一个元素，并让指针后移
    >        ```
    >        
    >    6. 使用步骤
    >    
    >       1.根据集合对象来创建迭代器
    >       
    >       2.使用while循环来遍历集合
    >       
    >    7. 增强for循环
    >    
    >       Java中的foreach循环，专门用来遍历数组和集合，其内部也是通过迭代器实现的，所有单列集合都可以使用foreach。由于它是通过迭代器实现的，所以在遍历的过程中，不能进行集合的增删操作
    > 
#### 2. 泛型
2. 泛型
    > 1. 简介
    >
    >    泛型其实就是未知的数据类型，当不知道用什么类型时，使用泛型，泛型默认为Object类型。
    >    
    >    泛型可以看作是用来接收数据类型的变量，是数据类型的占位符，用一个大写字母T或E来做泛型。
    >    
    >    集合的泛型的数据类型在创建对象时确定，如：```ArrayList<String> str = new ArrayList<>();//这里就确定了泛型的类型为String```，确定了泛型的数据类型后，会把这个数据类型传递给这个类，把所有的泛型用该数据类型替换
    >    
    > 2. 集合使用泛型与不使用泛型的比较
    >
    >     * 不使用泛型：
    >     
    >         * 好处：不使用泛型，可以存储不同的数据类型
    >         
    >         * 坏处：不安全，会引发异常
    >         
    >     * 使用泛型：
    >     
    >         * 好处： 1、存储的什么类型，取出来的还是什么类型，不用做类型转换；2、把运行期（点击运行后）的异常，提前到了编译期（写代码时）
    >         
    >         * 弊端：泛型为什么类型，只能存储什么类型的数据，可以忽略这个弊端
    >     
    > 3. 泛型定义与使用
    >
    >     1. 定义与使用带泛型的类
    >     
    >     2. 定义与使用含有泛型的方法
    >     
    >     3. 定义与使用含有泛型的接口
    >     
    > 4. 泛型的通配符
    >
    >     1. 介绍
    >     
    >       ``` <?>```，表示传递的类型中，泛型数据类型不确定，但是使用了这个通配符，集合中的元素无法使用自身的方法，只能使用Object类共有的方法
    >     
    >     2. 泛型通配符的使用
    >     
    >        **不能在创建对象时使用**，如：```ArrayList<?> list = new ArrayList<>();```。
    >        
    >        **只能用在方法的参数上**，如：```public static void pirntArray(ArrayList<?> list) { 代码; }```
    >        
    >     3. 泛型通配符的高级用法：通过泛型通配符设置泛型的上限和下限
    >     
    >         1. 介绍
    >         
    >            之前设置泛型，实际上任意的类都可以使用，但是我们可以指定一个泛型的上限和下限
    >            
    >         2. 设置上下限格式：
    >         
    >            上限：```<? extends 具体类型>：只能使用该类型和该类型的子类```
    >            
    >            下限：```<? super 泛型>```：只能使用该类型和该类型的父类
    >            
    >         3. 如何理解该类型和类型的子类
    >         
    >            类型之间是有继承关系的，如Object类型是所有类型的父类，Integer类型是Number类型的子类
    >            
## day03 

### 1. Set集合
2. Set集合
   > 1. 介绍
   > 
   >    是Collection接口的子类，位于java.until包
   >    
   > 2. 特点
   > 
   >     1. 没有索引，没有带索引的方法，不能用for循环遍历
   >     
   >     2. 不能存储重复的数据
   >     
   > 3. Set接口的实现类
   > 
   >     1. HashSet集合
   >     
   >         1. 介绍
   >         
   >            由Hash表提供支持，不保证迭代的顺序，特别是它不保证该顺序恒久不变
   >            
   >         2. 特点
   >         
   >            1、没有索引，没有带索引的方法，不能用for循环遍历
   >            
   >            2、不能存储重复的数据
   >            
   >            3、它是无序的集合，存储与取出元素的顺序可能不一致
   >            
   >            4、它底层是Hash表结构，所以查询速度非常的快
   >            
   >         3. 方法
   >         
   >            使用Collection接口中公用方法即可
   >            
   >         4. 遍历
   >         
   >            使用Iterator或增强for
   >            
   >         5. 哈希值
   >         
   >            一个十进制的整数，由系统随机给出，是对象的逻辑地址，不是实际存储的物理地址。
   >            Object类中的一个方法可以查看调用一个元素的哈希值：
   >            
   >            ```int hashCode() -- 查看哈希值```
   >            
   >            可以重写hashCode()方法，手动指定hash值
   >            
   >            由于基本类型有对应的包装类，所以用包装类调用hashCode()方法来确定基本数据类型数据的hash值 
   >            
   >         6. 哈希表
   >         
   >            它是HashSet集合存储数据的结构。
   >            
   >            JDK1.8之前，哈希表=数组+链表组成；JDK1.8之后，哈希表=数组+链表+红黑树组成
   >            哈希表特点：速度快
   >            
   >            JDK1.8之后的哈希表存储数据原理：数组结构进行分组，相同哈希值的数据分到一组。每一组中相同哈希值的元素通过链表和红黑树连接，具体是如果链表长度小于8位则由链表连接数据，如果超过8位，则链表转换为红黑树进行数据连接
   >            
   >         7. HashSet集合不允许重复的原理
   >         
   >            在调用add()方法给Set集合添加元素时，Set集合会先调用hashCode()方法和equals()方法，判断元素是否重复：
   >            
   >            例如：假设用add()方法添加一个哈希值为96354的元素s1
   >            
   >            add()方法会先调用该元素的hashCode()方法获取元素的hash值，在集合中找有没有hash值为96354的分组，在分组中找有没有这个元素，没有则连接这个元素。
   >            
   >            如果有（hash冲突）s2hash值也是96354，则会调用equals()方法比较两个元素s1.equals(s2)，返回true，则两个元素相同，不会存储，如果返回false，则说明hash值相同内容不同，则会存储。
   >            
   >            注意：综上，一个元素对象如果想被存储到HashSet集合，则要重写元素对象的hashCode()和equals()方法。
   >            
   >         8. HashSet集合存储自定义类型的元素
   >         
   >            **必须重写自己的hashCode()和equals()方法**
   >            
   >            Java中的String类、各种包装类等Java都已经重写好了这两个方法，自己封装的类要手动重写这两个方法
   >         
   >     2. LinkedHashSet集合
   >     
   >         1. 介绍
   >         
   >            是HashSet类的子类，继承了HashSet，也存在于java.until包下
   >            
   >         2. 特点
   >         
   >            底层由哈希表+链表实现，链表保证了元素的有序
   >            
   >            因此特点为：不允许重复，有序
   >            
### 2. 可变参数
2. 可变参数
   > 1. 介绍
   >
   >    JDK1.5之后出现的新特性。
   >    
   > 2. 使用前提：参数列表的数据类型确定，但是参数的个数不确定
   >
   > 3. 可变参数底层原理：底层由数组实现，根据传递进来的参数个数不同，创建不同长度的数组来存储参数，传参个数0~n个
   >
   > 4. 使用格式：定义方法时使用
   >
   >     ```
   >     修饰符 返回值 方法名(数据类型...变量名) {
   >     	变量名就是数组名，可以对数组进行操作来操作参数
   >     }
   >     ```
   >     
### 3. Collections工具类
3. Collections工具类
   > 1. 介绍
   >
   >    用于操作集合的工具类，存在于java.until包下
   >    
   > 2. 部分方法
   >
   >     ```
   >     public static <T> boolean addAll(Collection<T> c, T...elements) -- 往某个集合添加若干个元素，返回值：boolean
   >     ```
   >     
   >     ```
   >     public static void shuffle(List<?> list) -- 打乱某个集合的顺序，返回值：void
   >     ```
   >     
   >     ```
   >     public static <T> void sort(List<T> list) -- 让某个集合中元素按照默认规则排序，返回值：排好序的集合
   >     ```
   >     
   >     * **注意事项：**
   >     
   >        要想使用sort()方法实现集合默认排序，集合中元素必须实现Comparable<E>接口，规定泛型，并且还要重写compareTo()方法，添加比较规则
   >        
   >        规则是这样的：返回值为自己减去参数就是升序，反之就是降序。如果自定义类的对象作为集合元素，按照对象中某个属性进行排序，则只需要this.属性名和参数.属性名按照前边的规则就可以了
   >     
   >     ```
   >     public static <T> void sort(List<T> list, Comparator<? super T>) -- 将集合中元素按照指定规则排序，返回值：排好序的集合
   >     ```
   >     
   >     * **注意事项：**
   >     
   >        第二个参数为实现了Comparator接口的实现类的对象，我们可以使用匿名对象来作为第二个参数，具体如下：
   >        
   >         ```
   >        new Comparator<具体的泛型数据类型>() {
   >        	@overwrite //重写的比较规则
   >        	public int compare(Integer o1, Integer o2) {
   >        		/*return o1 - o2;升序*/
   >        		return o2 - o1;降序
   >        		/*如果自定义类的对象作为集合元素，按照对象中某个属性进行排序，则
   >        		只需要o1.属性名和o2.属性名按照前边的规则就可以了*/
   >        	}
   >        }
   >         ```
   > 
   



## day04
## day05
## day06
## day07
### 1. 线程通信
   1. **线程通信**
       > 1. *为什么要线程通信*  
       >
       >     多线程并发执行，cpu默认随即切换线程，当多个线程一起完成任务，我们需要他们有规律时，需要线程之间的协调，以达到共同操作一份数据的目的。
       >
       > 2. *如何保证线程间有效利用资源*  
       >
       >     有效利用资源即线程之间共同操作一份数据，避免对同一共享变量的争夺，我们需要用到等待唤醒机制
       >
       > 3. *等待唤醒机制*  
       >     1. 介绍  
       >     
       >         这是种线程之间的协作机制。一般谈到线程我们会想到竞争（race），如争夺锁，但是线程之间也会进行协作，这就要利用协作机制。一个线程进行了规定操作后，进入等待状态（使用wait()方法），当其他线程完成代码后，进行唤醒（使用notify()方法）；如果有多个线程等待中，可以使用notifyAll()方法进行全部唤醒。  
       >
       >         wait/notify就是一种协作机制
       
       >     2. 方法
       >
       >         1. wait() -- 线程不再参与调度，进入wait set，因此不会使用cpu资源和竞争锁，线程状态变为WAITING，直到别的线程执行notify/notifyAll唤醒等待的线程从wait set释放，进入调度队列（ready queue）
       >
       >         2. notify() -- 选取所通知对象中的wait set的一个线程释放
       >
       >         3. notifyAll() -- 选取所通知对象中的wait set的全部线程释放  
       >    
       >             **注意：不管通知几个线程释放，他们都需要先争夺锁，争夺到了才从WAITING状态变为RUNNABLE状态；没争夺到锁，则从wait set释放后进入entry set，从WAITING状态变为BLOCKED状态**  
       >    
       >             **使用细节：**   
       >             
       >             **1. wait()、notify()方法必须由同一个锁对象调用，因为：同一个锁对象使用notify可以唤醒使用同一个锁对象wait的线程**  
       >             
       >             **2. wait()、notify()方法是Object类的方法，锁对象是任意对象，所有的对象所属的类都继承了Object类，因此锁对象可以调用这几个方法**  
       >
       >             **3. 因为wait()、notify()方法必须由锁对象调用，因此只能在同步代码块或同步函数中使用这些方法**
### 2. 线程池
   2. **线程池**
       > 1. *介绍*  
       >
       >     每次使用线程就去创建一个线程虽然很方便，但是会有一个问题：如果并发的线程数量很多，每一个线程都是执行一个很短时间的任务，频繁创建线程会大大降低系统的效率, 因为创建线程和销毁线程都需要时间。因此我们可以使得一个线程执行完任务后不被销毁，以后还能完成其他任务，线程池便可以达到这样的目的。
       >
       > 2. *创建线程池*  
       >
       >     使用集合创建线程池，推荐使用LinkedList集合，LinkedList<Thread>  
       >
       >     线程池中使用了队列的思想  
       >
       >     使用步骤：  
       >     1. 当程序第一次启动时，我们可以创建多个线程保存到集合中：使用add()方法添加线程  
       >
       >     2. 当我们要使用线程时，从线程池中获取线程：使用remove(xxx)方法，方法返回值就是被移出的元素，在线程池中就是单个的线程  
       >
       >     3. 使用完线程归还线程池：使用add()方法重新添加  
       >
       > 3. 线程池原理  
       >
       >     见视频
       >
       > 4. 使用线程池  
       >
       >     从JDK1.5之后，线程池不用手动创建，Java自动创建了线程池，我们只需使用 
       >
       >     > java.until.concurrent.Executors类：是生产线程池的工厂类，在Executors类中有一个静态方法可以生产线程池：
       >     >
       >     > ```
       >     > static ExecutorService newFixedThreadPool(int nThreads) -- 创建一个可重用的固定线程数的线程池，参数：线程数，返回值：ExecutorService接口的实现类对象
       >     > ```
       >     >
       >     > 我们可以使用ExecutorService接口来接收（面向接口编程）：
       >     >
       >     > ```
       >     > ExecutorService 线程池名 = Executors.newFixedThreadPool(线程数);
       >     > ```
       >    
       >     > java.until.concurrent.ExecutorService接口：线程池的接口
       >     > 方法：
       >     >
       >     > ```
       >     > submit(Runnable task) -- 获取线程，调用start()方法执行线程任务
       >     >```
       >     >
       >     >```
       >     > shutdown() -- 关闭/销毁线程池 (了解即可，一般不用)
       >     > ```
       >
       >     > 线程池使用步骤：  
       >     > 1. 通过java.until.concurrent.Executors类的静态方法生产线程池  
       >     > 2. 创建一个Runnable接口的实现类，重写run()方法设置线程任务  
       >     > 3. 调用java.until.concurrent.ExecutorService接口的方法submit()，传递Runnable实现类的对象开启线程
### 3. Lambda表达式
   3. **Lambda表达式**
       > 1. 函数式编程 
       > 
       >     面向对象编程：通过调用对象的方式完成某件事
       >   
       >     函数式编程：只要能获取到结果，忽略完成的过程
       >
       > 2. Lambda表达式简介  
       >
       >     JDK1.8之后出现的特性
       >
       > 3. 匿名内部类的分析  
       >
       >     省去了实现类的定义，但是很复杂。
       >   
       >     如果匿名内部类内部只有一个重写的方法，可以被Lambda表达式替换
       > 4. Lambda标准格式 
       > 
       >     ```java
       >       (参数列表) -> {一些重写方法的代码}
       >     ```
       > 5. Lambda省略  
       >
       >     可以省略的情况：
       >     1. (参数列表)参数类型可以省略
       >     2. 只有一个参数时可以省略()
       >     3. {}中只有一个return语句，则可以省略{}、return、;，并且省略时如果三个都有必须一起省略
***

## day08
### 1. File类
1. **File类**
   
    > 1. 介绍  
    >
    >     java.io.File是文件和目录路径名的抽象表示，主要用于文件和目录的创建、查找、删除操作
    >
    >     java.io.File类是与系统无关的类，任何操作系统都可以使用
    >     
    > 2. 静态成员变量  
    >
    >     static String pathSeparator -- 与系统有关的路径分隔符，表示为一个字符串  
    >
    >     static char pathSeparatorChar -- 与系统有关的路径分隔符  
    >
    >     &nbsp;&nbsp;&nbsp;&nbsp;**路径分隔符：windows系统下是;，Linux系统下是:**  
    >
    >     static String separator -- 与系统有关的名称分隔符，表示为一个字符串  
    >
    >     static char separatorChar -- 与系统有关的名称分隔符  
    >
    >     &nbsp;&nbsp;&nbsp;&nbsp;**名称分隔符：windows系统下是\，Linux系统下是/** 
    >     
    > 3. File类构造方法  
    >
    >     **注意：路径中\要写成\\\\的形式**  
    >
    >     File(String pathname) -- 通过给定路径字符串转换为抽象路径来创建一个File实例  
    >
    >     &nbsp;&nbsp;&nbsp;&nbsp;**注意：路径可以是文件路径也可以是文件夹路径;<br>
    >
    >     &nbsp;&nbsp;&nbsp;&nbsp;路径可以是存在的，也可以是不存在的，因为我们只是把路径封装成为File对象，不考虑真假<br>
    >
    >     &nbsp;&nbsp;&nbsp;&nbsp;通过打印对象名得到了路径名可知，File类重写了toString()方法**  
    >
    >     File(String parent, String child) -- 根据parent路径字符串和child路径字符串创建一个File实例  
    >
    >     &nbsp;&nbsp;&nbsp;&nbsp;**注意：把路径分为两部分父路径和子路径，好处为：父路径，子路径可以自由变化**  
    >
    >     File(File parent, String child) -- 根据parent抽象路径名和child子路径创建File实例  
    >
    >     &nbsp;&nbsp;&nbsp;&nbsp;**注意：好处：1、可以自由变化 2、由于父路径是File对象，因此可以使用File的方法对路径名进行一些操作，然后再创建对象**  
    >     
    > 4. File类常用方法  
    >     1. 获取功能 
    >     
    >         ```
    >         public String getAbsolutePath() -- 返回File类绝对路径的字符串，无论构造方法中传递的是相对路径还是绝对路径，返回的都是绝对路径
    >         ```
    >         ```
    >         public String getPath() -- 将File转化为路径字符串，构造方法中传递的什么路径，就是什么路径
    >         ```
    >         &nbsp;&nbsp;&nbsp;&nbsp;**注意：File类重写的toString()方法，内部就是利用了getPath()方法**  
    >         ```
    >         public String getName() -- 返回由File表示的文件或目录名称，就是获取的构造方法的结尾部分的文件或文件夹
    >         ```
    >         ```
    >         public long length() -- 返回File表示的文件的长度，以字节为单位，如果路径不存在，返回0；文件夹没有大小概念，因此路径为文件夹调用此方法也返回0
    >         ```
    >         
    >     2. 判断功能  
    >         ```
    >         public boolean exists() -- 判断此File表示的目录或文件是否存在
    >         ```
    >         ```
    >         public boolean isDirectory() -- 判断File表示的是否为目录，即路径是否以文件夹结尾
    >         ```
    >         ```
    >         public boolean isFile() -- 判断File表示的是否为文件，即路径是否以文件结尾
    >         ```
    >
    >         **注意事项：**  
    >     
    >         1.以上的两个判断目录和文件的方法必须保证路径是存在的然后判断，否则直接返回false 
    >         2.以上的两个判断目录和文件的方法互斥，要么是文件要么是目录
    >         
    >     3. 创建删除功能    
    >     
    >         ```
    >         public boolean createNewFile() -- 当且仅当File代表文件不存在时，创建一个新文件，成功返回true，失败返回false
    >         ```
    >         **注意：**  
    >     
    >    1.此方法创建的是文件，不会创建文件夹  
    >    
    >    2.如果路径必须存在，否则抛出异常  
    >    
    >    3.此方法会抛出异常，我们必须处理
    >    
    >         ```
    >         public boolean delete() -- 删除File代表的文件或文件夹，成功返回true，失败返回false
    >         ```
    >         
    >         **注意：此方法删除是直接删除，不会走回收站，所以一定谨慎使用**  
    >         
    >         ```
    >         public boolean mkdir() -- 创建File表示的目录，成功返回true，失败返回false
    >         ```
    >         
    >         ```
    >         public boolean mkdirs() -- 创建File表示的目录，包括任何必须但是不存在的父目录，成功返回true，失败返回false
    >         ```
    >    
    >     4. 遍历目录  
    >    
    >         ```
    >         public String[] list() -- 返回String类型的数组，表示该路径下的所有子文件和目录
    >         ```
    >         
    >         ```
    >         public File[] listFiles() -- 返回File对象数组，会把构造方法的路径中的子文件和目录封装成一个个的File对象，File对象构成File数组
    >         ```
    >         **注意：以上两个方法都是遍历构造方法中给出的目录，如果构造方法中的路径不存在，抛出空指针异常；如果构造方法中路径不是一个目录，也会抛出空指针异常**
    >         
### 2. 递归
2. **递归**
   
    > 1. 递归分类  
    >
    >    直接递归：方法调用自己  
    >
    >    间接递归：比如A方法调用B方法，B方法调用C方法，C方法调用A方法形成闭环
    > 2. 递归注意事项
    >
    >     1. 递归必须要有终止条件，否则会栈内存溢出
    >     2. 递归次数不能太多，否则会栈内存溢出
    >     3. 构造方法禁止递归
    > 3. 递归使用的前提 
    > 
    >     方法体不变，参数每次变化
    >     
### 3. 文件过滤器
3. **文件过滤器**  
    listFiles()有两个重载方法listFiles(FileFilter filter)和listFiles(FilenameFilter filter)，方法的参数传递的就是过滤器
    
    >    1. java.io.FileFilter是一个接口，是File的过滤器  ，该接口中只有一个方法：  
    >
    >        ```
    >        boolean accept(File pathname) -- 测试pathname是否包含在当前File目录中，存在返回true，否则返回false，参数：遍历的File目录的每一个File对象
    >        ```
    >        
    >        FileFilter接口没有实现类，所以我们自己创建一个实现类，重写accept方法在方法中定义过滤规则。可以使用new匿名内部类作为new实现类来直接作为listFiles(FileFilter filter)的参数，或者使用Lambda表达式
    >        
    >    2. java.io.FilenameFilter是一个接口，是文件名称过滤器，该接口中只有一个方法：  
    >
    >       ```
    >       boolean accept(File dir, String name) -- 方法里面自己定义规则测试指定文件是否应该包含在某一文件列表中，存在返回true，否则返回false，参数1：遍历的File目录的每一个File对象，参数2：便利的File目录的每一个文件/文件夹名称
    >       ```
    >       
    >       FilenameFilter接口没有实现类，所以我们自己创建一个实现类，重写accept方法在方法中定义过滤规则。可以使用new匿名内部类作为new实现类来直接作为listFiles(FilenameFilter filter)的参数，或者使用Lambda表达式
## day09
### 1. IO
1. IO
    > 1. IO介绍  
    >    
    >    把数据的传输，看成时数据的流动，即流Stream。以内存为基准，输入input和输出output，即输入内存时输入流，输出内存是输出流  
    >
    >    Java中I/O操作主要是java.io包下的内容，输入又叫读数据，即把硬盘的数据读出到内存；输出又叫写数据，即把内存的数据写入硬盘
    > 2. 字节流  
    >
    >    计算机一切的数据都是字节，因此字节流可以传输任何的数据。我们要明确，一切的流对象，底层都是二进制数据。  
    >    1. 字节输出流（OutputStream）  
    >
    >       java.io.OutputStream是一个抽象类，表示所有字节输出流的基类。  
    >       1. 公共方法  
    >         ```
    >         public void close() -- 关闭此流，并释放资源
    >         ```
    >         ```
    >         public void flush()
    >         ```
    >         ```
    >         public void write(byte[] b) -- 将指定的b数组写入指定的字节输出流
    >         ```
    >         **注意：如果第一个字节是正数，查询ASCII表；如果第一个字节是负数，则第一个字节和第二个字节组合，查询其他表。类推到整个字节数组**  
    >         ```
    >         public void write(byte[] b, int off, int len) -- 把字节数组的一部分写入到字节输出流，参数1：字节数组，参数2：数组开始的索引，参数3：写入的长度
    >         ```
    >         ```
    >         public abstract void write(int b) -- 写入指定的字节输出流
    >         ```
    >         **注意：想写入字符，可以把字符串转化为字符数组，然后使用上述的write方法，String类中有一个方法getBytes()，可以把字符串转化为字节数组。** 
    >      2. 它的子类  
    >
    >          一共六个，子类的命名格式都为子类功能OutputStream  
    >          1. 文件字节输出流FileOutputStream  
    >
    >             java.io.FileOutputStream继承了java.io.OutputStream，又叫文件字节输出流  
    >              1. 作用  
    >
    >                   把内存中的数据写入到硬盘的文件  
    >              2. 构造方法
    >                  ```
    >                  new FileOutputStream(String name) -- 创建一个向指定名称的文件中写入数据的文件输出流，参数：指定名称的硬盘文件路径
    >                  ```
    >                  ```
    >                  new FileOutputStream(File file) -- 创建一个向指定File对象中写入数据的文件输出流，参数：指定的文件
    >                  ```
    >                  构造方法的作用：
    >
    >                  1.创建一个FileOutputStream对象  
    >
    >                  2.根据参数创建一个空文件  
    >
    >                  3.会把FileOutputStream对象指向这个创建的空文件
    >            3. 写入数据  
    >                1. 原理  
    >
    >                   Java程序寻找JVM，JVM寻找OS，OS调用自己的写入数据的方法，最后写入数据
    >                2. 写入数据步骤  
    >                    1. 创建FileOutputStream对象
    >                    2. 调用write(xxx)方法
    >                    3. 释放资源
    >                3. 存储数据原理 
    >
    >                   写入数据时，会把数据转换为二进制的字节存储，当用记事本等读取时，会把二进制的文件通过查ASCII等表转换为各种字符。
    >                4. 数据的追加写和换行写  
    >
    >                   普通的文件输出字节流每次写入数据都会创建新文件覆盖旧文件，无法进行数据的追加写。  
    >
    >                   实现追加写：改用两个参数的构造方法，第二个参数就是追加写开关，如果为true就开启追加写  
    >
    >                   &nbsp;&nbsp;&nbsp;&nbsp;new FileOutputStream(String name, boolean append)
    >
    >                   &nbsp;&nbsp;&nbsp;&nbsp;new FileOutputStream(File file, boolean append)  
    >
    >                   实现换行写：需要换行时，写入换行的字节数组"\r\n".getBytes()                    
    >     2. 字节输入流InputStream  
    >
    >        java.io.InputStream是一个抽象类，表示所有输出字节流的基类  
    >         1. 公共方法  
    >             ```
    >             public byte read() -- 每次读取一个字符，把字符转换为十进制整数
    >             ```
    >             &nbsp;&nbsp;&nbsp;&nbsp;**注意：读取完所有内容后，再次读取返回-1**  
    >         2. 它的子类
    >             1. 文件字节输入流FileinputStream  
    >
    >                java.io.FileinputStream继承了InputStream，又叫文件字节输入流
    >                 1. 作用  
    >
    >                    把硬盘中数据读入内存  
    >                    
    >                 2. 构造方法  
    >                     ```  
    >                     new FileInputStream(String name) -- 创建一个读取指定文件的文件字节输入流，参数：指定名称的硬盘文件路径
    >                     ```
    >                     ```
    >                     new FileInputStream(File file) -- 创建一个读取指定文件的文件字节输入流，参数：指定的文件
    >                     ```
    >        
    >                 3. 读取数据的步骤  
    >
    >                     1.创建FileInputStream对象  
    >                
    >                     2.使用while( (len = fis.read()) != -1) 循环一直读取直到读取完所有内容，其中len在循环前定义，用来记录读取到的字节，fis为文件输入字节流对象。  
    >                 这里不能写成while(fis.read() != -1) {xxx;}，因为每次read()读取完一个字符，指针都会向后移动，如果这样写，则判断时读取到的字符就无法获取了 
    >        
    >                    3.释放资源
    >                
    >                 4. 读取多个字节的方法  
    >                    
    >                    新建一个byte[]数组，用来接收读取的字节，同时它也代表最大的每次读取的字节数   
    >                
    >                    使用read方法的带参方式：  
    >                     ```
    >                     int read(byte[] b) -- 从输入流中读取一定数量的字节，并将其存储在缓冲区数组b中
    >                     ```
    >                    **注意：每次读取都覆盖上一次的数组内容，当读取了最后的内容后，即便数组还有空间也不会继续读取了，下一次再读，就返回-1。**
    >        
    >                    因此参数的分析如下：
    >        
    >                    1、起到了缓冲的作用
    >        
    >                    2、缓冲数组通常定义大小为1024，即1KB，或1024的整数倍**
    >                
    >                    因此返回值分析如下：
    >                   
    >                    1、返回读取到的内容的字节数
    >                   
	>                    可以选择使用String类的带参构造方法：   
    >                     ```
    >                     new String(byte[] bytes) -- 根据字节数组转换为字符串
    >                     ```
    >                     ```
    >                     new String(byte[] bytes, int offset, int len) -- 根据字节数组转换为字符串，参数1：byte数组，参数2：开始转换的索引，参数3：转化的长度  
    >                     ```
    >                    **注意：同样的也可以使用循环来进行全文读取，循环和上文一样使用while((len = fis.read(bytes) != -1)) {xxx;}，注意，由于不知道内容是否完全占用了数组的空间，因此在内部使用转换时，建议使用new String(byte[] bytes, int offset, int len)，之前定义的len就是记录有效字节个数的**  
    >    3. **注意：释放资源时，先释放输出流的资源，即写的资源，然后再释放输入流的资源，即读的资源**
    >
    > 3. 字符流  
    >
    >    字节流虽然可以传输所有类型的数据，但是它也有可能有些问题，如在传输中文时，由于一个中文GBK码中占两个字节，UTF8码中占三个字节，因此读取完无法转变成中文。  
    >
    >    Java提供一个字符流来读取字符。  
    >     > 1. 字符输入流Reader  
    >     >
    >     >    java.io.Reader抽象类表示读取字符流所有类的超类，可以读取字符信息到内存中，它定义了字符输入流的基本共性功能方法
    >     >     1. 共性方法  
    >     >         ```
    >     >         public void close() -- 关闭流并释放资源
    >     >         ```
    >     >         ```
    >     >         public int read() -- 从输入流读取一个字符
    >     >         ```
    >     >         ```
    >     >         public int read(char[] cbuf) -- 从输入流读取一些字符，并存储到数组cbuf中
    >     >         ```
    >     >     2. 它的所有子类的格式：功能Reader  
    >     >         1. InputstreamReader类  
    >     >
    >     >            继承了Reader抽象类  
    >     >             1. FileReader类  
    >     >
    >     >                继承了InputstreamReader类，文件字符输入流，用来读取字符文件的便捷类，把硬件中文件以字符方式读取到内存  
    >     >                 1. 构造方法  
    >     >                     ```
    >     >                     new FileReader(String filename) -- 根据文件路径读取
    >     >                     ```
    >     >                     ```
    >     >                     new FileReader(File file) -- 根据文件读取
    >     >                     ```
    >     >                 2. 使用步骤  
    >     >
    >     >                    与文件输入字节流步骤相同  
    >     > 2. 字符输出流Writer  
    >     >
    >     >    java.io.Writer抽象类表示输出字符流所有类的超类  
    >     >    
    >     >     1. 共性方法  
    >     >         ```
    >     >         public void write(int n) -- 写入单个字符
    >     >         ```
    >     >         ```
    >     >         public void write(char[] cbuf) -- 写入字符数组
    >     >         ```
    >     >         ```
    >     >         public void write(char[] cbuf, int offset, int len) -- 写入字符数组的一部分
    >     >         ```
    >     >         ```
    >     >         public void write(String str) -- 写入字符串
    >     >         ```
    >     >         ```
    >     >         public void write(String str, int offset, int len) -- 写入字符串的一部分
    >     >         ```
    >     >         ```
    >     >         public void flush() -- 刷新该流的缓冲
    >     >         ```
    >     >         ```
    >     >         public void close() -- 刷新缓冲，并且关闭流
    >     >         ```
    >     >     2. 它的子类  
    >     >
    >     >        子类格式：功能Writer  
    >     >         1. OutputstreamWriter类  
    >     >
    >     >            继承了Writer 
    >     >             1. FileWriter  
    >     >
    >     >                继承了OutputstreamWriter，文件字符输出流，把内存中字符数据写入文件  
    >     >                 1. 构造方法  
    >     >                     ```
    >     >                     new FileWriter(File file)
    >     >                     ```
    >     >                     ```
    >     >                     new FileWriter(File file, boolean append)
    >     >                     ```
    >     >                     ```
    >     >                     new FileWriter(String filename)
    >     >                     ```
    >     >                     ```
    >     >                     new FileWriter(String  filename, boolean append)
    >     >                     ```
    >     >                 2. 字符输出流执行的步骤
    >     >
    >     >                     1.创建FileWriter对象
    >     >
    >     >                     2.根据构造方法参数创建文件
    >     >
    >     >                     3.write()方法会把数据先保存到内存的缓冲区中（在这里是把字符先转换为字节，然后保存到缓冲区）
    >     >
    >     >                     4.flush()方法把缓冲区的数据刷新到文件中
    >     >
    >     >                     5.close()方法把缓冲区的数据刷新到文件中然后关闭资源  
    >     >
    >     >                     **注意：可见，字节流是直接把数据写入硬盘，字符流是先转化字符成字节保存到缓冲区，然后通过flush()刷新到硬盘**  
    >     >                 3. flush()和close()区别  
    >     >
    >     >                    flush()刷新了缓冲区，流还可以使用；close()刷新缓冲区，并且会关闭流，流不可以使用
    > 4. IO异常处理  
    >     1. JDK1.7之前  
    >
    >        实际开发中，不允许throws处理，必须使用try{}catch(){}finally{}来处理  
    >     2. JDK7新特性 
    >
    >        try{}catch(){}finally{}有了一个变化，即可以写为try(){}catch(){}finally{}，try后边的()中可以放定义流对象的代码  
    >
    >        好处：与JDK1.7之前相比，由于流对象是在()中定义，所以作用域只有try后边的大括号有效，因此try后边的大括号中代码执行完毕会自动释放流对象，不用写finally
    >     3. JDK9新特性 
    >
    >        try代码块之前定义了流对象，try后边的()中可以引入流对象的变量名，之后还是会自动释放  
    >        
### 2. 属性集
2. 属性集  
    > 1. 概述  
    >
    >    java.until.Properties继承于Hashtable，表示一个持久的属性集。它用键值结构存储数据，每个键及其对应值都是一个字符串。  
    >
    >    该类也被许多的Java类使用，如System.getProperties返回的就是Properties集合。
    > 2. Properties集合  
    >     1. 概述  
    >
    >        继承了Hashtable，**是唯一一个和IO流相关的集合。**  
    >
    >        可以使用Properties集合中的store方法，将集合中临时数据持久性写入硬盘存储，对应的文件为xxx.properties形式，该文件中存储的还是键值对形式的数据  
    >
    >        可以使用Properties集合中的load方法，把硬盘中保存的文件（键值对形式的数据）读取到内存  
    >
    >        **Properties集合默认键值类型都为字符串，因此可以不用写泛型**
    >     2. Properties集合特有的操作字符串的方法  
    >         ```
    >         Object setProperty(String key, String value) -- 调用Hashtable的put方法，添加键值对
    >         ```
    >         ```
    >         String getProperty(String key) -- 通过key找到value，此方法相当于Map中的get方法
    >         ```
    >         ```
    >         set<String> stringPropertyNames() -- 返回属性列表中的键集，相当于Map中的keySet方法
    >         ```
    >     3. Properties集合持久化存储文件方法：store方法  
    >         ```
    >         void store(OutputStream out, String comments) -- 参数1：字节输出流，不能写中文，参数2：注释，不能写中文  
    >         ```
    >         ```
    >         void store(Writer writer, String comments) -- 参数1：字符输出流，可以写中文，参数2：注释，不能写中文
    >         ```
    >
    >         使用步骤：  
    >
    >          1.创建Properties集合并存入数据  
    >
    >          2.创建字符/字节输出流指定存入地址  
    >
    >          3.使用store方法持久化存入数据  
    >
    >          4.释放资源  
    >     4. Properties集合读取键值对文件方法：load方法  
    >         ```
    >         void load(InputStream inStream) -- 字节输入流，不能读中文
    >         ```
    >         ```
    >         void load(Reader reader)  -- 字符输入流，可以读中文
    >         ```
    >     5. **注意：**  
    >
    >         **1.存储键值对的文件，键和值的连接可以用=、空格（其他符号）**  
    >
    >         **2.键值对的文件可以用#注释**  
    >
    >         **3.键值对文件默认键和值都是字符串，不用在文件中加引号了**
## day10
### 1. 缓冲流
1. 缓冲流
    > 1. 介绍  
    >
    >    缓冲流又叫高效流，是对基本的FileXxx的增强，所以也是四个流，按照数据类型分类：  
    >
    >    &nbsp;&nbsp;&nbsp;&nbsp;字节缓冲流：BufferedInputStream BufferedOutputStream  
    >
    >    &nbsp;&nbsp;&nbsp;&nbsp;字符缓冲流：BufferedReader BufferedWriter  
    >
    >    缓冲流的原理：创建流对象时，会创建一个内置的默认大小的缓冲区数组，通过缓冲区读写，减少系统IO次数，从而提高读写效率
    > 2. 字节缓冲流  
    >     1. 字节缓冲输出流BufferedOutputStream    
    >         1. 介绍  
    >
    >            java.io.BufferedOutputStream，继承了OutputStream，可以使用OutputStream的方法  
    >         2. 构造方法  
    >             ```
    >             new BufferedOutputStream(OutputStream out) -- 创建一个新缓冲流
    >             ```
    >             ```
    >             new BufferedOutputStream(OutputStream out, int size) -- 创建一个新缓冲流，并指定缓冲区大小
    >             ```
    >         3. 使用步骤
    >
    >             1.创建字节输出流（一般是文件字节输出流FileOutputStream），构造方法绑定目的地  
    >
    >             2.创建字节缓冲输出流  
    >
    >             3.使用write()方法，把数据写入缓冲区  
    >
    >             4.使用flush()方法，刷新数据到文件  
    >
    >             5.使用close()关闭资源（由于close()方法会先自动刷新缓冲区，然后关闭流，因此第四步可以省略）  
    >     2. 字节缓冲输入流BufferedInputStream  
    >         1. 介绍  
    >
    >            java.io.BufferedInputStream,继承了InputStream，可以使用InputStream的方法  
    >         2. 构造方法  
    >             ```
    >             new BufferedInputSTream(InputStream in) -- 创建一个新缓冲流
    >             ```
    >             ```
    >             new BufferedInputSTream(InputStream in, int size) -- 创建一个新缓冲流，并指定缓冲区大小
    >             ```
    >         3. 使用步骤  
    >
    >             1.创建字节输入流(一般是文件字节输入流FileInputStream)，构造方法绑定读取地址  
    >
    >             2.创建字节缓冲输入流  
    >
    >             3.使用read()方法读取资源  
    >
    >             4.使用close()方法释放资源
    > 3. 字符缓冲流  
    >     1. 字符缓冲输出流BufferedWriter
    >         1. 介绍  
    >
    >            java.io.BufferedWriter继承了Writer，可以使用Writer的方法  
    >         2. 构造方法  
    >             ```
    >             new BufferedWriter(Writer writer) -- 创建缓冲流
    >             ```
    >             ```
    >             new BufferedWriter(Writer writer, int size) -- 创建缓冲流，指定缓冲区大小
    >             ```
    >         3. **特有的方法**  
    >             ``` 
    >             void newLine() -- 写入一个行分隔符，会根据不同的系统获取不同的行分隔符
    >             ```
    >         4. 使用步骤  
    >
    >             1.创建字符输出流（文件字符输出流FileWriter），绑定写入的地址
    >
    >             2.创建字符缓冲输出流
    >
    >             3.使用flush()方法
    >
    >             4.使用close()方法
    >     2. 字符缓冲输入流BufferedReader  
    >         1. 介绍  
    >
    >            java.io.BufferedReader继承了Reader，可以使用Reader的方法  
    >         2. 构造方法  
    >             ```
    >             new BufferedReader(Reader in) -- 创建新缓冲流
    >             ```
    >             ```
    >             new BufferedReader(Reader in, int size) -- 创建新缓冲流，并指定缓冲区大小
    >             ```
    >         3. **特有的方法**  
    >             ```
    >             String readLine() -- 读取一行文本，通过换行('\n')或回车('\r')或回车后跟着换行('\r\n')来确定一行文本结束，返回值：返回不包含终止符号（即换行符）的一行文本，如果已经达到末尾，则返回null
    >             ```
    >         4. 使用步骤
    >            
    >            1.创建字符缓冲流
    >            2.使用read()或readLine()方法读取文本
    >            3.释放资源
    > 
### 2. 转换流       
2. 转换流
    > 1. 字符编码和字符集
    > 
    >    编码：按照规则，将字符存储到计算机中
    > 
    >    解码：将存储在计算机中的二进制数按照某种规则解析出来
    > 
    >    字符集：也叫编码表，常见的有ASCII字符集，GBK字符集，Unicode字符集
    > 
    >    ASCII字符集-》ASCII编码
    >    
    >    GBK字符集-》GBK编码
    >    
    >    Unicode字符集-》UTF8, UTF16, UTF32
    >    
    >    指定了编码，则字符集就指定了
    > 2. 编码引出的问题
    > 
    >    在使用FileReader读取文本文件时，IDEA默认编码时UTF8，读取Windows系统文件时，Windows系统文件默认编码是GBK，会造成乱码的情况。
    > 3. InputStreamReader
    >    1. 介绍
    >    
    >       java.io.InputStreamReader是Reader的子类，是从字节流到字符流的桥梁（解码），可以使用Reader的方法。
    >    2. 构造方法
    >    
    >        ```
    >        new InputStreamReader(InputStream input) -- 创建默认字符集的InputStreamReader，默认编码utf-8
    >        ```
    >        ```
    >        new InputStreamReader(InputStream input, String charsetName) -- 创建指定字符集的InputStreamReader
    >        ```
    >    3. 使用步骤
    >    
    >       1.创建InputStream对象，指定目标地址
    >       
    >       2.创建InputStreamReader对象，指定字节流和编码
    >       
    >       3.使用read()方法按照参数给定的编码对文件解码，读取文件
    >
    >       4.释放资源
    >       
    >       注意事项：参数指定的编码必须和文件相同，否则会乱码
    > 4. OutputStreamWriter
    >    1. 介绍
    >    
    >        java.io.OutputStreamWriter是Writer的子类，是从字符流到字节流桥梁（编码），可以使用Writer的方法
    >    2. 构造方法
    >    
    >        ```java
    >        new OutputStreamWriter(OutputStream out) -- 创建默认字符集的OutputStreamWriter
    >        ```
    >        ```java
    >        new OutputStreamWriter(OutputStream out, String charsetName) -- 创建指定字符集的OutputStreamWriter
    >        ```
    >       默认使用UTF-8编码，指定编码不分大小写，如utf-8/UTF-8都可以
    >    3. 使用步骤
    >    
    >       1.创建OutputStream对象，指定目标地址
    >       
    >       2.创建OutputStreamWriter对象，参数指定字节流和编码
    >       
    >       3.使用write()方法将字符编码为字节存储到缓冲区
    >       
    >       4.使用flush()方法刷新缓冲区字节到文件
    >       
    >       5.使用close()方法释放资源（可以省略第三步）
    > 5. **转换流可以和缓冲流配合使用，能更加高效**
    > 
### 3. 序列化流
3. 序列化流
    > 1. 序列化和反序列化
    >
    >    序列化：把对象写入文件
    >    
    >    反序列化：把文件中保存的对象读出来
    > 2. ObjectOutputStream
    >    1. 介绍
    >    
    >       java.io.ObjectOutputStream是序列化流，将Java对象中的原始数据写入到文件，实现对象的持久存储，继承了OutputStream，可以使用OutputStream的方法
    >    2. 构造方法
    >    
    >        ```
    >        new ObjectOutputStream(OutputStream out)
    >        ```
    >    3. **特有方法**
    >    
    >        ```
    >        void writeObject(Object obj) -- 将指定的对象写入ObjectOutputStream
    >        ```
    >    4. 使用步骤
    >    
    >       1.创建OutputStream对象，指定目标地址
    >       
    >       2.创建ObjectOutputStream对象
    >       
    >       3.使用writeObject()方法
    >       
    >       4.释放资源
    >    5. **注意**
    >    
    >       想要序列化或反序列化时会抛出异常，类要实现序列化或反序列化必须实现java.io.Serializable接口。
    >       
    >       java.io.Serializable接口是个标记接口，实现该接口的类会有一个标记，当序列化或反序列化时会检测，有则正常，没有则抛出异常。
    > 3. ObjectInputStream
    >     1. 介绍
    >     
    >        java.io.ObjectInputStream是反序列化流，将文件中保存的Java对象以流的方式读出来。实现了InputStream，可以使用InputStream的方法
    >        
    >     2. 构造方法
    >     
    >         ```
    >         new ObjectInputStream(InputStream in)
    >         ```
    >         
    >     3. **特有的方法**
    >        
    >         ```
    >         Object readObject() -- 从ObjectInputStream读取对象
    >         ```
    >        
    >        注意：它会抛出文件有关的一个异常ClassNotFoundException，因此前面光解决IO异常不行，用了这个方法还要解决它的这个异常。ClassNotFoundException叫做类找不到异常。
    >        
    >     4. **注意：反序列化的前提：**
    >     
    >        1、文件中存储的对象的类实现了Serializable接口
    >        
    >        2、文件的对象所在的class文件必须存在
    >        
    >     5. 使用步骤
    >        
    >        1.创建InputStream对象，指定文件地址
    >        
    >        2.创建ObjectInputStream对象
    >        
    >        3.使用readObject()方法
    >        
    >        4.接收对象，使用Object类型接收
    >        
    >        5.使用close()方法关闭资源
    >        
    >     6. transient关键字
    >        
    >        static关键字和transient关键字修饰的都不能被序列化
    >        
    >        static关键字：静态关键字。它会优先于非静态加载到内存中（比如静态会优先于对象加载到内存中，所以不创建对象也可以调用静态方法）,因此静态的东西被所有对象共享，不属于对象。序列化的只能是对象，因此static修饰的不可以被序列化
    >        
    >        transient关键字：瞬态关键字。被transient修饰的不能被序列化。
    >        
    >     7. **注意：**
    >     
    >        反序列化一个对象，如果能找到class文件，但是class文件发生了改变时，反序列化会失败，并抛出异常InvalidClassException
    >        
    >        InvalidClassException异常产生原因：
    >         1. 该类的序列版本号和从流中读取的类的不一致
    >        
    >            原因：Java编译器编译.java文件生成.class文件，因此class文件也会被编译生成.class文件，如果class文件中的类实现Serialize接口，则在编译生成的.class文件中会添加一个序列号到类中，因此序列化生成的文件中对象信息中有序列号。反序列化时，会比较文件中的序列号和对应类的序列号，一样则反序列化成功，否则失败并抛出异常。当修改了类时，会重新生成.class文件，同样添加新序列号，这就导致了文件序列号和类序列号不一样，直接进行反序列化就会失败。
    >            
    >            解决方法：我们可以手动为类添加序列号，这样无论类怎么修改都没事了。序列号添加在类中，格式必须为：private final static long serialVersionUID = 序列号;
    >        2. 该类包含未知的数据类型
    >        3. 该类没有可访问的无参构造
    > 4. 序列化多个对象的方法
    >    
    >    当我们想要序列化多个对象并且都保存在一个文件时，可以把对象保存到集合，然后序列化集合即可。
    >    
### 4. 打印流
4. 打印流
    > 1. 介绍
    >    
    >    java.io.PrintStream是打印流，平常用的System.out就是打印流对象，而System.out.print()和System.out.println()都属于打印流中的方法。它为其他输出流添加了功能，使得他们方便地打印各种形式的数值
    >    
    >    java.io.PrintStream继承了OutputStream，可以使用OutputStream的方法
    >    
    > 2. 打印流的特点
    >
    >    1.只负责数据的输出，不负责数据的读取
    >    
    >    2.永远不会抛出IOException异常
    >    
    >    3.特有的方法有print()和println()方法，可以输出任意类型的值
    >    
    > 3. 构造方法
    >    
    >    ```
    >    new PrintStream(File file) -- 输出数据的目的地是文件
    >    ```
    >    ```
    >    new PrintStream(OutputStream out) -- 输出数据的目的地是字节输出流
    >    ```
    >    ```
    >    new PrintStream(String fileName) -- 输出数据的目的地是文件路径
    >    ```
    > 4. **注意**
    >    
    >    1.如果使用继承自父类的write()方法写了数据，则会自动查询编码来转化数据。
    >
    >    2.如果使用print()和println()方法，则写的数据原样输出
    >
    >    3.可以改变打印流的流向。默认我们使用System.out.print()和System.out.println()方法输出的地方是控制台，我们可以使用System中的静态方法setOut(PrintStream out)手动指定目的地为参数传递的打印流的目的地，重新分配System的输出流流向，例如：
    >
    >    ```
    >    PrintStream ps = new PrintStream("D:\\a.txt");
    >           System.setOut(ps);
    >           System.out.print("aaa");
    >           ps.close();
    >    ```
## day11
### 1. 网络编程
1. 网络编程
    > 1. 软件结构
    >    
    >    B/S:Browser/Server，网页/服务器结构
    >
    >    C/S:Client/Server，客户端/服务器结构
    > 2. 网络通信协议
    >     1. 介绍
    >        
    >        计算机网络使得多个计算机连接，位于同一个计算机网络的计算机在连接和通信时必须遵循一定的规则。  
    >        
    >        计算机网络中，这些连接和通信合起来被称为网络通信协议，他对数据的传输格式，传输速率，传输步骤等做了统一的规定，传输的双方必须遵循才能进行数据交换。
    >     2. TCP/IP协议
    >         1. 介绍
    >         
    >            传输控制协议/因特网协议，是Internet最基本，最广泛的协议，定义了计算机如何连入因特网，以及数据如何在它们间进行交换的标准。它的内部包含了一系列用于通信的协议，采用四层分层模型，每一层呼叫下一层的协议完成自己的需求
    >         2. 四层分层模型
    >            
    >            1.应用层 -- 主要负责网络程序的协议，如HTTP协议，FTP协议
    >            
    >            2.传输层 -- 使得网络程序进行通信，进行网络通信时，可以使用TCP协议，也可以使用UDP协议
    >            
    >            3.网络层 -- 整个TCP/IP协议最核心的层，用于将传输的数据分组，将分组数据发送到目标计算机或网络
    >            
    >            4.链路层 -- 最底层的协议，定义物理传输通道的驱动，如光纤的驱动等
    >     3. 协议分类
    >        
    >        网络协议较为复杂，java.net包中提供了一些接口和类用于提供低层次的通信细节。我们可以使用这些类和接口，专注网络程序开发，而不必注重通信细节。
    >        
    >         1. java.net提供了两种常见网络协议支持：
    >             * UDP协议：用户数据报协议。**数据报（Datagram）：网络传输的基本单位**
    >             
    >                UDP是无连接通信协议，即在数据传输时，数据的发送端和接收端不建立逻辑链接，意思是发送端发送数据不会管接收端是否存在，接收端接收了数据也不会有反馈。
    >                
    >                好处：消耗资源小，通信效率高，通常用于音频、视频、普通数据的传输，例如视频会议，使用UDP协议即使丢失一两个数据包，也不会对接受结果产生大影响
    >                
    >                坏处：不能保证数据的完整性，不建议在传输重要数据时使用
    >             * TCP协议：传输控制协议
    >             
    >                TCP是**面向连接**的协议，即传输数据之前，发送端和输出端必须建立逻辑链接。TCP提供两台计算机之间的**无差错**数据传输
    >                
    >                TCP连接中必须确定客户端和服务器端，由客户端向客户端发送连接请求，每次连接创建都要经过三次握手。
    >                
    >                 * 三次握手：TCP协议中，发送数据的准备阶段，客户端和服务器端的三次交互，以保证链接的可靠
    >                   
    >                    第一次握手：客户端向服务器端发送连接请求，等待服务器端确定
    >                    
    >                    第二次握手：服务器端向客户端返回一个响应，通知客户端请求已经收到
    >                    
    >                    第三次握手：客户端再次向服务器端发送确认信息，确认连接
    >                    
    >                
    >                好处：由于这种面向连接的特性，因此TCP协议可以保证数据的安全，应用很广泛，例如：下载文件、浏览网页
    >                
    >                缺点：效率不如UDP
    >     4. 网络编程三要素
    >         1. 协议
    >         2. IP地址
    >         
    >            互联网协议地址。用来给网络中的每一个计算机一个唯一编号
    >             * IP分类
    >            
    >                IPv4：一个32位二进制数，通常被分为4个字节，表示成xxx.xxx.xxx.xxx的形式，每个字节表示0~255的整数，如127.0.0.1，IPv4最多可以表示42亿个
    >                
    >                IPv6：用于解决IPv4的地址资源不足问题，采用128位地址长度，每16个字节一组，分成8组16进制数，表示成xxxx.xxxx.xxxx.xxxx.xxxx.xxxx.xxxx.xxxx
    >         3. 端口号
    >         
    >            由于计算机有很多的软件，数据由在计算机之间传输时，需要知道计算机中哪个软件来接收，因此就需要区别每一个软件，这就引出了端口号这一概念
    >            
    >            逻辑端口，无法直接查看。当我们使用网络软件，操作系统会为网络软件随机分配端口号，或者网络软件在打开时向系统要指定端口号。
    >            
    >            端口号取值范围0~65535。**注意：1024之前的无法使用，并且网络软件端口号不能重复**
    >            
    >            **常用端口号：80（网络端口）、3306（MySql端口号）、1521（Oracle端口号）、8080（Tomcat端口号）**
    >            
### 2. TCP通信程序
2. TCP通信程序
    > 1. 介绍
    >
    >    TCP通信可以实现两台计算机的数据交互，通信必须严格区分客户端（Client）和服务器端（Server）
    >    
    > 2. 两端通信步骤
    >
    >    1、服务器端必须先启动，等待客户端连接
    >    
    >    2、客户端主动连接服务器端，连接成功即可通信。服务器端不可以主动连接客户端
    >    
    >    **注意：客户端和服务器端建立的连接中包含IO对象，客户端和服务器端通过IO流对象进行数据交互。连接不仅要传递字符数据，因此IO对象是字节流对象**
    >    
    > 3. Java中提供了两个类用于提供TCP通信
    >
    >     客户端：java.net.Socket。创建Socket对象，客户端向服务器端发送连接请求，服务器端响应请求，两者建立连接
    >     
    >     服务器端：java.net.ServerSocket。创建ServerSocket对象，相当于开启一个服务，等待客户端连接。
    >     
    > 4. 服务器端和客户端交互必须明确
    >
    >    1、服务器端可能会和多个客户端交互，因此必须明确和哪个客户端进行的交互。java.net.ServerSocket中提供一个方法：
    >    
    >     ```
    >     Socket accept() -- 返回获取到请求的客户端对象
    >     ```
    >    
    >    2、服务器端没有IO对象，因此服务器端只能使用客户端的IO流来和每个客户端进行交互。通过accept()方法服务器端获取到请求的客户端对象，然后就可以用客户端的流对象了
    >    
    > 5. Socket类
    >
    >     1. 介绍
    >     
    >        java.net.Socket实现客户端套接字（也可以就叫套接字）。**套接字：包含了IP地址和端口号的网络单位，两台设备之间通信的端点。**
    >        
    >     2. 构造方法
    >     
    >         ```
    >         new Socket(String host, int port) -- 创建流套接字连接到指定IP地址的主机的指定端口
    >         ```
    >     3. 成员方法
    >     
    >         ```
    >         OutputStream getOutputStream() -- 获取一个此套接字的字节输出流
    >         ```
    >         
    >         ```
    >         InputStream getInputStream() -- 获取一个此套接字的字节输入流
    >         ```
    >         
    >         ```
    >         void close() -- 关闭此套接字，释放资源
    >         ```
    >     
    >     4. 实现步骤
    >     
    >        1、创建一个客户端套接字Socket对象
    >        
    >        2、使用getOutputStream()获取一个网络字节输出流对象
    >        
    >        3、使用网络字节输出流对象的write()方法发送数据给服务器
    >        
    >        4、使用getInputStream()获取一个网络字节输入流对象
    >        
    >        5、使用网络字节输入流的read()方法获取服务器回写的数据
    >        
    >        6、使用close()方法关闭套接字，释放资源
    >        
    >        **注意：**
    >        
    >        **1、服务器端和客户端之间的数据交互只能使用getOutputStream()和getInputStream()获取的网络字节输出流和网络字节输入流进行交互**
    >        
    >        **2、当我们创建客户端对象Socket时，客户端就会和服务器端进行三次握手了；握手成功，则可以进行数据交互；握手失败，那么就会抛出异常**
    > 6. ServerSoket类
    >     1. 介绍
    >     
    >        java.net.ServerSocket实现服务器套接字。
    >     
    >     2. 构造方法
    >     
    >         ```
    >         new ServerSocket(int port) -- 创建绑定到指定端口的服务器套接字，并向系统索要端口号
    >         ```
    >        
    >     3. 成员方法
    >     
    >         ```
    >         Socket accept() -- 侦听并接收此套接字的连接
    >         ```
    >         
    >     4. 实现步骤
    >        
    >        1、创建ServerSocket对象
    >        
    >        2、使用accept()方法获取到请求的客户端对象
    >        
    >        3、使用客户端对象中的getInputStream()方法获取网络字节输入流
    >        
    >        4、使用网络字节输入流中的方法read()获取客户端传入的数据
    >        
    >        5、使用客户端对象中的getOutputStream()方法获取网络字节输出流
    >        
    >        6、使用网络字节输出流中的write()方法回写数据
    >        
    >        7、使用客户端对象的close()方法关闭客户端套接字，释放资源
    >        
    >        8、使用close()关闭服务器端套接字，释放资源
    >
    > 7. 阻塞问题
    > 
    >    read()方法有一个问题，read()方法从输入流读取字节，如果输入不存在，则进入阻塞状态。
    >    
    >    例如：
    >    
    >    客户端从本地读取一个文件传输给服务器端，则客户端使用本地字节输入流读取文件，使用read()方法读取，但是read()不会读取文件最后的结束标记-1，因此客户端通过网络字节输出流传递的文件数据是没有结束标记的；服务器端读取这个文件数据，使用read()方法读取并读取全部文件后，因为读取不到结束标记，但是后续输入不存在，因此进入阻塞状态，一直死循环等待结束标记，服务器端之后的代码就不会执行，同样的，如果客户端还要接收服务器端的回写数据，则也处在一直等待。
    >    
    >    解决方法：
    >    
    >    在使用网络字节输出流传输数据完毕后，使用Socket的一个方法：
    >    
    >     ```
    >     void shutdownOutput() -- 禁用套接字的输出流。如果是TCP套接字，则任何以前的数据都将被发送，并且数据后边会跟上TCP正常连接种植序列。
    >     ```
    >    
    >     手动在传输数据完毕后添加这个方法即可解决阻塞问题。
## day12
### 1. 函数式接口
1. 函数式接口
    > 1. 介绍
    >
    >    Java中函数式接口指的是有且只有一个抽象方法的接口。由于函数式编程在Java中的体现就是Lambda，因此函数式接口就是可以适用于Lambda的接口。
    >    
    >    ```@FunctionalInterface```注解如果在确认接口中只有一个抽象方法的情况下，可以不用加。但是加上更加标准
    >    
    > 2. 定义格式
    >    
    >    ```java
    >    @FunctionalInterface//和@Override作用类似，用于检测此接口是否为函数式接口
    >    public interface 接口名 {
    >       public abstract 返回值 方法名();
    >    }
    >    ```
    >    
    > 3. 使用
    >    
    >    一般作为方法的参数或返回值使用
    >    
    > 4. Lambada表达式和匿名内部类的关系
    >    
    >    应用层面，它们可以看作是语法糖的关系，但是二者的原理其实是不同的。
    >    
    >    不同之处：匿名内部类在编译时，会出现.class的编译文件运行时会需要加载这个文件到内存，而Lambda表达式不会，因此Lambda表达式效率要高于匿名内部类
### 2. 函数式编程
2. 函数式编程
    > 1. Lambda表达式延迟执行
    > 
    >    一些场景下代码执行后的结果并不会被使用，性能会造成浪费，Lambda表达式是延迟执行的，因此可以很好的解决性能浪费问题，提高性能。
    >    
    >    延迟执行的案例：见视频
    >    
    > 2. Lambda表达式抛开原理，可以作为某些匿名内部类的替代。
    > 
    >    如果方法的参数或返回值为函数式接口的类型，就可以使用Lambda表达式代替，如java.lang.Runnable接口就是函数式接口，我们假如定义startThread()方法的参数是该接口，我们传参时就可以舍弃原来的匿名内部类传参，改为Lambda表达式传参。
    > 
### 3. 常用的函数式接口
3. 常用的函数式接口

   JDK提供了大量函数式接口及Lambda表达式使用场景，他们主要在java.until.function包中被提供。以下为一些最简单的接口及使用案例。
   
    > 1. Supplier接口
    >    1. 介绍
    >    
    >       java.until.function.Supplier<T>又叫生产型接口，只要指定了泛型的类型，则方法get()就会生产什么类型的数据
    >       
    >    2. 方法
    >    
    >       ```
    >       T get() -- 获取泛型指定类型的数据
    >       ```
    >    
    > 2. Consumer接口
    >    1. 介绍
    >    
    >       java.until.function.Consumer<T>接口又叫消费型接口，和Supplier<T>接口正好相反，它的作用是消费一个数据，数据类型由泛型决定。
    >       
    >    2. 方法
    >    
    >        ```
    >        void accept(T t) -- 消费一个泛型指定数据类型的数据
    >        ```
    >       
    >    3. 默认方法
    >    
    >        ```
    >        Consumer andThen(Consumer con) -- 把两个Consumer接口组合在一起，然后就可以调用一次accept()方法达到多个Consumer接口对同一数据进行消费，谁写前边谁先消费，返回组合的Consumer接口，因此可以使用链式写法
    >        ```
    >    
    > 3. Predicate接口
    >     1. 介绍
    >     
    >        有时候我们要对某种类型的数据进行判断，从而得到一个boolean类型的结果，这时可以使用java.until.function.Predicate<T>接口。
    >        
    >     2. 方法
    >     
    >         ```
    >         boolean test(T t) -- 对数据进行判断，判断标准是Lambda表达式中的逻辑            
    >         ```
    >         
    >     3. 默认方法
    >        
    >        1、方法内部两个判断条件可以使用&&连接表示且，如：a.test(xxx) && b.test(xxx)，Predicate接口提供一个默认方法也有&&的效果
    >        
    >         ```
    >         Predicate and(Predicate pre) -- 表示且，等价于&&，如：a.and(b).test(xxx)
    >         ```
    >        
    >        2、方法内部两个判断条件可以使用||连接表示或，如：a.test(xxx) || b.test(xxx)，Predicate接口提供一个默认方法也有||的效果
    >        
    >         ```
    >         Predicate or(Predicate pre) -- 表示或，等价于||，如：a.or(b).test(xxx)
    >         ```
    >        
    >        3、方法内部判断可以使用!连接表示非，如：!a.test(xxx)，Predicate接口提供默认方法也有!的效果
    >        
    >         ```
    >         Predicate negate() -- 表示非，等价于!，如：a.negate().test(xxx)
    >         ```
    >     
    > 4. Function接口
    >     1. 介绍
    >     
    >        java.until.function.Function<T, R>是一个转换的接口，它的功能是把第一个泛型所代表的类型的数据最终转换成第二个泛型所代表的类型的数据
    >        
    >     2. 方法
    >     
    >         ```
    >         R apply(T t) -- 根据T类型参数，获取R类型结果
    >         ```
    >         
    >     3. 默认方法
    >     
    >         ```
    >         Function andThen(Function fun) -- 进行组合，可以把多个Function组合
    >         ```

## day13
### 1. Stream流
1. Stream流
    > 1. 介绍
    > 
    >    Stream流是Lambda表达式的衍生物，即关注做什么，不关注怎么做，在JDK1.8后出现。Stream流和I/O流完全不同，它可以解决集合类库的一系列弊端
    >    
    > 2. 流式思想
    > 
    >    见视频
    >    
    > 3. 获取流
    > 
    >    java.until.stream.Stream<T>是JDK1.8后出现的、最常见的流接口（**不是函数式接口**）
    >    
    >    获取流有两种方法：
    >    
    >    1、所有的Collection集合都有一个方法stream()，该方法会返回Stream流对象
    >    
    >    2、Stream流由静态方法用以获取对应数组的流：
    >    
    >     ```
    >     static <T> Stream<T> of(T... value) -- 参数是可变参数，由于可变参数底层是数组实现所以我们可以直接传递数组
    >     ```
    >    注意：数组数据类型必须和Stream的泛型类型一样，不能使用基本数据类型数组必须使用包装类的数组
    >    
    > 4. 常用方法
    > 
    >    Stream流中方法分为两种，延迟方法和终结方法：
    >    
    >    延迟方法：方法返回值为Stream接口，因此可以使用链式写法，除终结方法之外都是延迟方法
    >    
    >    终结方法：方法返回值不为Stream接口，代表结束，之后不能调用Stream流中其他方法了，常用的终结方法有count()和foreach()
    >    
    >     1. 终结方法
    >    
    >         ```
    >         void foreach(Consumer con) -- 接收Consumer接口函数（使用Lambda表达式），每一个流元素都作为实参传递给函数处理，
    >         ```
    >      
    >         ```
    >         long count() -- 统计流中元素个数
    >         ```
    >      
    >     2. 延迟方法
    >      
    >         ```
    >         filter(Predicate pre) -- 将一个流转换成另一个字节流，相当于筛选，使用Lambda表达式，返回为true则筛选出去进入另一个流。
    >         ```
    >         
    >        **注意：Stream流是管道流，只能被消费一次，消费完毕,筛选好的数据进入下一个Stream流，这时上一个Stream流会关闭，不能再调用任何方法**
    >        
    >         ```
    >        map(Function fun) -- 如果需要将流中的元素映射（转换）到另一个流中，可以使用map方法
    >         ```
    >        
    >         ```
    >        limit(long n) -- 对流进行截取，只取前n个到下一个流中，集合长度大于参数才可以进行操作，否则不操作。它也是一个延迟方法，返回一个新Stream流，所以可以继续调用Stream流中方法
    >         ```
    >        
    >         ```
    >        skip(long n) -- 跳过前n个元素，只取之后的元素到下一个流中，集合长度大于参数才可以正常操作，否则会得到长度为0的空流
    >         ```
    >        
    >     3. 静态方法
    >    
    >         ```
    >         static <T> Stream<T> concat(Stream<? extends T> a, Stream<? extends T> b) -- 静态方法，用于将两个流合并成一个流
    >         ```

### 2. 方法引用
2. 方法引用
    > 1. 介绍
    >    
    >    实际就是对Lambda表达式的优化，方法引用可以直接代替Lambda表达式。Lambda表达式传递的就是解决方案，因此如果该方案已经存在，则不需要写Lambda表达式了，直接使用该方案即可。以达到简化代码的目的。因此，方法引用是和Lambda表达式等价的，它在某些情况比Lambda表达式更好用。
    >    
    > 2. 使用方法引用的几种办法
    >     1. 通过对象名引用方法
    >     
    >        如果对象已经存在，并且方法也存在，就可以使用对象名::方法名的方式进行方法引用
    >        
    >     2. 通过类名引用静态方法
    >     
    >        如果类存在，静态成员方法也存在，则可以直接使用类名::静态方法名的方式进行方法引用
    >        
    >     3. 通过super引用父类的方法
    >     
    >        如果继承了某个父类，父类中方法存在，则可以直接用super::方法名进行方法引用
    >        
    >     4. 通过this引用本类的方法
    >     
    >        如果本类中有某个方法，则可以直接用this::方法名进行方法引用
    >        
    >     5. 类的构造方法的引用
    >     
    >        如果类中构造方法已知，则可以使用类名称::new进行构造方法的引用，即对象的创建
    >        
    >     6. 数组的构造方法的引用
    >     
    >        如果数组的长度已知，则可以使用数组类型::new进行数组的构造器引用，即数组的创建
    >        
# JavaWeb
## day01

### 1. Junit测试
1. Junit测试
    > 1. 测试分类
    >     1. 黑盒测试
    >     
    >     
    >       不需要代码，只需要输入一些值，看是否能够输出想要的值
    >     
    >    2. 白盒测试
    >       
    >    
    >       需要测试代码，Junit单元测试是就白盒测试的一种
    >    
    > 2. Junit使用步骤
    >     1. 定义一个测试类T
    >     
    >        定义测试类名：xxxtest
    >        
    >        定义测试类所在的包：xxx.xxx.xxx.test
    >        
    >     2. 定义测试方法：它是可以独立运行的，并且如果想进行多个测试，可以定义多个测试方法，都完成第二到第四步即可
    >     
    >        public void testxxx() {}
    >        
    >     3. 给测试方法加注解
    >     
    >        @Test
    >        
    >     4. 导入测试环境，通过Alt+Enter直接添加
    >     
    > 3. 断言
    > 
    >    在测试方法中，我们对测试的结果不会直接打印输出，我们使用断言，即断定结果为多少，然后与测试结果相比，如果一样，则结果正确，否则错误。
    >    
    >     * 如何进行断言操作？
    >    
    >         Assert类中的许多静态方法都可以进行断言操作，如Assert.assertEquals()
    >    
    > 4. 初始化方法和释放资源方法
    > 
    >    测试类中，我们需要一个初始化方法，用来做资源申请，所有测试类在执行前，都要先执行初始化方法。
    >    
    >    初始化方法定义格式：
    >    
    >     ```
    >     @Before//@Before修饰的方法会在所有测试方法之前执行，因此常用来修饰初始化方法
    >     ```
    >    
    >     ```
    >     public void init() {xxx;}
    >     ```
    >    
    >    测试类中，我们需要一个释放资源的方法，该方法会在所有测试类执行完毕后，自动执行
    >    释放资源方法定义格式：
    >    
    >     ```
    >     @After//@After修饰的方法会在所有测试方法执行之后自动执行，常用来修饰释放资源的方法
    >     ```
    >    
    >     ```
    >     public void close() {xxx;} 
    >     ```

### 2. 反射
2. 反射
    > 1. 介绍
    >
    >    框架设计的灵魂。将类的各个组成部分封装为其他的对象，这就是反射机制。
    >    
    > 2. Java代码在计算机中的三阶段
    >
    >    见视频
    >    
    > 3. 反射机制的好处
    >
    >    1、可以在程序运行期间操作这些对象
    >    
    >    2、可以解耦，提高程序的可扩展性
    >    
    > 4. Class对象
    >     1. 获取Class对象的方式
    >         1. 在Source源代码期间：这个期间类没有导包，还没有加载进入内存，```.java```文件编译成的```.class```字节码文件还存于硬盘，因此需要手动加载进入内存，需要一个静态方法：
    >         
    >             ```
    >             Class Class.forName("全类名") -- 将.class字节码文件加载进内存，返回Class对象
    >             ```
    >         
    >            该方式多用于配置文件。将类名保存在配置文件，读取文件，加载类
    >         
    >         2. Class对象阶段：类已经导包完成，已经加载进入内存，但是还没有真正的new类来创造对象，我们需要：
    >         
    >             ```
    >             类名.class -- 通过类的class属性来获取
    >             ```
    >         
    >            该方式多用于传参，需要传递Class对象的参数时用这种方式获取Class对象
    >         
    >         3. Runtime阶段：此阶段，类已经被new创建了对象，因此可以使用方法：
    >         
    >             ```
    >             对象.getClass() -- 返回Class对象
    >             ```
    >         
    >            该方式多用于对象获取字节码
    >         
    >         * **注意：同一个类的字节码文件，在程序运行中，只会被加载进入内存一次，即它的Class对象永远只有一个；类和Class对象是一一对应的关系**
    >       
    >      5. Class对象的方法
    >          1. 和获取相关的方法
    >              1. 获取成员变量们
    >              
    >                  ```
    >                  Field[] getFields() -- 获取所有的public修饰的成员变量
    >                  ```
    >                  
    >                  ```
    >                   Field getField(String name) -- 获取指定名称的public修饰的成员变量
    >                  ```
    >                  
    >                  ```
    >                  Field[] getDeclaredFields() -- 获取所有的成员变量，不考虑修饰符
    >                  ```
    >                  
    >                  ```
    >                  Field getDeclaredField(String name) -- 获取指定的成员变量，不考虑修饰符
    >                  ```
    >                  
    >                  * **注意：非public的成员变量在获取之后不能直接操作，需要忽略访问权限修饰符的安全检查：**
    >                  
    >                      ```
    >                      成员变量的对象.setAccessible(true) -- 暴力反射
    >                      ```
    >              2. 获取构造方法们
    >              
    >                  ```
    >                  Constructor<?>[] getConstructors() -- 获取所有的public修饰的构造方法
    >                  ```
    >                  
    >                  ```
    >                  Constructor<T> getConstructor(类<?>... parameterTypes) -- 获取指定的public修饰的构造方法，参数：构造方法需要的若干个参数的class对象，如：String.class,int.class,long.class等
    >                  ```
    >                  
    >                  ```
    >                  Constructor<?>[] getDeclaredConstructors() -- 获取所有的构造方法，不考虑修饰符
    >                  ```
    >                  
    >                  ```
    >                  Constructor<T> getDeclaredConstructor(类<?>... parameterTypes) -- 获取指定的构造方法，不考虑修饰符
    >                  ```
    >                  
    >              3. 获取成员方法们
    >              
    >                  ```
    >                  Method[] getMethods() -- 获取所有的public修饰的成员方法
    >                  ```
    >                  
    >                  ```
    >                  Method getMethod(String name, 类<?>... parameterTypes) -- 获取指定的public修饰的成员方法，参数1：方法名，参数2：方法的若干参数的class对象，如：String.class.int.class
    >                  ```
    >                  
    >                  ```
    >                  Method[] getDeclaredMethods() -- 获取所有的成员方法，不考虑修饰符
    >                  ```
    >                  
    >                  ```
    >                  Method getDeclaredMethod(String name, 类<?>... parameterTypes) -- 获取指定的成员方法，不考虑修饰符
    >                  ```
    >                  
    >              4. 获取类名
    >              
    >                  ```
    >                  String getName() -- 获取全类名
    >                  ```
    >                  
    >                  ```
    >                  String getSimpleName() -- 获取简短类名
    >                  ```
    >     
    > 5. Field对象
    >     1. 介绍
    >        
    >        Field对象是类中成员变量封装成的对象
    >        
    >     2. 方法
    >        
    >         ```
    >         void set(Object obj, Object value) -- 给成员变量设置它的值，参数1：类的对象，参数2：想要赋给成员变量的值
    >         ```
    >         
    >         ```
    >         Object get(Object obj) -- 获取成员变量的值，参数：类的对象
    >         ```
    >     
    > 6. Constructor对象
    >     1. 介绍
    >        
    >        Constructor对象是类中构造方法封装成的对象
    >        
    >     2. 方法
    >
    >         ```
    >         T newInstance(Object... initargs) -- 创建对象，参数：构造方法需要的实参
    >         ```
    >         
    >        **注意：如果要获取空参构造方法，然后根据空参构造方法的对象来创建类的对象太麻烦，因此Java提供了更简便的方法，直接通过class对象的中的方法**
    >        
    >         ```
    >         T newInstance() -- 根据空参创建对象
    >         ```
    >        
    >        **简化操作，因此以后想用空参构造创建对象就用这种方式即可**
    >
    > 7. Method对象
    >     1. 介绍
    >        
    >        Method对象是类中成员方法封装成的对象
    >        
    >     2. 方法
    >
    >         ```
    >         invoke(Object obj, Object... initargs) -- 执行当前方法，参数1：真正要执行该方法的对象；参数2：方法所需要的实参的字节码文件
    >         ```
    >         
    >         ```
    >         getName() -- 获取方法名
    >         ```
    >
    > 8. 暴力反射
    >
    >     ```
    >     对象.setAccessible(true) -- 对非public修饰的东西，忽略访问权限修饰符的安全检查
    >     ```
    >
    > 9. 类加载器
    >     1. 介绍
    >        
    >        每个类的字节码文件都有一个类加载器，用来加载其他的类进入内存
    >        
    >     2. 使用步骤
    >        
    >        1、获取当前类的类加载器
    >        
    >         ```
    >         ClassLoader 类加载器名 = 当前类.class.getClassLoader()
    >         ```
    >        
    >        2、通过类加载器，获取所需资源的字节流
    >        
    >         ```
    >         InputStream 字节流对象名 = 类加载器名.getResourceAsStream(String 资源路径，从src开始算);
    >         ```
    >        
    >        3、通过字节流对象读取数据
### 3. 注解
3. 注解
    > 1. 介绍
    >
    >    是从JDK5.0 引入的一种注释机制，用来说明程序
    >    
    > 2. 格式
    >
    >    @注释名称
    >    
    > 3. 功能
    >
    >    1、编写文档：通过代码中标识的元数据生成文档【生成doc文档，如API文档】
    >    
    >    2、代码分析：通过代码中标识的元数据分析代码【使用反射】
    >    
    >    3、编译检查：通过代码中标识的元数据让编译器能够实现基本的编译检查，如@Overide
    >    
    > 4. JDK预置的注解
    >
    >    1、@Override：检测被该注解标注的方法是否是继承自父类的
    >    
    >    2、@Deprecated：被该注解标注的内容，标注为已过时内容
    >    
    >    3、@SuppressWarnings("all")：用来压制所有的警告
    >    
    > 5. 自定义注解
    >     1. 格式
    >       
    >         ```
    >         元注解
    >         public @interface 注解名{}
    >         ```
    >        
    >     2. 注解的本质
    >       
    >        一个默认继承了java.lang.annotation.Annotation接口的一个新接口
    >       
    >     3. 注解中的属性
    >     
    >        接口中可以定义的抽象方法，例如：
    >        
    >         ```
    >         元注解
    >         public @interface 注解名 {
    >             public abstract void 属性名();
    >         }
    >         ```
    >        
    >        注解中属性的要求：
    >        
    >        1、属性的返回值类型必须为：基本数据类型、String类型、枚举类型、注解类型、以上类型的数组
    >        
    >        2、定义了属性，在使用时必须要赋值，属性值的类型和返回值类型一样，例如：@注解名(属性名 = 值)；如果在属性创建时，使用了default关键字，则可以在使用时不用赋值，例如：
    >        
    >         ```
    >         元注解
    >           public @interface 注解名 {
    >               public abstract String xxx() default "xxx";
    >           }
    >         ```
    >        
    >         * **注意：如果只有一个属性需要赋值，且属性的名为value，则赋值时不需要写属性名，如@SuppressWarnings("all")**
    >        
    >     4. 注解中的元注解
    >         1. 介绍
    >         
    >            注解的注解，用于描述这个注解作用位置、保留阶段等的注释
    >            
    >         2. 元注解分类
    >         
    >            1、@Target(value={ElementType.xxx,...}):注解作用的位置，可以写若干个
    >            
    >             * ElementType后边的取值：
    >            
    >                1、TYPE：作用于类
    >                
    >                2、METHOD：作用于方法
    >                
    >                3、FIELD：作用于成员变量
    >                
    >            
    >            2、@Retention(value=RetentionPolicy.xxx):注解可以保留到的Java阶段，可以省略value，直接写RetentionPolicy.xxx
    >            
    >             * RetentionPolicy后边的取值：
    >            
    >                1、SOURCE:源码阶段，不会被保留到class字节码文件也不会被JVM读取
    >                
    >                2、CLASS:Class对象阶段，会被保留到class字节码文件，不会被JVM读取到
    >                
    >                3、RUNTIME:运行时阶段，会被保留到class字节码文件且会被JVM读取到，自定义的注解一般都写这个阶段
    >                
    >            
    >            3、@Documented:注解是否被抽取到API文档，加了此元注解，该注解会被抽取到API文档
    >            
    >            4、@Inherited:注解是否被子类继承，加了此元注解，该注解会被继承
    >         
    >     5. 判断方法上是否有注解
    >     
    >        获取方法的Method对象，在Method对象中有个方法可以判断：
    >        
    >         ```
    >         boolean isAnnotationPresent(注解的Class对象) -- 判断方法上是否有注解
    >         ```
    >        
    >     6. 在程序中解析（使用）注解：获取注解中定义的属性值
    >         1. 应用场景举例：
    >         
    >            可以用来替代配置文件
    >            
    >         2. 解析步骤
    >         
    >            以替代配置文件为例：
    >            
    >            1、获取类的字节码文件对象：Class<类名> 类对象名 = 类名.class;
    >            
    >            2、获取注解对象：通过类的字节码对象中的方法获取
    >            
    >             ```
    >             注解名 注解对象名 = 类对象名.getAnnotation(指定注解的字节码对象即注解名.class) -- 通过指定注解的字节码对象获取注解对象，返回值类型为某个注解的对象
    >             ```
    >            
    >            **其实就是在内存中自动生成了一个注解的实现类对象**
    >            
    >            3、调用注解对象中定义的抽象方法获取属性值：
    >            
    >             ```
    >             返回值类型 属性值 = 注解对象名.方法名()
    >             ```
    >            
    >            这样注解就相当于配置文件了
    >            
    >            综上，解析的通用步骤为：
    >            
    >             1. 获取注释作用的位置的对象，如作用在类就获取类的字节码对象、作用在方法就获取Method对象，作用在成员变量就获取Field对象
    >            
    >             2. 获取注解对象
    >            
    >             3. 调用注解中抽象方法获取属性值 
    >         
    >     7. 大多数情况下我们不自定义注解，只是使用它们；注解给编译器和解析程序使用；注解不是程序的一部分，可以理解为只是一种标签 

## day02
### 1. 数据库
1. 数据库
    > 1. SQL语句分类
    > 
    >    1、DDL：数据定义语言，操作数据库和表
    >    
    >    2、DML：数据操作语言，增删改数据
    >    
    >    3、DQL：数据查询语言，查询数据
    >    
    >    4、DCL：数据控制语言，进行授权
    >    
    > 2. DDL
    >     1. 操作数据库（CRUD操作）
    >     
    >        C:Create，创建
    >        
    >         ```
    >         CREATE [IF NOT EXISTS] DATABASE XXX [CHARACTER SET XXX];
    >         ```
    >        
    >        R:Retrieve，查询
    >        
    >         ```
    >         SHOW DATABASES;
              SHOW CREATE DATABASE XXX;
    >         ```
    >        
    >        U:Update，修改
    >        
    >         ```
    >         ALTER DATABASE XXX CHARACTER SET XXX;
    >         ```
    >        
    >        D:Delete，删除
    >        
    >         ```
    >         DROP DATABASE [IF EXISTS] XXX;
    >         ```
    >        
    >        使用数据库
    >        
    >         ```
    >         SELECT DATABASE();
              USE XXX;
    >         ```
    >        
    >     2. 操作表
    >     
    >        C:Create，创建
    >        
    >         ```
    >         CREATE TABLE XXX();
    >         ```
    >        
    >        R:Retrieve，查询
    >        
    >         ```
    >         SHOW TABLES;
              DESC XXX;
    >         ```
    >        
    >        U:Update，修改
    >        
    >         ```
    >         ALTER TABLE XXX RENAME TO XXX;
              ALTER TABLE XXX CHARACTER SET XXX;
              ALTER TABLE XXX ADD 列名 数据类型 ...;
              ALTER TABLE XXX CHANGE 旧列名 新列名 新数据类型 ...;
              ALTER TABLE XXX MODIFY 旧列名 新数据类型;
              ALTER TABLE XXX DROP 某一列的列名;
    >         ```
    >        
    >        D:Delete，删除
    >        
    >         ```
    >         DROP TABLE [IF EXISTS] XXX;
    >         ```
    >        
    >        **以xxx为模板复制一份表XXX：CREATE TABLE XXX LIKE xxx;**
    >        
    >        **查看表结构的语句：DESC 表名;**
    >     
    > 3. DML
    > 
    >     ```
    >     添加数据：INSERT INTO XXX[()] VALUES ();
    >     ```
    >     
    >     ```
    >     删除数据：DELETE FROM XXX [WHERE 条件];
    >     ```
    >     
    >     ```
    >     删除(截断)表：TRUNCATE TABLE XXX; -- 删除表，然后创建一个一模一样的空表
    >     ```
    >     
    >     ```
    >     修改（更新）数据：UPDATE XXX SET XXX=XXX, ... WHERE 条件;
    >     ```
    >     
    > 4. DQL
    > 
    >    WHERE
    >    
    >    GROUP BY
    >    
    >    HAVING
    >    
    >    ORDER BY
    >    
    >    LIMIT
    >    
    >    **去除重复结果集：SELECT DISTINCT XXX FROM XXX;**
    >    
    >    **如果有null参与运算，则显示为null，可以使用IFNULL(null值出现的字段, 如果为null返回的值)来解决**
    >    
    >     * 运算符：
    >    
    >        \>、\<、=、\>=、\<=、\<\> 或者 !=
    >        
    >        BETWEEN ... AND ... 相当于 xxx \<= a  && a \<= xxx
    >        
    >        IN(集合)
    >        
    >        LIKE -- 模糊查询**占位符：%、_**
    >        
    >        IS NULL
    >        
    >        IS NOT NULL
    >        
    >        AND 或者 &&
    >        
    >        OR 或者 ||
    >    
    > 5. 数据类型
    > 
    >    INT
    >    
    >    FLOAT(M, D)
    >    
    >    DOUBLE(M, D)
    >    
    >    DECIMAL(M, D)
    >    
    >    CHAR(M)
    >    
    >    VARCHAR(M)
    >    
    >    DATETIME
    >    
    >    TIMESTAMP -- TIMESTAMP类型与DATETIME区别：格式都是yyyy-MM-dd HH:mm:ss，但是TIMESTAMP类型不赋值，则默认使用系统时间自动赋值
    >    
    >    TINYTEXT
    >    
    >    TEXT
    >    
    >    MEDIUMTEXT
    >    
    >    LONGTEXT
    >    
## day03
### 1. 约束
1. 约束
    > 1. 非空约束：NOT NULL
    > 
    >    1、创建表时，字段后添加
    >    
    >    2、创建完毕之后添加，使用:ALTER TABLE XXX MODIFY XXX NOT NULL;
    >    
    >    **可以使用DEFAULT XXX进行默认值赋值**
    >    
    > 2. 主键约束：PRIMARY KEY
    > 
    >    主键约束每张表只能有一个这个约束
    >    
    >    1、创建表时，字段后添加
    >    
    >    2、创建完毕之后添加，使用:ALTER TABLE XXX MODIFY XXX KEY;
    >    
    >    **删除主键约束：ALTER TABLE XXX DROP PRIMARY KEY;**
    >    
    >     * 自增：AUTO_INCREMENT
    >    
    >        删除自增：ALTER TABLE XXX MODIFY 字段名 不加自增的类型等;
    >    
    > 3. 唯一约束：UNIQUE KEY
    > 
    >    唯一约束可以有null值，但是只能有一个null
    >    
    >    1、创建表时，字段后添加
    >    
    >    2、创建完毕之后添加，使用:ALTER TABLE XXX MODIFY XXX UNIQUE;
    >    
    >    **删除某个字段的唯一约束：ALTER TABLE XXX DROP INDEX 加了唯一约束的字段名;**
    >    
    > 4. 外键约束：FOREIGN KEY
    > 
    >    添加约束语句：[CONSTRAINT 外键表名] FOREIGN KEY 外键列名称 REFERENCES 主表名(主表列名);
    >    
    >    **删除外键：ALTER TABLE XXX DROP FOREIGN KEY 外键列名;**
    >    
    > 5. 级联操作
    > 
    >    级联操作主要用于外键关联的多张表
    >    
    >    设置级联更新：在创建外键时设置，CONSTRAINT 外键表名 FOREIGN KEY 外键列名称 REFERENCES 主表名(主表列名) ON UPDATE CASCADE;
    >    
    >    设置级联删除：创建外键时设置，CONSTRAINT 外键表名 FOREIGN KEY 外键列名称 REFERENCES 主表名(主表列名) ON DELETE CASCADE;
    >    
### 2. 数据库设计
2. 数据库设计
    > 1. 多表关系
    >     1. 一对一
    >     2. 一对多
    >       
    >        多的一方添加外键
    >       
    >     3. 多对多
    >       
    >        引入中间表。
    >       
    >        因为中间表关联时多个主键是联合主键即都非空且唯一，因此要使用联合主键形式，多个联合主键字段作为外键关联多个表。
    >       
    >        联合主键：PRIMARY KEY(字段1, 字段2, ...);
    >     
    > 2. 数据库范式
    >      1. 第一范式（1NF）
    >      
    >         每一列都是不可分割的原子数据项
    >         
    >      2. 第二范式（2NF）
    >      
    >         在第一范式的基础上，要求非码属性必须完全函数依赖于码
    >         
    >          * 概念：
    >         
    >             1、函数依赖：通过A属性或属性组的值，可以确定唯一的B的属性值，则B依赖于A
    >             
    >             2、完全函数依赖：如果A是属性组，则B属性值的确定需要依赖A属性组中所有属性的属性值
    >             
    >             3、部分函数依赖：如果A是属性组，则B属性值的确定依赖于A属性组中某些值
    >             
    >             4、传递函数依赖：如果通过A属性或属性组，可以确定B，通过B确定唯一的C属性值，则C传递函数依赖于A
    >             
    >             5、码：如果属性或属性组被其他所有属性完全依赖，则该属性或属性组称为表的码
    >         
    >      3. 第三范式（3NF）
    >      
    >         在第二范式的基础上，要求任何的非主属性不依赖于其他的非主属性
    >         
### 3. 数据库备份和恢复
3. 数据库备份和恢复
    > 1. 命令行中
    >     1. 备份
    >     
    >        mysqldump -u用户名 -p密码 数据库名称 \> 保存的路径
    >        
    >     2. 恢复
    >     
    >        在数据库命令行中创建一个新数据库，通过use使用这个新数据库，通过source导入即可
    >     
    > 2. 图形化界面中
    > 
    >    直接通过按钮等
    >    
## day04
### 1. 多表查询
1. 多表查询
    > 1. 内连接
    >     * 隐式内连接
    >     
    >        使用WHERE消除无用数据，如：SELECT stu.name, pro.math FROM student AS stu, project AS pro WHERE stu.`pro_id` = pro.`id`;
    >        
    >     * 显式内连接
    >     
    >        使用INNER JOIN ... ON，如：SELECT 查询字段 FROM 表1 [INNER] JOIN 表2 ON 条件
    >        
    >     * **内连接查询使用注意事项：**
    >     
    >        1、从哪些表中查询数据
    >        
    >        2、如何判断有效数据
    >        
    >        3、查询哪些字段
    >     
    > 2. 外连接
    > 
    >    左外连接：SELECT 字段 FROM 表1 LEFT [OUTER] JOIN 表2 ON 条件
    >    
    >    右外连接：SELECT 字段 FROM 表1 RIGHT [OUTER] JOIN 表2 ON 条件
    >    
    > 3. 子查询：查询中嵌套查询
    > 
    >    SELECT 字段 FROM 表1 FROM (SELECT 字段 FROM 表2) WHERE xxx;
    >    
    >     * 子查询的不同情况：
    >    
    >         1. 子查询的结果是单行单列
    >         
    >            子查询可以作为条件，使用各种运算符运算
    >            
    >         2. 子查询的结果是多行单列
    >         
    >            子查询可以作为IN()中()的集合
    >            
    >         3. 子查询的结果是多行多列
    >         
    >            子查询可以作为虚拟表进行表的查询
    >            
### 2. 事务
2. 事务
    > 1. 事务的概念
    > 
    >    如果一个包含多个步骤的业务操作被事务管理着，要么同时成功，要么同时失败
    >    
    > 2. 事务的操作
    > 
    >    1、开启：start transaction
    >    
    >    2、回滚：rollback
    >    
    >    3、提交：commit
    >    
    > 3. 事务默认自动提交
    > 
    >    MySql数据库默认事务自动提交，即一条DML语句会自动提交一次事务。
    >    
    >    事务可以手动提交，需要先开启事务，再提交
    >    
    >    查看事务的默认提交方式用到的SQL语句：SELECT @@autocommit;，其中1代表自动提交，0代表手动提交
    >    
    >    修改事务默认提交方式的SQL语句：SET @@autocommit = xxx;，如果修改了事务默认提交方式为手动提交，则以后的DML语句必须要写commit，否则不会生效
    >    
    > 4. 事务的四大特征ACID
    > 
    >    1、原子性：不可分割的最小操作单位，要么同时成功，要么同时失败
    >    
    >    2、持久性：一旦事务提交或者回滚，则会持久性的更新数据表
    >    
    >    3、隔离性：多个事务之间相互独立
    >    
    >    4、一致性：事务操作前后，数据的总量不变
    >    
    > 5. 事务隔离的级别
    >    1. 概念
    >    
    >       多个事务之间是相互独立的，但是如果多个事务操作同一批数据，会引发一系列的问题。要解决这些问题需要设置隔离级别
    >       
    >       多个事务操作同一批数据会引发的问题有：
    >       
    >       1、脏读：一个事务读取到另一个事务中未提交的数据
    >       
    >       2、不可重复读：同一个事务中两次读取到的数据不同
    >       
    >       3、幻读：一个事务进行DML操作所有数据，如果另一个事务添加了一条数据，则第一个事务无法查看到自己的修改
    >    
    >     2. 隔离级别（了解）
    >    
    >        1、READ UNCOMMITTED：读未提交。此级别会引发的问题，脏读、不可重复读、幻读
    >        
    >        2、READ COMMITTED：读已提交。此级别会引发的问题，不可重复读，幻读
    >        
    >        3、REPEATABLE READ：可重复读。此级别会引发的问题，幻读
    >        
    >        4、SERIALIZABLE：串行化。此级别不会产生所有问题。类似于多线程中加锁的操作。
    >        
    >        隔离级别从小到大的安全性递增，但是效率递减。
    >        
    >        **MySql默认隔离级别为REPEATABLE READ，Oracle默认隔离级别为READ COMMITTED**

### 3. DCL：管理用户，授权
3. DCL：管理用户，授权
    > 1. 管理用户
    >     1. 添加用户
    >     
    >        USE mysql，在mysql数据库下创建，使用DCL的语法：CREATE USER '用户名'@'主机名' IDENTIFIED BY '密码';
    >        
    >     2. 删除用户
    >     
    >        DCL语法：DROP USER '用户名'@'密码';
    >        
    >     3. 修改用户登录密码
    >     
    >        DML语法：UPDATE USER PASSWORD = PASSWORD('新密码') WHERE USER = '用户名';
    >        
    >     4. 查询用户
    >     
    >        用户信息保存在mysql这个数据库中的user表中，通过查询user表来查询用户。其中HOST中的%代表此用户可以在任何主机访问。
    >     
    > 2. 授权登录
    >     1. 授予权限
    >     
    >        GRANT 权限1, 权限2, ... ON 数据库名.表名 TO '用户名'@'主机名';
    >        
    >        所有权限：ALL
    >        
    >        所有库/所有表：*
    >        
    >        授予一个用户所有库所有表的所有权限：GRANT ALL ON *.* TO '用户名'@'主机名';
    >        
    >     2. 撤销权限
    >     
    >        REVOKE 权限1, ... ON 数据库名.表名 FROM '用户名'@'主机名';
    >        
    >     3. 查询权限
    >     
    >        SHOW GRANTS FOR '用户名'@'主机名';
    >        

## day05
### 1. JDBC
1. JDBC
    > 1. JDBC概念
    > 
    >    Java DataBase Connective：Java数据库连接
    >    
    > 2. JDBC本质
    > 
    >    官方（SUN公司）定义的一套操作关系型数据库的规则（接口）。每个数据库厂商实现这些接口，提供关于数据库驱动的jar包，因此我们实际是使用这套接口编程，真正执行的是这些jar包中的实现类
    >    
    > 3. 使用JDBC步骤
    >     1. 导入jar包
    >     
    >        1、复制jar包到项目的libs文件夹下
    >        
    >        2、对libs文件夹右键，选择Add As Library
    >        
    >     2. 注册驱动
    >     
    >        Class.forName("com.mysql.jdbc.Driver");
    >        
    >     3. 获取数据库连接对象：Connection
    >     
    >        Connection conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/数据库名?useSSL=false", "用户名", "密码");
    >        
    >        **注意：建立对象的url需要后边添加?useSSL=false，因为根据MySQL 5.5.45+、5.6.26+和5.7.6+的要求，如果没有设置显式选项，则必须默认建立SSL连接。**
    >        
    >     4. 定义SQL
    >     
    >        String sql = "xxx";
    >        
    >     5. 获取执行SQL的对象：Statement
    >     
    >        Statement stmt = conn.createStatement();
    >        
    >     6. 执行SQL，获取返回的结果
    >     
    >        stmt.execute
    >        
    >     7. 释放资源，注意，最后申请的资源要最先释放
    >     
    >        stmt.close();
    >        
    >        conn.close();
    >     
    > 4. 详解对象
    >     1. DriverManager：驱动管理对象，原型是类
    >         * 功能
    >             1. 注册驱动：告诉程序使用什么驱动jar包
    >             
    >                 ```
    >                 static void registerDriver(Driver driver)：注册指定的驱动程序
    >                 ```
    >               
    >                写代码使用这个语句注册驱动：Class.forName("com.mysql.jdbc.Driver")。因为通过查看源码可知，在com.mysql.jdbc.Driver类中有静态代码块，静态代码块中就用的是DriverManager注册驱动的静态方法，因此当Driver类被导入时，静态代码块中的注册驱动的方法自动执行了。
    >               
    >                **注意：在mysql5之后的驱动，可以不用写注册驱动了，因为在mysql驱动jar包中有一个META-INF文件夹下的service文件夹下的java.sql.Driver文件已经自动注册了驱动。**
    >               
    >             2. 获取数据库连接
    >             
    >                 ```
    >                 static Connection getConnection(String url, String user, String password)
    >                 ```
    >                
    >                参数：
    >                
    >                url：指定连接路径，语法：jdbc:mysql://ip地址（域名）:端口号/数据库名称，如果连接主机且端口号为3306，可以简写url为jdbc:mysql:///数据库名称
    >                
    >                user：指定用户
    >                
    >                password：用户密码
    >         
    >     2. Connection：数据库连接对象，原型是接口
    >         * 功能
    >             1. 获取执行sql的对象
    >             
    >                 ```
    >                 Statement createStatement()
    >                 ```
    >                 
    >                 ```
    >                 PreparedStatement prepareStatement(String sql)
    >                 ```
    >                 
    >             2. 管理事务
    >                 * 开启事务：
    >                 
    >                     ```
    >                     void setAutoCommit(boolean autocommit) -- 参数设置为false，即开启事务
    >                     ```
    >                     
    >                 * 提交事务：
    >                 
    >                     ```
    >                     void commit()
    >                     ```
    >                     
    >                 * 回滚事务：
    >                 
    >                     ```
    >                     void rollback()
    >                     ```
    >         
    >     3. Statement：执行静态sql的对象，原型是接口
    >         * 功能
    >             1. 执行SQL
    >             
    >                 ```
    >                 boolean execute(String sql) -- 执行任意sql，只做了解
    >                 ```
    >                 
    >                 ```
    >                 int executeUpdate(String sql) -- 执行DML语句、DDL语句，返回值：影响的行数，可以通过返回值来知道sql执行是否成功
    >                 ```
    >                 
    >                 ```
    >                 ResultSet executeQuery(String sql) -- 执行DQL语句，返回值：结果集对象
    >                 ```
    >         
    >     4. ResultSet：结果集对象，原型是接口
    >     
    >        **注意：ResultSet也是一个资源，使用后也需要释放资源**
    >        
    >         * 功能
    >        
    >             ```
    >             boolean next() -- 指针向下移动一次，判断是否为最后一行末尾即判断是否有数据，没有数据则返回false，有数据则返回true
    >             ```
    >             
    >             ```
    >             getXxx(参数) -- 获取Xxx类型的数据，如getInt()、getString()，参数：参数有两种形式，传递Int类型代表列的编号，列编号从1开始；传递String类型代表列的名称
    >             ```
    >             
    >         * 使用方式：
    >        
    >            1、循环的游标向下移动,判断是否有数据
    >            
    >            2、有则获取
    >        
    >     5. PreparedStatement：执行预编译sql的对象，原型是接口
    >     
    >        为了解决sql注入问题
    >        
    >         * 步骤
    >        
    >            1、定于sql时：使用?作为占位符
    >            
    >            2、获取执行sql的对象：Connection接口中有prepareStatement(String sql)方法返回PrepareStatement对象，参数为使用了占位符的sql
    >            
    >            3、为占位符赋值：PrepareStatement中有setXxx(参数1, 参数2)方法为占位符赋值，Xxx为各种数据类型，参数1为?的编号，编号从1开始；参数2为?的值
    >            
    >            4、执行sql：不需要传递sql参数了
    >            
    >            5、最后也需要释放PrepareStatement对象
### 2. 抽取JDBC工具类
2. 抽取JDBC工具类
    > 1. JDBC工具类介绍
    > 
    >    这是我们自定义的类，由于JDBC代码重复率较高，因此我们可以抽取公用代码形成JDBC工具类，暂定名称为JDBCUtils，新建一个utils文件夹，将工具类放入其中。
    >    
    > 2. JDBC工具类作用
    >     1. 抽取注册驱动
    >     
    >        注册驱动可以将驱动信息放入配置，然后在静态代码块中直接完成读取配置中驱动信息，然后注册驱动
    >        
    >     2. 抽取方法获取连接对象
    >     
    >        需求：不传递参数，但是保证工具类的通用性，即动态获取
    >        
    >        解决方案：通过配置文件解决这个需求
    >        
    >         * 实现步骤：
    >        
    >            1、在一个配置文件中写各种配置，如url，user，password
    >            
    >            2、在工具类中，通过静态代码块做到自动读取配置文件将各种配置赋值给类中的属性，之后的方法中只需要使用这些属性即可。
    >            
    >            3、在使用FileReader()加载文件时，需要先使用类加载器ClassLoader来获取文件地址。
    >            
    >             * **ClassLoader类加载器可以获取src下的文件，使用ClassLoader类加载器步骤：**
    >                **1、任意的类的class对象中都有一个方法getClassLoader()来获取类加载器对象，如ClassLoader classloader = JDBCUtils.class.getClassLoader();**
    >                
    >                **2、类加载器对象中有一个getResource(String url)方法，该方法以src目录为对照，向获取哪个文件就写哪个文件相对于src的路径，该方法返回一个URL对象，如：URL res = classloader.getResource("xxx.properties");**
    >                
    >                **3、URL对象中有一个getPath()方法，可以返回该URL对象的字符串路径，如：String path = res.getPath();**
    >                
    >                **4、把上述的path放入FileReader作为其参数**
    >        
    >     3. 抽取方法释放资源
    >     
    >        普通的定义一个释放资源方法，然后把释放资源的代码放进去即可
    >        
    >        **注意：每个异常都要各自进行try catch()，不能将多个可能会产生异常的代码写入一个try中，因为如果前一个代码产生异常，会导致直接跳转到catch，从而下面的代码无法执行，造成资源无法关闭。**
    >        
### 3. JDBC控制事务
3. JDBC控制事务
    > 1. 介绍
    > 
    >    使用Connection对象中相应的方法管理事务
    >    
    > 2. Connection对象中控制事务的方法
    >    1. 开启事务
    >    
    >        ```
    >        setAutoCommit(boolean autocommit) -- 设置参数为false，开启事务
    >        ```
    >        
    >    2. 提交事务
    >    
    >        ```
    >        commit() -- 在try中最后提交事务
    >        ```
    >        
    >    3. 回滚事务
    >    
    >        ```
    >        rollback() -- 在catch中回滚事务，因为一旦出现异常一定会进入catch中
    >        ```
    >        * 注意:
    >           1、此时的catch需要解决的异常是任意异常，因此需要将参数改为Exception
    >           2、回滚前先判断Connection对象是否为null，不为null才回滚
    >           
## day06
### 1. 数据源
1. 数据源（DataSource）
    > 1. 介绍
    > 
    >    一个存放数据库连接的容器（集合）。系统初始化，容器被创建，容器中会申请一些对象，当用户来访问数据库时，从容器中获取连接池对象，当用户访问完毕，归还对象。
    >    
    > 2. 使用连接池的好处
    > 
    >    1、高效
    >    
    >    2、利用率高
    >    
    > 3. 连接池的实现
    > 
    >    通过查看API可以看到一个Interface DataSource，这就是数据库连接池。DataSource的实现是由驱动的供应商实现的，我们一般不去实现，或者使用开源的连接池实现技术来作为实现类即可。
    >    
    > 4. 连接池的方法
    > 
    >    获取连接：
    >    
    >     ```
    >     Connection getConnection()
    >     ```
    >    
    >    归还连接：如果Connection连接是从数据库连接池中获取的，则调用close()方法就不是释放资源，而是归还连接。
    >    
    > 5. 连接池实现技术
    > 
    >    **注意：导入数据库连接池jar包后别忘了看是否导入了myql驱动jar包，未导入会报错**
    >    
    >     1. C3P0:较老的技术
    >        1. 使用步骤
    >        
    >            1. 导入jar包：c3p0自己的jar包c3p0-0.9.5.2.jar和依赖jar包mcchange-commons-java-0.2.12.jar两个
    >              
    >            2. 定义配置文件：名称必须命名为c3p0.properties 或者 c3p0-config.xml，将文件直接放在src路径下即可
    >              
    >            3. 创建数据库连接池对象：创建数据库连接池对象，DataSource ds = new ComboPooledDataSource();
    >              
    >               **注意：通过查看C3P0的配置文件可知，C3P0为我们提供两套配置，如果创建连接池对象时无参，则使用默认配置；传参则使用参数所对应的name的配置**
    >              
    >            4. 获取连接：通过使用getConnection()方法
    >        
    >     2. Druid:阿里巴巴提供
    >         1. 使用步骤
    >         
    >             1. 导入jar包：导入druid-1.0.9.jar这一个包
    >             
    >             2. 定义配置文件：druid.properties，但是名称可以是任意的，也可以放在任意的包下，因此我们需要手动加载这个Properties文件
    >             
    >             3. 获取数据库连接池对象：通过一个工厂类DruidDataSourceFactory的静态方法来获取：
    >             
    >                 ```
    >                 static DataSource createDataSource(Properties prop) -- 参数：配置文件的Properties对象 
    >                 ```
    >                 
    >             4. 获取连接：通过getConnection()方法来获取
    >    
    > 6. Druid工具类
    >     1. 介绍
    >     
    >        虽然Druid很好用，但是其中有些步骤也是很繁琐的，我们自定义一个JDBCUntils工具类来简化
    >        
    >     2. 工具类内容
    >        1. 静态代码块：用来加载Druid配置文件和初始化连接池对象，通过静态成员变量接收连接池对象
    >        2. 静态方法们
    >           1. 获取连接池：直接返回静态成员变量即可
    >           2. 获取连接
    >           3. 释放资源
    > 

### 2. Spring JDBC:JDBCTemplate
2. Spring JDBC:JDBC Template
    > 1. 介绍
    > 
    >    是Spring框架提供的JDBC简单封装，提供了JdbcTemplate对象简化开发
    >    
    > 2. 使用步骤
    > 
    >    1、导入jar包
    >    
    >    2、创建JdbcTemplate对象：此对象创建需要传递DataSource为参数，JdbcTemplate template = new JdbcTemplate(ds);
    >    
    >    3、调用JdbcTemplate的方法完成CRUD操作
    >    
    >    **注意：我们不用考虑释放资源，JdbcTemplate会自动释放的**
    > 
    > 3. JdbcTemplate方法
    > 
    >     ```
    >     int update() -- 执行DML语句。增删改语句。参数1：sql语句，参数2：预编译的sql语句中，第一个?的值，参数3：预编译的sql语句中，第二个?的值，依此类推
    >     ```
    >     
    >     ```
    >     Map<String, Object> queryForMap() -- 执行DQL语句，将结果集ResultSet封装为Map集合。参数1：sql语句，参数2：预编译的sql语句中，第一个?的值，依此类推。该方法会将列作为key，值作为value封装成Map集合
    >     ```
    >     
    >     * **注意：该方法查询的结果集长度必须为1**
    >     
    >     ```
    >     List<Map<String, Object>>queryForList() -- 执行DQL语句，将结果集ResultSet封装为list集合。参数1：sql语句，参数2：预编译的sql语句中，第一个?的值，依此类推。将每一个记录封装为Map集合，然后再将Map集合封装给List集合
    >     ```
    >     
    >     ```
    >     List<E> query() -- 执行DQL语句，将结果集ResultSet封装为JavaBean对象。参数1：sql语句，参数2：RowMapper<E>接口的实现对类象。该方法返回一个List对象，List中是RowMapper<E>接口中mapRow()方法的返回值
    >     ```
    >     
    >     * **该方法是正常业务中最常用的**
    >     
    >     * **BeanPropertyRowMapper<E>：**
    >     
    >        **是RowMapper<E>接口的实现类。虽然我们可以直接用匿名内部类方式来实现RowMapper<E>接口：new RowMapper<E>() {xxx;}，但是这样太麻烦，因此我们直接使用官方提供的实现类，使用方法如下：**
    >        
    >         ```
    >         List<E> list = template.query(sql, new BeanPropertyRowMapper<E>(E.class));
    >         其中E是我们定义的存储数据的Java类，E.class是它的字节码文件
    >         ```
    >        
    >     * **建议泛型的Java类中数据类型写成封装类**
    >     
    >     ```
    >     queryForObject() -- 执行DQL语句，将结果集ResultSet封装为对象。参数1：sql语句，参数2：返回值类型的字节码文件，如Long.class,Double.class。一般此方法用来执行一些聚合函数
    >     ```
    >     
## day07
### 1. WEB概述
1. WEB概述
    > 1. JavaWeb
    > 
    >    基于Java语言开发互联网技术的统称
    >    
    > 2. 软件架构
    > 
    >     * C/S:Client/Server，客户端/服务器架构
    >     
    >        缺点：开发安装部署维护麻烦
    >        
    >        优点：用户体验好
    >        
    >     * B/S:Browser/Server，浏览器/服务器架构
    >     
    >        缺点：1、应用过大用户体验会受到影响；2、对硬件要求过高。总体来说这些都是硬件方面的缺点
    >        
    >        优点：开发安装部署维护简单
    >     
    > 3. B/S架构详解
    >     1. 静态资源
    >     
    >         通过静态网页技术开发的资源
    >         
    >         静态资源：图片，文本，视频，音频，HTML，CSS，JS等，后三个着重掌握
    >         
    >        * 特点：
    >        
    >            * 所有用户看到的是一样的
    >            
    >            * 用户申请访问静态资源，服务器直接发送静态资源给浏览器，浏览器内置解析引擎可以展示静态资源
    >        
    >     2. 动态资源（JavaWeb开发的重点）
    >     
    >        通过动态网页技术开发的资源
    >        
    >        动态网页技术：php,asp,jsp/servlet，其中jsp/servlet是JavaWeb开发的技术，重点掌握
    >        
    >         * 特点：
    >        
    >             * 不同人访问看到的结果不一定相同
    >             
    >             * 用户请求的是动态资源，服务器会执行动态资源，转换成静态资源，然后发送给浏览器
    >             * 学习动态资源之前必须要了解静态资源
    >             
### 2. HTML
2. HTML
    > 1. 介绍
    >
    >    超文本标记语言，最基础的网页开发语言
    >    
    > 2. 标签
    >    1. 文件标签
    >        ```
    >        <html></html>
    >        ```
    >        
    >        ```
    >        <head></head>
    >        ```
    >        
    >        ```
    >        <title></title>
    >        ```
    >        
    >        ```
    >        <body></body>
    >        ```
    >       
    >    2. 文本标签
    >    
    >        ```
    >        <h1></h1> to <h6></h6>
    >        ```
    >        
    >        ```
    >        <br />
    >        ```
    >        ```
    >        <p></p>
    >        ```
    >        
    >        ```
    >        <hr />
    >        ```
    >        
    >        ```
    >        <b></b>
    >        ```
    >        
    >        ```
    >        <i></i>
    >        ```
    >        
    >       注释：
    >       
    >        ```
    >        <!-- 注释 -->
    >        ```
    >       
    >    3. 图片标签
    >    
    >        ```
    >        <img src="xxx" />
    >        ```
    >        
    >    4. 列表标签
    >    
    >        ```
    >        <ol>
    >        	<li></li>
    >        </ol>
    >        ```
    >        ```
    >        <ul>
    >        	<li></li>
    >        </ul>
    >        ```
    >        
    >    5. 超链接标签
    >    
    >        ```
    >        <a href="xxx" target="_self/_blank"></a>
    >        ```
    >        
    >       _self/_blank：_self，默认值，当前页面打开；_blank，新页面打开
    >       
    >    6. 块标签
    >    
    >        ```
    >        <div></div>
    >        ```
    >        
    >        ```
    >        <span></span>
    >        ```
    >        
    >    7. 语义化标签（H5新概念）：使用H5中为了提供程序可读性的标签
    >    
    >        ```
    >        <header></header>
    >        ```
    >        
    >        ```
    >        <footer></footer>
    >        ```
    >        
    >    8. 表格标签
    >    
    >        ```
    >        <table border="x">
    >        	<tr>
    >        		<th></th>
    >        		<th></th>
    >        		<th></th>
    >        	</tr>
    >        	<tr>
    >        		<td></td>
    >        		<td></td>
    >        		<td></td>
    >        	</tr>
    >        	<tr>
    >        		<td></td>
    >        		<td></td>
    >        		<td></td>
    >        	</tr>
    >        </table>
    >        ```
    >        
    >    9. 表单标签
    >    
    >        ```
    >        <form action="xxx" method="get/post">
    >        	<input type="" value="" name="">
    >        </form>
    >        ```
    >        
    >       method属性共有7种，但是两种非常常用，分别为get/post
    >       
    >       get/post区别：1、get请求参数在url显示，post请求参数封装在请求行中；2、get请求请求参数长度有限，post请求请求参数长度不限；3、get请求不太安全，post请求较为安全
    >       
    >       表单项数据想要提交，表单项必须有name属性
    >       
    >        * 表单项类型：
    >       
    >            * ```<input type="xxx" name="xxx">```
    >            
    >                * ```<label for="input标签的id值">xxx</label>```
    >                
    >                   该标签一般和input标签配合使用，如```<label for="username" >用户名</label><input type="text" id="username">```，当点击用户名时，光标自动跳转到input表单项中
    >            
    >                * type属性取值：
    >                
    >                    * text：文本
    >                    
    >                        * placeholder属性：指定默认提示信息
    >                    
    >                    * password：密码
    >                    
    >                    * radio：单选。
    >                    
    >                       注意：1、想让多个单选实现单选效果，name属性值必须相同；2、一般我们提供value的值，作为被选中后提交的值；3、我们可以使用checked属性，表示默认被选中
    >                       
    >                    * checkbox：多选。
    >                    
    >                       注意；1、想让多个单选实现多选效果，name属性值必须相同，一般使用这种命名格式：hobby[]；2、一般我们提供value的值，作为被选中后提交的值；3、我们可以使用checked属性，表示默认被选中
    >                       
    >                    * file：图片
    >                    
    >                    * hidden：隐藏域
    >                    
    >                    * submmit：提交按钮
    >                    
    >                    * button：单纯一个按钮
    >                    
    >                    * image：图片式提交按钮，使用时需要在input标签中增加src属性
    >                    * H5新增的一些type值：
    >                    
    >                        * date：日期控件
    >                        
    >                        * datetime-local：详细日期控件
    >                        
    >                        * email：邮箱控件，它会做基本正则校验
    >                
    >            * ```<select> </select>```
    >            
    >               基本使用形式：
    >               
    >                ```
    >                <select name="xxx">
    >                	<option value="xx">xxx</option>
    >                	<option value="xx">xxx</option>
    >                </select>
    >                ```
    >               
    >                 * 属性：
    >                 
    >                     * selected：设置该option为默认选中
    >                     
    >                     * value：设置提交时传递的值
    >               
    >            * ```<textarea cols="xx" rows="xx">```
    >            
    >                * 属性：
    >                
    >                    * cols：默认多少列
    >                    
    >                    * rows：默认多少行
    >       
## day08
### 1. CSS
1. CSS
    > 1. 概述
    >
    >    层叠样式表
    >    
    > 2. CSS好处
    >
    >    1、功能强大
    >    
    >    2、代码耦合度降低
    >    
    > 3. CSS使用方式
    >
    >    1、内联样式
    >    
    >    2、内部样式
    >    
    >    3、外部样式
    >    
    > 4. 选择器
    >    1. 基本选择器
    >    
    >        * id选择器：#id名
    >        
    >        * 元素选择器：元素名
    >        
    >        * 类选择器：.类名
    >       
    >    2. 扩展选择器
    >    
    >        * 通配符选择器：\* 
    >        
    >        * 并集选择：选择器1,选择器2
    >        
    >        * 后代选择器：选择器1 选择器2
    >        
    >        * 子代选择器：选择器1\>选择器2
    >        
    >        * 属性选择器：元素名称[属性名="属性值"]
    >        
    >        * 伪类选择器；选择器:状态
    >        
    >            * 状态：
    >            
    >               1、link：初始状态
    >               
    >               2、visited：被访问后的状态
    >               
    >               3、active：正在访问的状态
    >               
    >               4、hover：鼠标悬停的状态 
    > 5. 属性
    >     1. 字体、文本
    >     
    >        font-size
    >        
    >        color
    >        
    >        text-align
    >        
    >        line-height
    >        
    >     2. 背景
    >     
    >        background: url("xxx");
    >        
    >     3. 边框
    >     
    >        border
    >        
    >     4. 尺寸
    >     
    >        float
    >       
    >     5. 盒子模型
    >     
    >        margin
    >        
    >        padding   
    > 
## day09
### 1. JavaScript基础
1. JavaScript基础
    > 1. 概念
    >
    >    客户端脚本语言。运行在客户端浏览器中，每个浏览器存在JavaScript的解析引擎
    >    
    > 2. JS功能
    >
    >    可以增强用户和HTML的交互，可以控制页面元素，让界面有些动态效果
    >    
    > 3. JS发展史
    >
    >    1992年，Nombase公司，开发出第一门客户端脚本语言：C--，后来更名为：ScriptEase；1995年，NetSpace公司（网景公司），开发了另一门客户端脚本语言：LiveScript，后来请来SUN公司专家改进LiveScript语言改名为JavaScript；1996年，MicroSoft抄袭JavaScript开发出JScript搭载到自己的IE浏览器；1997年ECMA（欧洲计算机协会）指定客户端脚本语言规范，起名为：ECMAScript，是所有的客户端脚本语言规范
    >    
    >    因此JavaScript = ECMAScript + JS特有的东西（BOM和DOM）
    >    
    > 4. ECMAScript
    >     1. 基本语法
    >         1. JS和HTML结合方法
    >         
    >            1、内部JS
    >            
    >            2、外部JS
    >            
    >         2. 注释
    >         
    >            单行注释：//
    >            
    >            多行注释：/**/
    >            
    >         3. 数据类型
    >             * 原始数据类型
    >             
    >                number：数字。整数/小数/NaN
    >                
    >                string：字符串。"abc"或'abc'都可以
    >                
    >                boolean
    >                
    >                null：对象为空的占位符
    >                
    >                undefined：未定义。如果一个变量没有初始化，则默认undefined
    >                
    >             * 引用数据类型：对象
    >             
    >        4. 变量：一小片存储数据的内存空间
    >        
    >            ```
    >            var 变量名 = 变量值;
    >            ```
    >           
    >           **typeof(xxx)运算符：可以得到变量的数据类型**
    >           
    >           **JS中，使用var定义的变量是局部变量；省略var定义的是全局变量**
    >           
    >        5. 运算符
    >        
    >            * 一元运算符：
    >            
    >               +、-、++、--
    >               
    >            * 算数运算符
    >            
    >            * 赋值运算符
    >            
    >            * 比较运算符
    >            
    >               JS中特有的是：===
    >            
    >            * 逻辑运算符
    >            
    >            * 三元运算符
    >            
    >            * JS中运算数不是运算符要求的数据类型，JS引擎会自动做数据转换。注意，string类型和number类型是按照字面值转的，字面值转不了数字，直接转成NaN
    >            
    >        6. 流程控制语句
    >        
    >            * if...else
    >            
    >            * switch
    >            
    >               Java中switch语句可以接收byte/short/int/char/枚举（1.5新）/String（1.7新）类型的数据；JS中可以接收任意类型的数据
    >               
    >            * while
    >            
    >            * do...while
    >            
    >            * for
    >        
    >     2. 基本对象	
    >     
    >         * Function：方法对象
    >             1. 创建
    >             
    >                 ```
    >                 var fun = new Function(形参列表, 方法体);
    >                 ```
    >                 
    >                 ```
    >                 function 方法名(形参列表) { 方法体 }
    >                 ```
    >                 
    >                 ```
    >                 var 方法名 = function(形参列表){ 方法体 }   
    >                 ```
    >                 
    >             2. 方法 
    >             
    >             3. 属性
    >             
    >                 ```
    >                 length -- 属性返回方法的形参个数
    >                 ```
    >                 
    >             4. 特点
    >             
    >                1、JS中，方法的形参类型不用写，返回值类型也不用写
    >                
    >                2、定义相同的方法，后边的会覆盖前面的
    >                
    >                3、在JS中方法的调用只与方法名有关，和形参列表无关，即只要方法名写对，无论是否传递参数、传递多少个参数都会调用这个方法
    >                
    >                4、在方法声明中有一个隐藏对象（数组）arguments，它封装所有以后传递进方法的实参。如果我们参数的个数不确定，Java中用重载和...来做，而JS中可以用arguments对象来做
    >             
    >         * Array对象
    >             1. 创建
    >             
    >                 ```
    >                 var arr = new Array(元素列表);
    >                 ```
    >                 
    >                 ```
    >                 var arr = new Array(数组长度);
    >                 ```
    >                 
    >                 ```
    >                 var arr = [元素列表];
    >                 ```
    >                 
    >             2. 方法
    >             
    >                 ```
    >                 join(分隔符) -- 将数组中的元素按照参数为分隔，拼接为字符串
    >                 ```
    >                 
    >                 ```
    >                 push(值) -- 给数组的末尾添加元素
    >                 ```
    >                 
    >             3. 属性
    >             
    >                 ```
    >                 length -- 返回数组长度
    >                 ```
    >             
    >             4. 特点
    >             
    >                1、JS中，数组元素类型可以不同
    >             
    >                2、JS中，数组长度可变。如果访问超出默认数组长度的值，数组会自动扩容，同时超出的部分值为undefined
    >             
    >         * Date对象：日期对象
    >             1. 创建
    >             
    >                 ```
    >                 var date = new Date();
    >                 ```
    >                 
    >             2. 方法
    >             
    >                 ```
    >                 toLocaleString() -- 返回当前Date对象对应的本地时间字符串格式
    >                 ```
    >                 
    >                 ```
    >                 getTime() -- 获取毫秒值。获取当前时间和1970年1月1日的时间差的毫秒值
    >                 ```
    >                 
    >             3. 属性
    >             
    >             4. 特点
    >             
    >         * Math对象
    >             1. 创建
    >             
    >                该对象不用创建，直接通过Math用里面的方法、属性
    >                
    >             2. 方法
    >             
    >                 ```
    >                 random() -- 产生0~1的随机数，范围为[0, 1)
    >                 ```
    >                 
    >                 ```
    >                 ceil(值) -- 对值向上取整
    >                 ```
    >                 
    >                 ```
    >                 floor(值) -- 对值向下取整 
    >                 ```
    >                 
    >                 ```
    >                 round(值) -- 对值四舍五入
    >                 ```
    >                 
    >             3. 属性
    >             
    >                 ```
    >                 PI -- 返回圆周率的估计值
    >                 ```
    >                 
    >             4. 特点
    >             
    >         * RegExp对象：正则表达式对象
    >             1. 正则表达式简介
    >                 1. 单个字符：[]
    >                 
    >                    如[ab], [a-z], [a-zA-Z0-9]
    >                    
    >                    **特殊符号代表单个字符：1、\d -- 代表0~9的单个数字字符，相当于[0-9]；2、\w -- 代表数字、字母、下划线的单词字符，相当于[0-9a-zA-Z_]**
    >                    
    >                 2. 量词符号：*、?、+、{}
    >                 
    >                    *：出现0次或多次
    >                    
    >                    ?：出现0次或1次
    >                    
    >                    +：出现1次或多次
    >                    
    >                    {m, n}：大于等于m小于等于n。{,n}，表示最多n次；{m,}，表示最少m次
    >                3. 开始结束符号
    >                
    >                    ^：开始
    >                    
    >                    $：结束
    >                
    >             2. 创建
    >         
    >                 ```
    >                 var reg = new RegExp("正则表达式");注意：这种创建方式里面，正则表达式是字符串的，必须写成\\的形式
    >                 ```
    >             
    >                 ```
    >                 var reg = /正则表达式/;
    >                 ```
    >             
    >             3. 方法
    >         
    >                 ```
    >                 test(字符串) -- 验证字符串是否符合正则表达式，符合返回true，不符合返回false
    >                 ```
    >             
    >             4. 属性
    >         
    >             5. 特点
    >             
    >         * Global对象：全局对象
    >         
    >             1. 特点
    >             
    >                因为是全局对象，所以不需要对象名，直接：方法名();
    >                
    >             2. 方法
    >             
    >                **由于传输协议不支持中文数据，所以转码中文数据，转码用的最多的是URL编码。下面四种都是URL编码和解码的方法，两两对应。**
    >                
    >                 ```
    >                 encodeURI(参数) -- 编码
    >                 ```
    >                
    >                 ```
    >                 decodeURI(参数) -- 解码
    >                 ```
    >                
    >                 ```
    >                 encodeURIComponent(参数) -- 编码，字符更多
    >                 ```
    >                
    >                 ```
    >                 decodeURIComponent(参数) -- 解码，字符更多
    >                 ```
    >                
    >                 ```
    >                 parseInt(参数) -- 从第一个字符开始逐一判断每一个字符是否为数字，直到不是数字为止，将是数字的转为数字并返回这个值
    >                 ```
    >                
    >                 ```
    >                 isNaN(参数) -- 判断值是否为NaN。注意：NaN参与的==全部为false，包括它自己的==比较也为false，因此需要这个方法来判断是否为NaN
    >                 ```
    >                
    >                 ```
    >                 eval(参数) -- 将JS的字符串转换成JS脚本来执行
    >                 ```
    >                
## day10
### 1. JavaScript高级
1. JavaScript高级
    > 1. DOM
    >     1. 介绍
    >     
    >        Document Object Model，文档对象模型。将标记文档的各个部分封装成对象，通过这些对象进行CRUD操作 
    >        
    >     2. 核心DOM（最基础的DOM，针对任何结构化的标准模型）
    >         1. 对象（前三个重点掌握）
    >             * Document：文档对象
    >                 1. 获取
    >                    通过window.document或者直接document获取
    >                 2. 方法
    >                     1. 获取Element对象
    >                     
    >                         ```
    >                         getElementById(id值) -- 返回id对应的元素对象
    >                         ```
    >                         
    >                         ```
    >                         getElementsByTagName(标签名) -- 返回所有具有指定名称的节点。返回值为数组对象
    >                         ```
    >                         
    >                         ```
    >                         getElementsByClassName() -- 返回具有指定class值的元素。返回值为数组对象
    >                         ```
    >                         
    >                     2. 创建其他DOM对象
    >                     
    >                         ```
    >                         createAttribute(name)
    >                         ```
    >                         
    >                         ```
    >                         createComment()
    >                         ```
    >                         
    >                         ```
    >                         createElement(标签名)
    >                         ```
    >                         
    >                         ```
    >                         createTextNode(文本) -- 根据文本创建文本节点
    >                         ```
    >                 
    >             * Element：元素对象
    >                 1. 获取或创建
    >                 
    >                    通过document来获取和创建
    >                    
    >                 2. 方法
    >                 
    >                     ```
    >                     removeAttribute(属性名) -- 删除属性
    >                     ```
    >                     
    >                     ```
    >                     setAttribute(属性名, 属性值) -- 设置属性
    >                     ```
    >                 
    >             * Node：节点对象，是其他5个对象的父对象
    >                 1. 特点
    >                 
    >                    所有的DOM对象都可以被认为是一个节点
    >                    
    >                 2. 方法
    >                    1. 添加
    >                    
    >                        ```
    >                        appendChild(创建的节点对象) -- 向当前节点的子节点列表末尾添加一个子节点
    >                        ```
    >                        
    >                    2. 删除
    >                    
    >                        ```
    >                        removeChild(子节点对象) -- 删除并返回当前节点的指定子节点
    >                        ```
    >                        
    >                       **如何让超链接保留可以点击的功能，但是不允许跳转呢？将超链接的href属性设置为javascript:void(0);即可，如：```<a href="javascript:void(0);">只能点击</a>```**
    >                       
    >                    3. 修改
    >                    
    >                        ```
    >                        replaceChild() -- 用新节点替换旧节点
    >                        ```
    >                    
    >                3. 属性
    >                
    >                    ```
    >                    parentNode -- 返回当前节点的父节点
    >                    ```
    >                
    >             * Attribute：属性对象
    >             
    >             * Text：文本对象
    >             
    >             * Comment：注释对象 
    >         
    >     3. HTML DOM
    >         1. 简介
    >         
    >            关于如何获取、修改、删除、添加HTML元素的标准，是标准DOM的扩展。
    >            
    >         2. 标签体的设置和获取
    >         
    >             ```
    >             innerHTML -- 可以获取标签体和设置标签体；追加操作：节点对象.innerHTML += 标签或文本
    >             ```
    >             
    >         3. 使用HTML元素的属性
    >         
    >         4. 设置样式
    >              1. 方式1
    >              
    >                  ```
    >                  节点对象.style.样式名称 = 值，如：
    >                  var div = document.getElementsByTagName("div")[0];
    >                  div.style.border = "1px solid black";
    >                  div.style.color = "blue";
    >                  div.style.fontSize = "15px";
    >                  ```
    >                  
    >              2. 方式2
    >              
    >                  ```
    >                  提前定义好类的CSS样式，可以设置节点元素className来改变其样式，如：
    >                  var div = document.getElementsByTagName("div")[1];
    >                  div.className = "d1";
    >                  ```
    >         
    >     4. 事件
    >         1. 事件监听机制
    >         
    >            当某些组件被执行某些操作后，某些代码会执行。
    >            
    >             * 事件：某些操作；
    >            
    >             * 事件源：组件；监听器：代码；
    >            
    >             * 注册监听：绑定事件、事件源、监听
    >            
    >         2. 常见事件
    >             1. 点击事件
    >             
    >                 * 单击事件：onclick
    >                 
    >                 * 双击事件：ondblclick
    >                 
    >             2. 焦点事件
    >             
    >                 * 失去焦点：onblur。一般用于表单验证
    >                 
    >                 * 获取焦点：onfocus
    >                 
    >             3. 加载事件
    >             
    >                 * 完成加载：onload
    >                 
    >             4. 鼠标事件
    >             
    >                 * 鼠标按下：onmousedown 
    >                 
    >                     * 此事件被触发会传递一个event对象给事件的方法，我们定义方法时定义形参evt接受event对象。event对象的button属性返回按下的鼠标按键，鼠标左键返回0，鼠标滚轮返回1，鼠标右键返回2
    >                 
    >                 * 鼠标移动：onmousemove
    >                 
    >                 * 鼠标从某个元素移开：onmouseout
    >                 
    >                 * 鼠标移到某个元素上：onmouseover
    >                 
    >                 * 鼠标松开：onmouseup
    >                 
    >             5. 键盘事件
    >             
    >                 * 某个按键按下：onkeydown
    >                 
    >                     * 此事件被触发会传递一个event对象给事件的方法。event对象中的keyCode属性返回按键的Number值，注意，回车对应的number值为13。
    >                 
    >                 * 某个按键松开：onkeyup
    >                 
    >                 * 某个按键按下然后松开：onkeypress
    >                 
    >             6. 选中和改变事件
    >             
    >                 * 域内容改变：onchange，常用于```<select></select>```中```<option></option>```变动触发该事件
    >                 
    >                 * 文本被选中：onselect
    >                 
    >             7. 表单事件
    >             
    >                 * 表单的提交按钮被点击：onsubmit。
    >                 
    >                     * 一般用此事件做表单的校验。如果该事件的方法return true或没有return，则表单正常提交；如果该事件的方法return false，则阻止表单提交
    >         
    >     
    > 2. BOM
    >     1. 简介
    >     
    >        Browser Object Model，浏览器对象模型。即将浏览器的各个组成部分封装成对象
    >     2. BOM组成
    >         1. Navigator：浏览器对象
    >         
    >            不做介绍
    >            
    >         2. Window：浏览器窗口对象
    >             1. 创建
    >             
    >             2. 方法
    >                 1. 弹出窗口相关方法
    >                 
    >                     ```
    >                     alert(提示信息) -- 显示一个带文本信息和确认按钮的警告框
    >                     ```
    >                     
    >                     ```
    >                     confirm(提示信息) -- 显示一个带文本信息、确认按钮、取消按钮的对话框。如果用户点击确定按钮，方法返回true；如果用户点击取消按钮，方法返回false
    >                     ```
    >                     
    >                     ```
    >                     prompt(提示信息) -- 显示可提示用户输入的对话框
    >                     ```
    >                     
    >                 2. 与打开关闭有关的方法
    >                 
    >                     ```
    >                     open(窗口的地址) -- 打开一个新窗口，返回新窗口的window对象
    >                     ```
    >                     
    >                     ```
    >                     close() -- 关闭打开的窗口。注意：哪个widow对象调用，就关闭谁
    >                     ```
    >                     
    >                 3. 与定时器有关的方法
    >                 
    >                     ```
    >                     setTimeOut(方法对象, 毫秒值) -- 一次性定时器，返回一次性定时器对象
    >                     ```
    >                     
    >                     ```
    >                     clearTimeOut(一次性定时器对象) -- 取消某个一次性定时器
    >                     ```
    >                     
    >                     ```
    >                     setInterval(方法对象, 毫秒值) -- 循环定时器，返回循环定时器对象
    >                     ```
    >                     
    >                     ```
    >                     clearIntrval(循环定时器对象) -- 取消某个循环定时器
    >                     ```
    >                 
    >             3. 属性
    >                 1. 获取其他的BOM对象
    >             
    >                     ```
    >                     history -- 获取页面的history对象
    >                     ```
    >                   
    >                     ```
    >                     location -- 获取页面的location对象
    >                     ```
    >                 
    >                     ```
    >                     navigator -- 获取页面的navigator对象
    >                     ```
    >                   
    >                     ```
    >                     screen -- 获取页面的screen对象
    >                     ```
    >                     
    >                 2. 获取DOM对象
    >                 
    >                     ```
    >                     document -- 返回页面的DOM对象
    >                     ```
    >                 
    >             5. 特点
    >             
    >                不用创建对象，直接用window.方法名()的方式来使用即可，window的引用可以省略
    >             
    >         3. History：历史记录对象
    >             1. 创建
    >             
    >                通过window属性获取History对象
    >                
    >             2. 方法
    >             
    >                 ```
    >                 back() -- 加载History列表中前一个URL
    >                 ```
    >                 
    >                 ```
    >                 forward() -- 加载History列表中后一个URL
    >                 ```
    >                 
    >                 ```
    >                 go(参数) -- 加载某个具体页面，参数：正数表示前进几个历史记录；负数表示后退几个历史记录
    >                 ```
    >                 
    >             3. 属性
    >             
    >                 ```
    >                 length -- 返回当前窗口浏览历史URL的数量
    >                 ```
    >                 
    >             4. 特点
    >         
    >         4. Location：地址栏对象 
    >             1. 创建
    >             
    >                通过window属性获取Location对象
    >                
    >             2. 方法
    >             
    >                 ```
    >                 reload() -- 刷新当前文档
    >                 ```
    >                 
    >             3. 属性
    >             
    >                 ```
    >                 href -- 获取或者设置href
    >                 ```
    >                 
    >             4. 特点
    >         
    >         5. Screen：显示器屏幕对象
    >         
    >            不做介绍
    >            
## day11
### 1. BootStrap
1. BootStrap
    > 1. 简介
    >
    >    前段开发框架
    >    
    > 2. 好处
    >
    >    1、有各种CSS样式和JS插件
    >    
    >    2、响应式布局
    >    
    > 3. 使用步骤
    >
    >    1、下载BootStrap并解压
    >    
    >    2、复制内部三个文件夹进项目
    >    
    >    3、当以后创建HTML界面时，通过link标签引入资源
    >    
    >    4、使用BootStrap的东西
    >    
    > 4. 响应式布局
    >     1. 实现
    >     
    >        依赖于栅格系统，栅格系统：将元素分为12份，规定不同的内容占多少份
    >        
    >     2. 使用步骤
    >     
    >         1. 定义容器
    >         
    >            容器分类：1、container（固定宽度）；2、container-fluid（100%宽度）
    >            
    >         2. 定义行
    >         
    >            行样式：row
    >            
    >         3. 定义元素
    >         
    >            元素样式：col-设备代号-份数
    >            
    >             * 设备代号：
    >            
    >                xs：超小屏幕（<768px）；sm：小屏幕（>=768px）；md：中等屏幕（>=992px）；lg：超大屏幕（>=1200px）
    >                
    >             * 1、如果份数超过12，则会导致元素自动换行；2、栅格系统向上兼容；3、真实设备宽度小于设备代号的宽度，一个元素占一行
    >            
    >         4. 指定该元素在不同的设备所占的份数
    >     
    > 5. CSS样式和JS插件
    >     1. 全局CSS样式
    >         * 按钮
    >         
    >            样式：btn btn-具体样式名
    >            
    >         * 图片
    >         
    >            样式：img-responsive(响应式图片)、img-rounded(方图)、img-circle(圆图)、img-thumbnail(相框形式图)；响应式和其他样式可以并存
    >         
    >         * 表格
    >         
    >            样式：table table-borded(表格边框线) table-hover(表格鼠标悬浮时变色)
    >         
    >         * 表单
    >         
    >            查看BootStrap文档自己看
    >         
    >     2. 组件
    >         * 导航条
    >         * 分页条
    >     3. 插件
    >        
    >         * 轮播图
    >         
## day12
### 1. XML
1. XML
    > 1. 介绍
    >
    >    可扩展标记语言。
    >    
    > 2. 功能
    >
    >    存储数据，具体的方向：1、作为配置文件；2、网络中传输数据的载体
    >    
    > 3. 基本语法
    >
    >     1. xml文件第一行必须写xml文档声明：```<?xml version='1.0' ?>```
    >       
    >     2. xml文件有且只能有一个根标签
    >       
    >     3. 属性的属性值必须引号引起来，单引号双引号都可以
    >       
    >     4. 标签必须有结束，可以有自闭和标签
    >       
    >     5. xml标签名称区分大小写
    >     
    > 4. xml文档组成部分
    >
    >     1. 文档声明
    >     
    >        文档第一行必须写：```<?xml 属性列表 ?>```
    >        
    >         * 属性列表：
    >        
    >            version：版本号，固定1.0，必须的属性
    >            
    >            encoding：编码方式，告知解析引擎当前文档的编码表，默认ISO-8859-1
    >            
    >            standalone：是否独立。取值：yes -- 不依赖于其他文件；no -- 依赖于其他文件，一般不写这个属性
    >        
    >     2. 指令（了解即可）
    >     
    >        结合CSS展示数据，但是现在已经不用了
    >        
    >     3. 标签
    >     
    >     4. 属性
    >     
    >        id值唯一
    >        
    >     5. 文本
    >     
    >        我们写的普通文本直接写即可。但是如果要保存一些代码，这些代码中一般会有如\>、\<等符号，我们需要存储到CDATA区，CDATA区文本原样展示。
    >        
    >        CDATA区：```<![CDATA[ 代码块 ]]>```
    >     
    > 5. 约束
    >
    >     1. 介绍
    >     
    >        又名约束文档，用来规定XML文件的书写规则。约束文档一般是由半成品软件（框架）提供，开发者只需要能引入约束文档和阅读约束文档。
    >        
    >     2. 约束文档分类
    >     
    >         1. DTD：简单的约束技术
    >           
    >            缺陷：无法约定标签的内容
    >           
    >         2. Schema：复杂的约束技术 
    >        
    >     3. 引入约束文档
    >     
    >         1. DTD文档的引入
    >         
    >             * 内部DTD文档（定义在XML文档内部）的引入：
    >               
    >             * 外部DTD文档（dtd文件）的引入：
    >             
    >                 * 本地
    >                 
    >                    ```<?xml version='1.0' encoding='UTF-8' ?>```
    >                    ```<!DOCTYPE 根标签名 SYSTEM "DTD文件位置">```
    >                    ```<根标签名>内容</根标签名>```
    >                    
    >                 * 网络
    >                 
    >                    ```<?xml version='1.0' encoding='UTF-8' ?>```
    >                    ```<!DOCTYPE 根标签名 PUBLIC "给DTD文件取个名字" “DTD文件的url地址”>```
    >                    ```<根标签名>内容</根标签名>```
    >             
    >         2. Schema文档的引入
    >         
    >             * 外部Schema文档（xsd文件）的引入：
    >             
    >                1、填入根标签
    >                
    >                2、引入xsi前缀：xmlns:xsi="xxx"
    >                
    >                3、引入xsd命名空间：xsi:schemaLocation=“命名空间 xsd文件名”
    >                
    >                4、为每一个xsd约束声明一个前缀作为标识：xmlns:前缀名="命名空间"，所有的标签，包括根标签都要加前缀，如<根标签名:前缀名 xxx>。如果只有一个xsd约束，可以简写成xmlns="xxx"，之后的标签不用加前缀
    >                
    >                 ```
    >                 <根标签名 xmlns:xsi="xxx" 
    >                             xsi:schemaLocation="xxx xxx.xsd"
    >                              xmlns=“xxx"
    >                 >内容</根标签名>
    >                 ```
    >     
    > 6. 解析：操作xml文档，将文档中的数据导入到内存中
    >
    >     1. 解析xml的方式（又名解析xml的思想）
    >     
    >         * DOM：和HTML的DOM一样，将标记语言文档一次性加载进内存，形成DOM树
    >         
    >            优点：操作方便，可以直接进行CRUD操作
    >            
    >            缺点：由于一次性加载，所以形成的DOM树很庞大，非常占用内存，不适用于内存小的设备
    >            
    >         * SAX：逐行读取，基于事件驱动。类似于有个指针，每次读取一行，读取完毕后指针下移一行，同时上一次读取的内容释放，保证内存中只有一行数据读取到；同时由于只有一行被读取，所以无法判断是什么内容，因此需要基于事件驱动来判断
    >         
    >            优点：不占内存
    >            
    >            缺点：只能读取，无法CRUD
    >            
    >         * 综上，我们在服务器端使用DOM解析；在移动端如Android使用SAX解析
    >         
    >     2. 常见的解析器
    >     
    >         * JASP：SUN公司提供的解析器，支持DOM和SAX。比较慢，性能低
    >         
    >         * DOM4J：一看非常优秀的解析器 
    >         
    >         * Jsoup：本身是HTML解析器，但是非常好用，可以同时用于XML的解析
    >         
    >         * PULL：Android内置的解析器，SAX方式解析器
    >         
    >     3. Jsoup解析器
    >     
    >         1. 相应对象和工具类
    >         
    >             * Jsoup：工具类，可以解析xml或html文档， 返回document对象
    >             
    >                 ```
    >                 Document parse(File in, String charsetName) -- 解析xml或html文件 
    >                 ```
    >                 
    >                 ```
    >                 Document parse(String xml) -- 解析xml或html的字符串
    >                 ```
    >                 
    >                 ```
    >                 Document parse(URL url, int timeoutMills) -- 根据网络路径解析xml或html文件
    >                 ```
    >                 
    >             * Document对象：文档对象，代表了内存中的DOM树
    >             
    >                Document对象继承了Element对象，Document对象中的获取Element对象的方法是继承自Element的
    >                
    >                 ```
    >                 Elements getElementsByXxx(参数) -- 根据参数获取Elements对象，该对象继承了ArrayList<Element>，可以理解为Element对象的集合
    >                 ```
    >                
    >                 ```
    >                 Element getElementByXxx(参数) -- 根据参数获取Element对象
    >                 ```
    >                
    >             * Elements对象
    >             * Element对象
    >             
    >                 1. 获取子元素对象
    >                 
    >                     ```
    >                     Elements getElementsByXxx(参数) -- 根据参数获取Elements对象，该对象继承了ArrayList<Element>，可以理解为Element对象的集合
    >                     ```
    >                 
    >                     ```
    >                     Element getElementByXxx(参数) -- 根据参数获取Element对象
    >                     ```
    >                     
    >                 2. 获取属性值
    >                 
    >                     ```
    >                     String attr(String key) -- 根据属性名称获取属性值，不区分大小写
    >                     ```
    >                     
    >                 3. 获取文本内容
    >                 
    >                     ```
    >                     String text() -- 获取纯文本内容
    >                     ```
    >                     
    >                     ```
    >                     String html() -- 获取标签体所有内容，包括子标签的字符串形式
    >                     ```
    >                 
    >             * Node对象
    >             
    >                是Element对象的父类，因此也是Document对象的父类。
    >             
    >         2. 使用步骤
    >            
    >            1. 导入jar包
    >               
    >             2. 获取Document对象
    >            
    >                1、通过类加载器获取xml文档的path：
    >                
    >                 ```
    >                 String path = 类名.getClassLoader().getResource(xml文档的路径).getPath();
    >                 ```
    >                
    >                2、使用Jsoup的静态方法获取Document对象：
    >                
    >                 ```
    >                 Document doc = Jsoup.parse(new File(path), "utf-8");
    >                 ```
    >               
    >             3. 获取对应的标签Element对象
    >                
    >             4. 获取数据
    >            
    >         3. 快捷查询方式
    >         
    >             1. selector：选择器
    >             
    >                 * 使用方式：在Element对象中有个方法select就是用来查找的，由于Document对象是继承自Element对象，我们可以直接使用Document对象调用这个方法
    >                 
    >                     ```
    >                     Element select(String cssQuery) -- 根据selector语法定义的字符串来选择Element对象
    >                     ```
    >                     
    >                 * selector语法：参考文档
    >                 
    >             2. XPath语法：专门用于xml查询位置的语言
    >                
    >                 * 因为Jsoup本身不支持XPath，因此我们使用XPath需要额外导入JsoupXpath的jar包，使用这里面的对象。
    >                 
    >                 * 使用步骤：
    >                 
    >                     1、根据Document对象，创建JXDocument对象
    >                     
    >                     2、使用JXDocument对象的方法，结合XPath语法查询
    >                     
    >                      ```
    >                      List<JXNode> selN(参数) -- 根据参数的XPath语法返回list集合
    >                      ```
    > 
## day13
### 1. Tomcat
1. Tomcat
    > 1. 介绍
    > 
    >     web服务器软件。web服务器软件用来部署web项目，承载动态资源，这些动态资源必须运行在web服务器软件中，因此这些软件也被称为web容器
    >     
    > 2. 常见的javaweb服务器软件
    > 
    >     * webLogic：Oracle公司推出；大型JavaEE服务器，支持所有的JavaEE；收费
    >     
    >         * JavaEE：Java在做企业级应用开发时遵循的规范，共有13项大的规范
    >         
    >     * webSphere：IBM公司推出；大型JavaEE服务器，支持所有的JavaEE；收费
    >     
    >     * JBOSS：JBOSS公司推出；大型JavaEE服务器，支持所有的JavaEE；收费
    >     
    >     * Tomcat：Apache基金组织推出；中小型服务器，支持少量的JavaEE规范；开源、免费
    > 3. Tomcat操作
    > 
    >     1. 下载
    >     
    >     2. 安装
    >     
    >        解压压缩包即可，安装目录不能有中文和空格
    >        
    >     3. 卸载
    >     
    >        删除目录
    >        
    >     4. 启动
    >     
    >        ```bin/startup.bat```（Linux下是```bin/startup.sh```）
    >        
    >        **注意，一些NI公司软件会占用8080端口，如Multisim软件。如果404，建议修改配置文件中的端口号为别的**
    >        
    >        **启动可能会产生的问题：**
    >        
    >          **1、窗口一闪而过，原因：JAVA_HOME没配置好**
    >        
    >          **2、启动报错，原因：端口被占用，改个端口或者杀死占用端口的进程**
    >        
    >        **一般会将Tomcat默认端口号修改为80，因为这是HTTP协议的默认端口，改成这个之后访问Tomcat的项目就不用再写端口号了**
    >        
    >     5. 关闭
    >     
    >        ```bin/shutdown.bat```（Linux下是```bin/shutdown.sh```）或者直接Ctrl+c关闭
    >        
    >     6. 配置
    >     
    >         * 部署项目的方式：
    >         
    >            1、直接放到webapps目录下，简化部署：将项目打包成war包，放置到webapps目录下，会自动解压部署。虚拟目录：在浏览器域名之后的目录结构
    >            
    >            2、配置conf/server.xml文件，在文件<host>标签体得空白区域添加如下的标签：```<Context docBase="项目原路径" path="虚拟目录路径，如/Pro1"/>```
    >            
    >            3、由于在server.xml配置可能会损坏该配置文件很不安全，我们需要一个专门用来配置项目的配置文件。在```conf/Catalina/localhost```中自定义一个xml文件，名称任意，添加：```<Context docBase="项目原路径"/> ```，此时虚拟目录就是xml文件名
    >            
    >        * 静态项目和动态项目
    >        
    >            * 目录结构
    >               -- 项目根目录
    >               	-- WEB-INF目录
    >                   	-- web.xml：项目核心配置文件
    >                     	-- Classes目录：项目字节码文件目录
    >                     	-- lib目录：放置依赖jar包
    >        
    >     7. 集成Tomcat进IDEA，创建JavaEE项目并部署项目
    >     
    >        在IDEA中，选择运行-》编辑结构-》default-》Tomcat Server-》configure-》选择Tomcat的安装目录即可
    >        
    >        在IDEA中的选择运行-》编辑结构-》Tomcat中的Deployment中设置虚拟目录名，默认为/，即在url中直接写```域名/资源路径```即可，我们设置需要的虚拟目录名。
    >     
### 2. Servlet
2. Servlet
    > 1. 简介	
    >
    >    JavaWeb三大组件之一。server applet，运行在服务器的小程序。理解成能让Tomcat识别并运行的，遵循了某些规则（Java中规则就是接口，遵循规则就是实现了接口）的Java类，这个接口就是Servlet。将来我们自定义的类实现Servlet接口，复写其中的方法。
    >    
    > 2. 使用步骤
    >
    >     1. 创建JavaEE项目
    >       
    >     2. 定义一个类，实现Servlet的所有方法
    >       
    >     3. 配置Servlet：在web.xml中配置如下代码
    >     
    >         ```
    >         <servlet>
    >             <servlet-name>类名</servlet-name>
    >             <servlet-class>全类名</servlet-class>（注意：配置文件中如果写了全类名，一般是和反射有关）
    >         </servlet>
    >         <servlet-mapping>
    >             <servlet-name>类名</servlet-name>
    >             <url-pattern>资源路径，如/Project1</url-pattern>
    >         </servlet-mapping>
    >         ```
    > 3. Servlet生命周期方法
    >
    >    Servlet中的所有方法如下：
    >    
    >     ```java
    >    public class Demo1 implements Servlet {
    >        /**
    >         * 初始化方法
    >         * 该方法在Servlet对象被创建时执行，且仅执行一次
    >         * @param servletConfig
    >         * @throws ServletException
    >         */
    >        @Override
    >        public void init(ServletConfig servletConfig) throws ServletException {
    >    
    >        }
    >    
    >        /**
    >         * 获取ServletConfig对象
    >         * ServletConfig对象：Servlet的配置对象
    >         * @return
    >         */
    >        @Override
    >        public ServletConfig getServletConfig() {
    >            return null;
    >        }
    >    
    >        /**
    >         * 提供服务方法
    >         * 该方法在每次Servlet被访问时执行，可以执行多次
    >         * @param servletRequest
    >         * @param servletResponse
    >         * @throws ServletException
    >         * @throws IOException
    >         */
    >        @Override
    >        public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {
    >            System.out.println("Hello, World!");
    >        }
    >    
    >        /**
    >         * 获取Servlet的信息，如版本、作者
    >         * @return
    >         */
    >        @Override
    >        public String getServletInfo() {
    >            return null;
    >        }
    >    
    >        /**
    >         * 销毁方法
    >         * 该方法服务器正常关闭时，即在Servlet被杀死时执行，且仅执行一次
    >         */
    >        @Override
    >        public void destroy() {
    >    
    >        }
    >    }
    >     ```
    >    
    >     * 上述中和生命周期相关的三个方法最重要，Servlet的生命周期为：
    >    
    >         1. 被创建：执行init()方法，执行一次
    >         
    >            * 默认情况下是在Servlet被创建时执行init()方法，我们也可以通过修改web.xml来配置Servlet创建时机
    >            
    >                ```xml
    >                <!--配置Servlet-->
    >                    <servlet>
    >                        <servlet-name>Demo1</servlet-name>
    >                        <servlet-class>cn.YUU.Demo1.Demo1</servlet-class>
    >                        <!--指定Servlet创建时机
    >                                <load-on-startup>正数</load-on-startup>：在服务器启动时创建
    >                                <load-on-startup>负数</load-on-startup>：第一次访问时创建，默认值就为-1
    >                        -->
    >                        <load-on-startup>-1</load-on-startup>
    >                    </servlet>
    >                ```
    >                
    >            * Servlet的init()方法只执行一次，说明内存中永远只有一个Servlet对象，Servlet是单例的
    >            
    >                * 多个用户同时访问Servlet可能会出现线程安全问题。但是我们不可以对Servlet的方法加锁，因为这会影响效率。
    >                
    >                * 解决方法：虽然Servlet对象只有一个，但是Service()方法可以多次调用。因此，尽量不要在Servlet中定义成员变量，我们定义局部变量；即使定义了成员变量，也不要去赋值或者修改值，只获取值，这样也就不会有线程安全问题了
    >            
    >         2. 提供服务：执行service()方法，执行多次
    >         
    >            每次访问Servlet都会执行service()方法
    >            
    >         3. 被销毁：执行destroy()方法，执行一次
    >         
    >            服务器关闭时，Servlet被销毁。但是只有服务器正常关闭，Servlet才会销毁。
    >    
    > 4. Servlet3.0
    > 
    >     * 好处：
    >     
    >         1. 支持注解配置
    >         
    >             * 步骤：
    >             
    >                1、创建JavaEE项目，选择Servlet3.0以上版本，可以不创建web.xml
    >                
    >                2、定义一个类实现Servlet接口，复写方法
    >                
    >                3、在类上使用@WebServlet注解进行配置，配置为：```@WebServlet("访问路径，如/Project1")```
    >     
    > 5. Tomcat和IDEA的相关配置
    > 
    >     1. IDEA会为tomcat部署的项目单独建立一份配置文件
    >     
    >     2. “工作空间项目”和“tomcat部署的web项目”
    >     
    >         * “工作空间项目”：IDEA中的项目列表；“tomcat部署的web项目”：在保存项目的物理目录中的out/artifacts目录下
    >         
    >         * tomcat真正访问的是“tomcat部署的web项目”，“tomcat部署的web项目”对应“工作空间项目”的web目录下的所有资源
    >         
    >         * WEB-INF目录下的资源不能被浏览器直接访问
    >         
    >         * tomcat的断点调试：Debug启动
    > 
    > 6. Servlet体系结构
    > 
    >     * Servlet: 
    >     
    >         * GenericServlet: 抽象类。将Servlet的其他方法做了默认空实现，只将service()方法作为抽象。将来定义Servlet类时，可以继承GenericServlet，实现service()方法即可
    >         
    >             * HttpServlet:抽象类。对HTTP的封装。定义类继承HttpServlet，复写doPost()方法或者doGet()方法，以后大多数时间使用这个类
    >     
    > 7. Servlet相关配置配置
    > 
    >     1. urlpartten：Servlet访问路径
    >     
    >         * 一个Servlet可以定义多个访问路径，如：```@WebServlet("/路径1", "/路径2", "/路径3")```  
    >         
    >         * Servlet路径定义规则：
    >         
    >             * /xxx
    >             
    >             * /xxx/xxx （/xx/*表示/xx/任意）
    >             
    >             * \*.do （*是通配符，在url中表示任意）
    >     
    > 8. Servlet默认在第一次被访问时被加载，不是服务器启动时
## day14
### 1. HTTP及请求消息
1. HTTP及请求消息
    > 1. 简介
    >
    >    超文本传输协议。
    >    
    >     * 传输协议：定义了客户端和服务器端发送数据的格式
    >    
    > 2. 特点
    >
    >     1. 是基于TCP/IP的高级协议
    >     
    >     2. 默认端口号是80
    >     
    >     3. 基于请求/响应模型：一次请求对应一次响应
    >     
    >     4. 无状态协议：每次的请求相互独立，不会交互数据	
    >     
    > 3. 历史版本
    >
    >     * 1.0：每次响应建立新连接
    >     
    >     * 1.1：可以复用旧连接
    > 
### 2. Http协议：请求消息
2. Http协议：请求消息
    > 1. 请求消息数据格式   
    >     1. 请求行
    >     
    >        请求方式 请求url 请求协议/版本
    >            
    >         * 请求方式：HTTP协议有7种方式，常用的有GET和POST两种
    >           
    >             * GET：
    >               
    >                1、请求参数在请求行中，在url后
    >                    
    >                2、url长度有限
    >                    
    >                3、不太安全
    >                
    >             * POST：
    >               
    >                1、请求参数在请求体中
    >                    
    >                2、url长度不限
    >                    
    >                3、相对安全
    >        
    >     2. 请求头
    >     
    >        请求头名称: 请求头的值[, 请求头的值[, ...]]
    >            
    >         * 常见的请求头：
    >           
    >             1. User-Agent: 浏览器告诉服务器，我访问你使用的浏览器版本信息。
    >             
    >                  * 作用：
    >                    
    >                     在服务器端获取请求头然后知道浏览器版本信息，解决兼容性问题
    >                 
    >             2. Referer：告诉服务器，当前请求从何处来
    >                
    >                 * 作用：
    >                   
    >                    1、防盗链，防止盗取链接
    >                        
    >                    2、统计工作
    >        
    >     3. 请求空行
    >     
    >        空行
    >            
    >        
    >         * 用于分隔POSt请求的请求头和请求体
    >        
    >     4. 请求体（请求正文）
    >     
    >        参数名=参数值
    >            
    >        
    >         * 用来封装POST请求的正文，GET请求没有请求体
    >     
    > 2. 请求消息数据格式的字符串表示
    >    
    >     ```
    >     请求方式 请求url 请求协议/版本
    >     请求头名称: 请求头的值[, 请求头的值[, ...]]
    >     请求头名称: 请求头的值[, 请求头的值[, ...]]
    >     请求头名称: 请求头的值[, 请求头的值[, ...]]
    >         
    >     参数名=参数值
    >     ```
    >     
### 2. Request
2. Request
    > 1. Request对象和Response对象的原理
    >
    >     * 当在浏览器输入url并按下回车后：
    >     
    >        1、tomcat服务器根据请求url的资源路径创建对应的Servlet实现类的对象
    >       
    >        2、tomcat服务器创建Request对象和Response对象，Request对象封装请求消息数据
    >       
    >        3、tomcat服务器将Request对象和Response对象传递给service()方法，执行service()方法
    >       
    >        4、我们程序员可以在service()方法中通过Request对象获取请求消息，并通过Response对象设置响应消息
    >       
    >        5、服务器从Response对象中获取设置的响应消息，封装到响应中
    >       
    >        6、服务器给浏览器回复响应，响应携带响应消息
    >        
    >     * Request对象和Response对象我们只是使用它们；Request对象用来获取请求消息，Response对象用来设置响应消息
    >     
    > 2. Request对象继承体系结构
    >
    >     * ServletRequest：接口
    >     
    >         * HttpRequest：接口
    >         
    >             * org.apache.catalina.connector.RequestFacade：由Tomcat实现的HttpRequest实现类
    >     
    > 3. Request功能
    >
    >     1. 获取请求消息数据
    >     
    >         * 获取请求行数据
    >         
    >             ```
    >             String getMethod() -- 获取请求方式
    >             ```
    >             
    >             ```
    >             String getContextPath() -- 获取虚拟目录。很重要，用到机会多
    >             ```
    >             
    >             ```
    >             String getServletPath() -- 获取Servlet路径
    >             ```
    >             
    >             ```
    >             String getQueryString() -- 获取GET方式传输时的参数
    >             ```
    >             
    >             ```
    >             String getRequestURI() -- 获取URI。URI就是"虚拟目录/访问路径"。很重要，用到机会多
    >             ```
    >             
    >             ```
    >             String getRequestURL() -- 获取URL。URL就是"协议://主机地址/虚拟目录/访问路径"
    >             ```
    >             
    >             ```
    >             String getProtocol() -- 获取协议及版本号
    >             ```
    >             
    >             ```
    >             String getRemoteAddr() -- 获取客户机IP地址
    >             ```
    >             
    >             * URI和URL区别：
    >             
    >                 * URI：统一资源标识符。代表范围更大
    >                 
    >                 * URL：统一资源定位符。代表范围小
    >             
    >         * 获取请求头数据
    >         
    >             ```
    >             String getHeader(String name) -- 根据请求头名称返回值。很重要，后期使用次数最多
    >             ```
    >             
    >             ```
    >             Enumeration<String> getHeaderNames() -- 获取所有请求头名称。Enumeration类似于Iterator接口，可以看做Iterator接口，同时它的方法也和Iterator接口一样
    >             ```
    >             
    >         * 获取请求体数据
    >         
    >             * 只有POST方式才有请求体，请求体中封装了POST请求的请求数据
    >             
    >             * 步骤：
    >             
    >                 1. 获取流对象
    >                     ```
    >                     BufferedReader getReader() -- 获取字符输入流，只能操作字符数据
    >                     ```
    >                     
    >                     ```
    >                     ServletInputStream getInputStream() -- 获取字节输入流，能操作所有数据
    >                     ```
    >                     
    >                 2. 从流对象中获取数据
    >         
    >     2. 其他功能（所有方法都很常用，都很重要）
    >     
    >         * 获取请求参数：通用的方式
    >         
    >             ```
    >             String getParameter(String name) -- 根据参数名称获取参数值
    >             ```
    >             
    >             ```
    >             String[] getParameterValues(String name) -- 根据参数名称获取参数值的数组。该方法多用于复选框
    >             ```
    >             
    >             ```
    >             Enumeration<String> getParameterNames() -- 获取所有请求的参数名称
    >             ```
    >             
    >             ```
    >             Map<String, String[]> getParameterMap() -- 获取所有参数的键值对集合
    >             ```
    >             
    >             * **中文乱码问题**：
    >             
    >                Tomcat8已经将GET方式提交的中文乱码，POST方式解决：获取参数之前设置Request对象的编码方式```request.setCharacterEncoding("utf-8")```
    >             
    >         * 请求转发：一种在服务器内部的资源跳转方式，如从AServelt跳转套BServlet
    >             * 步骤：
    >                 1. 通过Request对象获取请求转发器对象
    >                 
    >                     ```
    >                     RequestDispatcher getRequestDispatcher(String path) -- 获取跳转到某个path的RequestDispatcher对象。path：访问路径，Servlet中是@WebServlet("访问路径")
    >                     ```
    >                     
    >                 2. 使用RequestDispatcher对象进行转发
    >                 
    >                     ```
    >                     forward(ServletRequest request, ServletResponse response) -- 将这个Servlet的Request对象和Response对象转发给另一个Servlet
    >                     ```
    >                     
    >                 3. 上述步骤通常用链式编程
    >                 
    >             * 特点：
    >             
    >                 1. 浏览器的地址栏路径不变
    >                 
    >                 2. 只能转发到当前服务器内部资源中
    >                 
    >                 3. 转发只有一次请求，即多个资源使用同一个Request对象
    >             
    >         * 共享数据
    >         
    >             * 域对象：一个有作用范围的对象，可以在范围内共享数据，ServletRequest对象就是一个域对象
    >             
    >             * request域：代表一次请求的范围，一般request域用于请求转发的多个资源来共享数据
    >             
    >             * 方法：
    >             
    >                 ```
    >                 void setAttribute(String name, Object obj) -- 存储数据在request对象中
    >                 ```
    >                 
    >                 ```
    >                 Object getAttribute(String name) -- 通过名获取值
    >                 ```
    >                 
    >                 ```
    >                 void removeAttribute(String name) -- 通过名移除值
    >                 ```
    >           
    >         * 获取ServletContext对象
    >         
    >             ```
    >             ServletContext getServletContext() -- 获取ServletContext对象
    >             ```
    >             
### 3. BeanUtils工具类
3. BeanUtils
    > 1. 介绍
    > 
    >    用来简化封装JavaBean的工具类，开源的。
    >    
    > 2. 使用
    > 
    >     1. 导入jar包
    >     
    >     2. 获取请求参数的Map对象，getParameterMap()
    >     
    >     3. new空的JavaBean对象
    >     
    >     4. 使用BeanUtils.populate(JavaBean对象, 请求参数的Map集合对象)
    > 3. JavaBean:标准的Java类
    > 
    >     * JavaBean有以下特点：
    >     
    >        1、必须被public修饰
    >       
    >        2、必须提供空参构造
    >       
    >        3、成员变量被private修饰
    >       
    >        4、提供公共的setter和getter方法
    >        
    >     * 功能：封装数据
    >     
    >     * 概念：
    >     
    >        1、成员变量
    >        
    >        2、属性：setter和getter截取后的产物，如```getUername() -> Username -> username，username就是属性```，一般情况和成员变量一样
    >     
    > 4. 方法
    > 
    >     ```
    >     setProperty(Object javaBean, String propertyName, Object value) -- 根据JavaBean对象的属性名来设置属性值
    >     ```
    >     
    >     ```
    >     getProperty(Object javaBean, String name, Object value) -- 根据JavaBean对象的属性名来设置属性值
    >     ```
    >     
    >     ```
    >     populate(Object javaBean, Map parameterMap) -- 将Map集合的键值对信息封装到JavaBean
    >     ```
    >     
## day15
### 1. Http协议：响应消息
1. Http协议：响应消息
    > 1. 概述
    > 
    >    服务器端发送给服务器端的消息
    >    
    > 2. 响应消息格式
    > 
    >     1. 响应行
    >     
    >         * 组成：```协议/版本 状态码 状态码描述```
    >         
    >         * 响应状态码：服务器告诉客户端的响应状态，全部都是3位数字
    >         
    >             * 分类：从100~599，分为5类
    >             
    >                1xx -- 服务器接收客户端消息，但是没接收完成，等待一段时间后，发送1xx状态码
    >                
    >                2xx -- 成功，最常见：200
    >                
    >                3xx -- 重定向，最常见的：302。客户端请求服务器某个资源，服务器发送响应告诉浏览器服务器其他资源的路径。特殊：304，访问缓存，客户端请求服务器的资源在客户端有缓存后（如图片资源），下一次请求该资源，服务器发送该状态码，告诉客户端去找客户端的缓存。 
    >                
    >                4xx -- 客户端错误。常见：404（客户端请求路径没有资源），405（请求方式没有对应的doGet()或doPost()方法）
    >                
    >                5xx -- 服务器端错误。常见：500（服务器端出现异常）
    >         
    >     2. 响应头
    >     
    >         * 格式：```头名称: 值```
    >         
    >         * 常见的响应头：
    >         
    >            1、Content-Type：服务器告诉客户端本次响应响应体的格式和编码格式 
    >            
    >            2、Content-disposition：服务器告诉客户端以何种格式打开响应体数据。默认：in-line -- 在当前页面内打开；attachment;filename=xxx -- 以附件形式打开响应体。文件下载使用这个，其中xxx为下载提示框中的名字
    >            
    >            3、Location：重定向配合使用，新的资源路径
    >        
    >     3. 响应空行
    >     
    >     4. 响应体
    >     
    >        传输的数据
    >     
### 2. Response对象
2. Response对象
    > 1. 功能
    >
    >    设置响应消息，包括响应头、响应行、响应体
    >    
    > 2. 设置响应行
    >
    >     * 状态码设置：
    >         ```
    >         setStatus(int sc) -- 设置响应行的状态码
    >         ```
    >     
    > 3. 设置响应头
    >
    >     ```
    >     setHeader(String name, String value) -- 设置响应头
    >     ```
    >     
    >     * **在设置Context-disposition时，可能会遇到的问题：**
    >     
    >        在设置它的值为attachment;filename=xxx时，如果filename为中文，浏览器会无法解析中文字符，因此我们需要下列操作：
    >        
    >        1、获取请求头中的浏览器版本信息：```request.getHeader("user-agent")```
    >        
    >        2、将下载的工具类导入utils包中
    >        
    >        3、使用下载的工具类中的方法编码文件名
    >        
    >        4、将编码后的文件名作为filename的文件名
    >     
    > 4. 设置响应体
    >
    >    通过流的方式设置.
    >    
    >     * 获取流：Response对象获取的输出流会自动关闭销毁，不用手动操作
    >    
    >         ```
    >         ServletOutputStream getOutputStream() -- 获取字节输出流
    >         ```
    >         
    >         ```
    >         PrintWriter getWriter() -- 获取字符输出流
    >         ```
    >    
    > 5. 简单的重定向
    >
    >     ```
    >     sendRedirect(String path) -- 重定向新资源路
    >     ```
    >     
    >     * 重定向和转发的区别：
    >     
    >         * 转发（forward）特点：
    >         
    >            1、地址栏路径不变
    >            
    >            2、只能访问本服务器下的资源
    >            
    >            3、转发是一次请求。因此我们可以使用Request对象共享数据
    >            
    >            4、转发时地址是绝对地址而且给服务器使用，因此不用加项目的虚拟目录
    >            
    >         * 重定向（redirect）特点：
    >         
    >            1、地址栏变化
    >            
    >            2、可以访问其他站点资源
    >            
    >            3、是两次请求。因此不可以使用Request对象共享数据
    >            
    >            4、重定向地址地址是绝对地址而且给客户端使用，因此必须加项目的虚拟目录
    >     * 虚拟目录的书写：虚拟目录不允许写死，必须动态获取，使用```request.getContextPath()```来获取虚拟目录  
    >     
    > 6. Response响应数据步骤
    >
    >    1、设置响应行：设置状态，如要重定向直接用Response提供的简单重定向
    >    
    >    2、设置响应头：设置Context-Type，如要让浏览器下载数据还要设置Content-disposition
    >    
    >    3、设置响应体
    >    
    > 7. 使用Response响应普通文本数据的步骤（主要是用来解决中文乱码）
    >
    >    1、在获取流对象之前设置流对象的编码方式
    >    
    >    ```response.setContentType("text/html;charset=utf-8");```
    >    
    >    2、在输出数据前告诉浏览器响应体格式和编码
    >    
    >     * **Response提供简单的方式来完成上述的步骤：```response.setContextType("text/html;character=utf-8")```**
    >    
    >    3、使用流对象设置响应体
### 3. ServletContext对象
3. ServletContext对象
    > 1. 概念：
    > 
    >    代表了整个web应用，可以和Servlet容器通信，是域对象。在服务器开启后自动创建，在服务器正常关闭后自动销毁
    >    
    > 2. 获取
    > 
    >    1、通过Request对象的方法获取：```request.getServletContext()```
    >    
    >    2、通过本HttpServlet的方法获取：```this.getServletContext()```
    >    
    > 3. 功能
    > 
    >     1. 获取MIME类型
    >     
    >         * MIME类型：互联网通信过程中的一种文件类型标准，格式：大类型/小类型
    >         
    >         ```
    >         String getMimeType(String file) -- 根据文件名获取文件的MIME类型，具体原理：通过文件后缀名来获取文件的MIME类型
    >         ```
    >     
    >     2. 身为域对象，可以共享数据。ServletContext对象范围最大，可以共享所有用户的数据。该对象生命周期为服务器的开启到关闭，周期很长，而且保存所有用户数据，既不安全而且占内存，因此使用它要特别谨慎
    >     
    >         ```
    >         setAttribute()
    >         ```
    >         
    >         ```
    >         getAttribute()
    >         ```
    >         
    >         ```
    >         removeAttribute()
    >         ```
    >     
    >     3. 获取文件的真实路径（服务器路径）：我们以后的项目是放到远程服务器的，因此如果要加载某些文件，我们不可能写项目路径，必须写服务器路径。如创建File类，以后就用服务器路径。它相对于ClassLoader好处是ClassLoader只能加载src目录下的文件
    >     
    >         ```
    >         getRealPath(String path) -- 获取文件的真实路径。path写法：/代表项目中的web目录，/WEB-INF代表项目中的web/WEB-INF目录，/WEB-INF/classes代表项目中的src目录，根据这个写path
    >         ```
    >         
## day15 
### 1. 会话技术
1. 会话技术
    > 1. 会话概述
    > 
    >    一次会话包含了多次的请求和多次的响应。一次会话的生命周期：浏览器第一次向服务器发送请求时建立，一方断开连接时终止。
    >    
    > 2. 会话功能
    > 
    >    在一次会话的范围内的多次请求间共享数据。
    >    
    > 3. 方式
    > 
    >     * 客户端会话技术：Cookie
    >     
    >     * 服务器端会话技术：Session
    >     
### 2. Cookie
2. Cookie
    > 1. 概念
    > 
    >    客户端会话技术。将数据保存到客户端。
    >    
    > 2. 使用步骤
    > 
    >    1、创建Cookie对象：```Cookie cookie = new Cookie(String name, String value);```
    >    
    >    2、通过响应把Cookie对象返回给客户端保存：```response.addCookie(Cookie cookie)```
    >    
    >    3、获取下一次的请求携带的Cookie们：```Cookie[] request.getCookies() -- 由于cookie可以有多个，所以获取的是Cookie数组```
    >    
    > 3. **题外话：修改Servlet模板：**
    > 
    >    在IDEA中的setting搜索code template，对其中的other中的web下的Java code template中的Servlet Annotated Class进行修改
    >    
    > 4. 原理
    > 
    >    本质上还是通过Http协议的请求和响应来完成。
    >    
    >    响应把Cookie对象中的cookie信息写在一个响应头中且响应头数据为键值对的cookie信息```set-cookie:name=value``` 
    >    
    >    客户端接收到响应，解析到```set-cookie:name=value```时，会自动将cookie信息保存
    >    
    >    下一次客户端发送请求，cookie信息被写进请求头中且请求头数据为键值对```cookie:name=value```
    >    
    >    服务器端接收到请求，解析到```cookie:name=value```，通过Cookie相关API就拿到了cookie信息
    >    
    > 5. cookie细节
    > 
    >     1. 一次是否可以发送多个cookie
    >     
    >        可以，创建多个Cookie对象调用多次```response.addCookie()```即可。发送多个cookie响应头中响应头数据会按,隔开：```set-cookie:name1-value1,name2=value2,...```
    >        
    >     2. 客户端保存cookie的时间
    >     
    >        默认情况下，浏览器关闭cookie销毁
    >        
    >         * 持久化存储cookie：在Cookie对象中有一个方法可以设置cookie的生命周期
    >             ```
    >             setMaxAge(int seconds) -- 根据参数的不同，设置不同的生命周期。参数取值：1.正数 -- 将cookie存储到硬盘文件中，即持久化存储；还代表了cookie的存活秒数，到时间cookie文件被自动删除 2.负数 -- 默认值。代表浏览器关闭cookie被销毁 3.0 -- 删除该cookie信息
    >             ```
    >        
    >     3. cookie是否可以保存中文
    >     
    >        Tomcat8之前不允许存储中文数据，要先将中文编码，一般采用URL编码
    >        
    >        Tomcat8之后支持存储中文数据
    >        
    >     4. cookie获取范围多大
    >     
    >         * 如果一个服务器部署了多个web项目，这些项目的cookie能否共享？
    >         
    >            默认情况下cookie无法共享。
    >           
    >            但是在Cookie对象中，有个方法可以设置cookie的共享范围
    >           
    >             ```
    >             setPath(String path) -- 设置cookie共享范围。默认情况下，不调用此方法，相当于调用了该方法设置path为当前项目的虚拟目录，即默认情况共享范围为当前项目。如果想多个项目共享cookie数据，则需要设置path为更高级别目录，如/（根目录）
    >             ```
    >            
    >         * 多个服务器之间cookie如果想共享数据怎么办？
    >         
    >            已知默认情况cookie无法共享，所以我们只能调用Cookie对象中的方法：
    >            
    >             ```
    >             setDomain(String path) -- 设置cookie的域名。如果设置一级域名相同，则多个服务器可以共享cookie
    >             ```
    >     5. cookie不支持特殊字符，如空格等，因此如果cookie想存储含有特殊字符的值，需要先进行编码，一般是URL编码，然后存储到cookie；之后拿到cookie后对数据解码即可：
    >     
    >        使用Java提供的URLEncoder类中的静态方法来编码：
    >        
    >         ```
    >         static encode(String value, String enc) -- 对一个字符串使用指定字符集来编码
    >         ```
    >        
    >        使用Java提供的URLEncoder类中的静态方法来解码：
    >        
    >         ```
    >         static decode(String value, String enc) -- 对一个编码了的字符串用指定字符集解码
    >         ```
    >     
    > 6. cookie特点和作用
    > 
    >     * 特点：
    >     
    >        1、cookie存储在客户端。客户端存在的数据不安全
    >        
    >        2、浏览器对单个cookie大小限制为4kb左右，同时浏览器限制同一个域名下的cookie数量为20个以内
    >        
    >     * 作用
    >     
    >        1、一般用于存储少量不太敏感的数据
    >        
    >        2、在不登录的情况下完成服务器对客户端的身份识别
    >     
### 3. Session
3. Session
    > 1. 概念
    > 
    >    服务器端会话技术，将数据保存到服务器端的对象中。
    >    
    > 2. 原理
    > 
    >    **Session是依赖于Cookie的。**第一次获取Session，如果没有Cookie：则在内存中创建一个新的Session对象，并且其有唯一的id；之后服务器端回馈响应，响应头中写入```set-cookie:JSESSIONID=服务器端创建的Session对象的id```，客户端将这个JSESSIONID的信息写入cookie。之后获取session，如果请求中有cookie信息：在服务器中查找跟cookie信息中JSESSIONID相同的Session对象，有则使用那个对象。因此只要会话不结束，Session对象都是相同的  
    >    
    > 3. HttpSession
    >     1. 概念
    >     
    >        域对象
    >        
    >     2. 获取
    >     
    >        通过```request.getSession()```方法来获取
    >        
    >     3. 方法
    >     
    >         ```
    >         getAttribute(String name) -- 通过名称获取值
    >         ```
    >         
    >         ```
    >         setAttribute(String name, Object value) -- 设置属性
    >         ```
    >         
    >         ```
    >         removeAttribute(String name) -- 删除属性
    >         ```
    >         
    >         ```
    >         getId() -- 获取Sessionid
    >         ```
    >     
    > 4. Session细节
    > 
    >     1. 当客户端关闭后，服务器端不关闭，重新打开客户端访问服务器，两次获取的Session是同一个吗？
    >     
    >        默认情况下不是。
    >        
    >         * 已知Session是依赖于Cookie的，根据上述原理，如果想在客户端关闭而服务器端不关闭后，客户端再次访问获取到同样的Session，我们可以把JSESSIONID作为键，sessionid作为值保存到cookie中：
    >        
    >             ```
    >             Cookie cookie = new Cookie("JSESSIONID", session.getId());
    >             cookie.setMaxAge(想要保存的秒数);
    >             response.addCookie(cookie);
    >             ```
    >        
    >     2. 客户端不关闭，服务器端关闭，两次获取的Session是同一个吗？
    >     
    >        不是同一个。但是我们必须确保Session对象中保存的数据不丢失
    >        
    >         * session的钝化
    >        
    >            在服务器正常关闭前，将Session对象序列化到硬盘中存储
    >            
    >         * session的活化
    >        
    >            在服务器开启后，将序列化的Session对象反序列化到内存中
    >            
    >         * 当我们项目部署到web服务器如Tomcat中后，Tomcat会自动帮我们进行钝化和活化，钝化后的序列化(.ser)文件存在于work目录下的项目目录中。但是IDEA下部署的项目无法完成活化
    >        
    >     3. Session的被销毁的时间是？
    >     
    >        1、服务器关闭 2、Session对象调用```session.invalidate()``` 3、Session默认失效时间为30分钟。Session的默认失效时间可以通过改变配置文件来改变，如Tomcat的conf目录下的web.xml配置中就有关于session默认失效时间的配置
    >     
    > 5. Session特点
    > 
    >    1、Session是用于存储一次会话多次请求的数据存在于服务器
    >    
    >    2、可存储任意类型，任意大小的数据
    >    
    >    3、Session对象也是域对象。如果我们进行重定向操作，重定向的两次请求想要共享数据我们一般会选择Session对象而非ServletContext对象
    >    
    > 6. Session与Cookie的区别
    > 
    >    1、Session存数据在服务器端，Cookie存数据在客户端
    >    
    >    2、Session没有数据大小限制，Cookie只能存小于4kb的数据
    >    
    >    3、Session相较于Cookie安全
    >    
### 4. JSP
4. JSP
    > 1. 概念
    > 
    >    Java Server Pages，Java服务器端界面，可以指定html标签，又可以定义Java代码。用于简化书写
    >    
    > 2. 原理
    > 
    >    客户端访问.jsp文件，在服务器端：.jsp文件 -> .java文件 -> .class字节码文件，因此可以看出来客户端访问JSP相当于访问了一个Java类，而只有Servlet类可以被外界访问，因此JSP本质上就是Servlet。同时，jsp转化的.java和.class文件存在于work目录的项目目录中
    >    
    >    通过查看jsp文件生成的java文件可以看到，jsp继承了HttpJspBase类，这个类是apache提供的，HttpJspBase类实现了HTTPServlet接口，因此jsp实质就是Servlet。我们在jsp中写的html标签，在jsp生成的java文件的Servlet中，都会通过流自动输出这些html标签到页面，因此简化了操作。
    >    
    > 3. JSP脚本
    > 
    >     1. 介绍
    >     
    >        在jsp文件中，JSP定义java代码的方式
    >        
    >     2. 定义方式
    >     
    >         * 方式1：该脚本定义的java代码，最终会转换在service()方法中。service()可以定义该脚本可以定义什么
    >         
    >             ```
    >             <%
    >                 java代码
    >             %>
    >             ```
    >             
    >         * 方式2：该脚本定义的java代码，最终会转换为成员变量或成员方法。这种方法很少用，因为之前说过在Servlet中尽量不要定义成员变量，易引发线程安全问题
    >         
    >             ```
    >             <%!
    >                 java代码
    >             %>
    >             ```
    >             
    >         * 方式3：该脚本相当于输出语句，会把内部的数据输出到页面，对于变量等采取就近原则获取，即先获取方式1中定义的service()中的变量，然后找方式2中的。输出语句可以定义什么，这里可以写什么
    >         
    >             ```
    >             <%=
    >                 java代码
    >             %>
    >             ```
    >     
    > 4. JSP内置
    > 
    >     1. 概念
    >     
    >        在jsp文件页面，不用创建和获取就可以直接使用的对象。
    >        
    >     2. 指令
    >     
    >         1. 作用
    >         
    >            用于配置JSP和导入资源文件
    >            
    >         2. 格式
    >         
    >             ```
    >             <%@ 指令名称 属性名1=属性值1 属性名2=属性值2 ... %>
    >             ```
    >             
    >         3. 指令名称分类
    >         
    >             * page:配置JSP页面。
    >             
    >                 * 常见属性：
    >                 
    >                     1. contentType -- 相当于response.setContentType()。作用：1.设置响应消息体的MIME类型和字符集；2.设置当前JSP页面的编码（只能是高级开发工具才可以生效，如IDEA）
    >                     
    >                     2. language -- 只支持java
    >                     
    >                     3. import -- java类的导包
    >                     
    >                     4. errorPage -- 错误页面。当前页面发生错误后会主动跳转到错误页面。属性值："标记的错误页面名.jsp"
    >                     
    >                     5. isErrorPage -- 标记当前页面为错误页面。属性值："true"。当使用该属性值且设置为true，我们就可以在jsp脚本中使用exception对象，使用exception对象中的方法获取错误信息，然后将错误信息写入日志
    >                 
    >             * include（很少用到）:页面包含的。
    >             
    >             * taglib:导入资源。我们一般用来导入标签库
    >             
    >                 * 属性：
    >                 
    >                      1. prefix --  前缀，自定义
    >                        
    >                      2. uri -- 资源地址
    >         
    >     3. jsp注释
    >     
    >         1. 格式
    >         
    >             ```
    >             <%-- 注释内容 --%>
    >             ```
    >             
    >         2. 好处
    >         
    >            和html注释相比，html注释只能注释html的部分，jsp注释可以注释jsp界面的任意内容
    >         
    >     4. JSP内置对象
    >     
    >         1. 概念
    >         
    >            jsp已经写好了的，直接使用即可的对象
    >            
    >         2. 九大内置对象
    >         
    >             1. 域对象：主要用来共享数据
    >             
    >                 * pageContext: 真实类型：PageContext。
    >                 
    >                    作用：1.当前页面共享数据；2.获取其他八个对象，通过```pageContext.属性```，属性为其他对象名，来获取
    >                 
    >                 * request: 真实类型：HttpServletRequest。
    >                 
    >                    作用：一次请求多次转发的多个资源之间共享数据
    >                 
    >                 * session: 真实类型：HttpSession。
    >                 
    >                    作用一次会话的多个请求间共享数据
    >                 
    >                 * application: 真实类型：ServletContext。
    >                 
    >                    作用：所有用户间共享数据
    >                 
    >             2. 其他对象
    >             
    >                 * response: 真实类型：HttpServletResponse。响应对象
    >                 
    >                 * page：真实类型：Object。当前的Servlet，
    >                 
    >                 * out: 真实类型：JSPWriter字符输出流对象。类似于response.write()，但是还是有区别：response.write()输出永远是最先的，而out定义在哪里就在哪里输出，因此我们以后尽量都使用out输出
    >                 
    >                 * config: 真实类型：ServletConfig。Servlet的配置对象
    >                 
    >                 * exception: 真实类型：Throwable。异常对象
    >         
## day16
### 1. MVC开发模式
1. MVC开发模式
    > 1. 概念
    > 
    >    一种典型的开发模式。将一个软件分为：Model层，View层，Controller层
    >    
    >     * Model层
    > 
    >         * 使用JavaBean来充当
    >    
    >         * 功能：业务逻辑操作，如查询数据库、封装数据
    >    
    >     * View层：使用
    > 
    >         * 使用JSP充当
    >    
    >         * 功能：展示数据
    >    
    >     * Controller层
    > 
    >         * 使用Servlet来充当
    >    
    >         * 功能：1.获取客户端输入；2.调用模型；3.将返回的数据交给View层
    >    
    > 2. 优缺点：
    > 
    >    优点：代码耦合性低；重用性高
    >    
    >    缺点：需要精心的设置，项目结构变的复杂，不适合小型的程序
    >
### 2. EL表达式
2. EL表达式
    >
    > 1. 概念
    >
    >    表达式语言，可以简化jsp页面Java代码
    >    
    > 2. 语法
    > 
    >     ```
    >     ${表达式}
    >     ```
    >     
    > 3. 注意
    > 
    >     * jsp默认支持EL表达式。如果不想要EL表达式被解析，可以用以下方式：
    >     
    >         1. 在JSP的page指令中写入一个属性：isELIgnored="true"即可，这样页面所有的EL表达式都不被解析
    >         
    >         2. \\${表达式}，此方法写的EL表达式不被解析
    >     
    > 4. EL表达式的功能
    >    
    >     1. 做运算
    >     
    >         * EL表达式的运算符：
    >         
    >             1. 算术运算符：+、-、*、/(div)、%(mod)
    >             
    >             2. 比较运算符：\>、<、=、\>=、<=、==
    >             
    >             3. 逻辑运算符：&&(and)、||(or)
    >             
    >             4. 空运算符(empty)：使用格式empty 对象
    >                
    >                功能：判断字符串对象、集合对象、数组对象是否为null且长度是否为0，是返回true，否返回false。
    >                
    >                **```${not empty 对象}```：判断一个对象是否不为空且长度不为0，是返回true，否返回false。这是我们最常用的empty运算符使用方式**
    >         
    >     2. 获取值
    >     
    >         1. **EL表达式只能从域对象中获取值，如果获取不到，返回空字符串""**
    >         
    >         2. 两种获取值的语法
    >         
    >             1. 方法1
    >             
    >                 ```
    >                 ${域名称.键名} -- 从某个域对象中获取值
    >                 ```
    >             
    >                 * 域名称
    >             
    >                     1. pageScope：对应pageContext对象
    >                 
    >                     2. requestScope：对应request对象
    >                 
    >                     3. sessionScope：对应session对象
    >                 
    >                     4. applicationScope：对应application(ServletContext)对象
    >                 
    >             2. 方法2
    >             
    >                 ```
    >                 ${键名} -- 依次从最小的域开始获取指定键名的值直到找到为止
    >                 ```
    >             
    >         3. 如果域对象中存储了对象、集合等，如何获取它们的值
    >         
    >             1. 对象
    >                
    >                通过对象的属性来获取，一般对象的属性和成员变量同名，如：```${域对象.键名.属性名}```。同理可知，如果我们想得到一些经过处理的数据，如经过格式化的Date对象，我们可以将Date定义成成员变量，然后定义一个getXxx()方法用来格式化Date对象，之后我们想要获取格式化的Date对象，只需要直接${对象名.键名.xxx}即可。
    >               
    >                 * **逻辑视图：如果一个JavaBean中的getXxx()方法没有对应的成员变量，我们称这种方法为逻辑视图，这个方法只是为某个属性提供某个效果**
    >                
    >             2. List集合
    >             
    >                通过```${域名城.键名[索引值]}```来获取集合中的值，同时，EL表达式对索引越界的显示做了优化，在EL表达式中如果索引越界，不会直接在页面打印异常
    >                
    >             3. Map集合
    >             
    >                通过```${域名城.键名[键名]}```或```${域名城.键名.键名}```俩获取集合中的值
    >     
    > 5. 隐式对象
    > 
    >     1. 概念
    >     
    >        类似于JSP中的request对象等，直接使用的对象，像之前的域名称就是其中一种。
    >     2. 最为主要的隐式对象
    >     
    >         * pageContext
    >         
    >            功能：获取jsp的其他八个内置对象，通过```pageContext.属性名```获取，这里的属性名是其他八个内置对象的名称
    >            
    >             * **最常用的隐式对象的用法：在jsp中动态获取虚拟目录，从而完成路径的编写**
    >            
    >                 由于request对象中有个getContextPath()方法可以获取虚拟目录，因此在EL表达式中通过获取request对象来获取虚拟目录：```pageContext.request.contextPath```
    > 
### 3. JSTL标签
3. JSTL标签
    > 1. 概念
    > 
    >     JavaServer Pages Tag Library, JSP标准标签库。是由Apache基金组织提供的开源的免费jsp标签
    >     
    > 2. 作用
    > 
    >    用于简化或者替换jsp页面的Java代码
    >    
    > 3. 使用步骤
    > 
    >    1、导入jar包
    >    
    >    2、在jsp页面通过taglib指令引入标签库：```<%@ taglib prefix="c" url="xxx/xxx/xxx" %>```，一般前缀都叫c 
    >    
    >    3、使用标签
    >    
    > 4. 常用标签
    > 
    >     * if：相当于Java的if语句
    >     
    >        语法：```<c:if test="接收boolean值，如果为true显示标签体内容，为false不显示标签体内容">标签体内容</c:if>```。
    >        
    >        一般情况下test属性结合EL表达式使用
    >     
    >     * choose：相当于Java的switch语句
    >     
    >        语法：
    >        
    >         ```
    >         <c:choose>
    >         	<c:when test="情况1">内容1</c:when>
    >         	<c:when test="情况2">内容2</c:when>
    >         	<c:when test="情况3">内容3</c:when>
    >         	<c:otherwise>默认内容</c:otherwise>
    >         </c:choose>
    >         ```
    >        
    >        其中：choose相当于switch语句主体，when标签相当于case，when中的test属性就是switch出现的情况，otherwise标签相当于default
    >     
    >     * foreach：相当于Java的foreach语句
    >     
    >         * 完成重复的工作，作为Java中普通for()语句
    >           
    >             ```
    >             <c:foreach 属性="属性值"></c:foreach>
    >             ```
    >             
    >             * 属性：
    >             
    >                 begin:开始的值，包含它自己
    >                 
    >                 end:结束的值，包含它自己
    >                 
    >                 var:临时变量名
    >                 
    >                 step:步长
    >                 
    >                 varStatus:循环状态对象名。循环状态对象有两个成员变量，假设循环状态对象为s：```s.index -- 容器中元素的索引```，```s.count -- 循环的次数，从1开始```
    >             
    >         * 遍历容器
    >         
    >             ```
    >             <c:foreach 属性="属性值"></c:foreach>
    >             ```
    >             
    >             * 属性：
    >             
    >                item:容器对象
    >                
    >                var:容器中元素的临时变量
    >                
    >                varStatus:同上
    >     
    > 
### 4. 三层架构
4. 三层架构
    > 1. 概念
    > 
    >    是一种软件设计的架构，将一个软件分为3个层面
    >    
    > 2. 三层
    > 
    >     * 界面层（表示层/web层）
    > 
    >        用户所看的界面。用户可以通过界面上的组件和服务器进行交互	
    >        
    >        web层由Servlet和JSP组成，接收用户参数，封装数据，调用业务逻辑层完成处理，转发到jsp页面完成数据显示。web层遵循MVC开发模式
    >        
    >     *  业务逻辑层（service层）
    >     
    >        处理具体的业务逻辑（也叫功能）。组成dao层的简单方法，形成复杂的功能。一般Service层的类和数据库中数据表保持一致
    >        
    >     * 数据访问层（dao层，Data Access Object）
    >     
    >        访问数据库，操作指定的数据。定义的都是最基本的CRUD操作。一般Dao层的类和数据库中数据表保持一致
    >        
## day17
### 1. 数据库小知识点
1. 数据库小知识点
    > 1. 以后的查询语句全部使用动态sql模式
    >    
    >    写动态sql过程：写个初始sql:```SELECT XXX FROM XXX WHERE 1 = 1```，如果有条件，则在后边不断添加```AND xxx = xxx```等条件语句
    >    
## day18
### 1. Filter
1. Filter
    > 1. 概念
    >
    >    JavaWeb三大组件之一。过滤器，用来过滤一些对服务器的访问，完成一些特殊功能。可以通过setting修改Filter模板
    >    
    >    一般过滤器用来做通用的操作，如登录验证
    >    
    > 2. 使用步骤
    >
    >     1. 步骤
    >     
    >         1. 定义一个类，实现接口Filter：注意，此时的Filter接口是javax.Servlet包下的
    >         2. 复写方法
    >         3. 配置过滤路径：哪些访问路径需要执行该过滤器
    >             * 两种配置方式
    >                1、web.xml中配置
    >                2、通过注解配置：```@webFilter("路径")```，以后主要就是用这种方式
    >     
    > 3. 过滤器细节
    >
    >     1. web.xml配置过滤器
    >     
    >     2. 过滤器执行流程
    >     
    >        以放行的代码```chain.doFilter(req, resp)```做分界，放行前对request请求做增强，然后放行让其访问资源，访问资源后执行放行后代码对response响应做增强，最后再返回给浏览器。
    >     
    >     3. 过滤器生命周期方法
    >     
    >         ```
    >          @WebFilter(value="/*", dispatcherTypes=DispatcherType.REQUEST)
    >         public class Filter implements javax.servlet.Filter {
    >         
    >         	/**
    >         	*每次请求被拦截资源时都会执行该方法
    >         	*/
    >             public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException {
    >         		//先对request进行增强
    >         		
    >                 //放行，让它去访问资源
    >                 chain.doFilter(req, resp);
    >                 
    >                 //对response进行增强，之后返回给浏览器
    >             }
    >         	
    >         	/**
    >         	*服务器启动后自动创建Filter对象，然后自动调用init()方法，只执行一次。用于加载资源
    >         	*/
    >             public void init(FilterConfig config) throws ServletException {
    >         
    >             }
    >             
    >             /**
    >             *在服务器关闭后，如果为正常关闭，自动执行destroy()方法且只执行一次；如果非正常关闭，不会执行。用于释放资源
    >             */
    >             public void destroy() {
    >             }
    >         
    >         }
    >         ```
    >     
    >     4. 过滤器配置详解
    >     
    >         * 拦截路径配置
    >         
    >            1、具体的资源路径，如```/xxx/xxx.jsp```：只有访问具体的资源路径才会执行过滤器。该方法并不常用
    >            
    >            2、目录拦截，如```/xxx/*```：访问具体目录的所有资源时都会执行过滤器
    >            
    >            3、后缀名拦截，如```*.jsp```：对访问具体后缀名的资源时执行过滤器
    >            
    >            4、拦截所有资源，```/*```：访问所有资源都会执行过滤器
    >            
    >         * 拦截方式配置：指的是资源被访问的方式，可以指定多个方式
    >         
    >             * 注解配置（最常用）：设置属性```dispatcherTypes={属性值1, 属性值2, ...}```，属性值共有五种
    >             
    >                1、DispatcherType.REQUEST:默认值。浏览器直接请求资源
    >                
    >                2、DispatcherType.FORWARD:转发访问资源。
    >                
    >                3、DispatcherType.INCLUDE:包含访问。
    >                
    >                4、DispatcherType.ERROR:错误跳转。
    >                
    >                5、DispatcherType.ASYNC:异步访问。
    >                
    >             * 思考题：如果配置```@WebFilter(value = "/*", dispatcherTypes = {DispatcherType.REQUEST, DispatcherType.FORWARD})```，如果访问一个Servlet1，这个Servlet1转发给另一个Servlet2会经过几次过滤器？
    >             
    >                会经过四次，包括两次放行前的，两次放行后的。因为浏览器访问Servlet1，执行一次放行前，Servlet1转发给Servlet2，执行一次放行前，Servlet2响应原路返回给Servlet1，执行一次放行后，Servlet1响应原路返回浏览器，执行一次放行后，因此一共是两次放行前，两次放行后，共四次。
    >                
    >         
    >     5. 过滤器链（配置多个过滤器）
    >     
    >         * 多个过滤器访问顺序：假设先执行过滤器1，再执行过滤器2，然后访问资源
    >         
    >             过滤器1-/>过滤器2-/>资源-/>过滤器2-/>过滤器1
    >             
    >         * 多个过滤器的先后顺序：
    >         
    >             * 注解配置：按照类名字符串的比较规则，值小的先执行。
    >             
    >                如AFilter和BFilter，因为A小于B，因此AFilter先执行了；再比如Filter12和Filter3，因为1比3小，因此Filter17先执行
    >         
    >     6. 在过滤器中增强request对象来产生一个新的request对象
    >     
    >         * 设计模式：一些通用的解决固定问题的方式，共有23种
    >         
    >         * 增强对象的功能：通过设计模式来增强，在这里有两种设计模式可以实现
    >         
    >             1. 装饰模式
    >             
    >             2. 代理模式
    >             
    >                 * 概念：
    >                 
    >                    1、真实对象：被代理的对象
    >                    
    >                    2、代理对象
    >                    
    >                    3、代理模式：代理对象代理真实对象来增强真实对象
    >                    
    >                 * 实现方式：
    >                 
    >                     * 静态代理：一个类文件专门描述代理模式
    >                       
    >                     * 动态代理：内存中形成代理类。使用频率最多
    >                     
    >                         * 使用步骤：
    >                         
    >                             1. 代理对象和真实对象实现相同的接口
    >                                
    >                             2. 使用一个方法来获取代理对象，方法如下：
    >                             
    >                                 ```
    >                                 代理对象 = (真实对象的类名)Proxy.newInstance(参数1, 参数2, 参数3);
    >                                 ```
    >                                 
    >                             3. 使用代理对象来调用增强过的方法
    >                             
    >                         * Proxy.newInstance()方法详解
    >                         
    >                             ```
    >                             Proxy.newProxyInstance(参数1, 参数2, 参数3) -- 获取代理对象。使用该方法需要强制转化它的返回值为需要的类对象
    >                             ```
    >                             
    >                             * 参数1：类加载器，```真实对象.getClass().getClassLoader()```。
    >                             
    >                             * 参数2：接口数组，```真实对象.getClass().getInterfaces()```。
    >                             
    >                             * 参数3：处理器,
    >                             
    >                                 ```java
    >                                 new InvocationHandler() {
    >                                 	/**
    >                                 	* 代理逻辑编写方法，代理对象调用的所有方法都会触发该方法的执行。这里面写增强该方法的逻辑
    >                             		* 参数1：proxy, 代理对象，几乎不用
    >                                 	* 参数2：method，代理对象调用的方法被封装成的对象
    >                                 	* 参数3：args, 代理对象调用方法时传递的实际的参数的数组
    >                                 	*/
    >                                     @Override
    >                                     public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
    >                                 		//书写增强逻辑
    >                                         
    >                                         //返回真实对象执行方法的返回值obj
    >                                     }
    >                                 }
    >                                 ```
    >                             
    >                         * 增强方法的步骤
    >                         
    >                            在```new InvaocationHandler() {}```中重写的```invoke()```方法中书写增强的逻辑，最后返回。
    >                            
    >                             * 增强方式：一个方法由参数列表，返回值类型，方法体组成，因此我们可以增强这三个方面
    >                            
    >                                 1. 参数列表
    >                                    
    >                                 2. 返回值类型：强转method.invoke(真实对象, args)
    >                                 
    >                                 3. 方法体：书写方法执行之前的逻辑，调用method.invoke(真实对象, args)执行原方法，书写方法执行之后的逻辑
    >                     
    >             
    >             
    >             
    >         
    > 
### 2. Listener
2. Listener
    > 1. 概念
    > 
    >    监听器。JavaWeb三大组件之一。
    >    
    > 2. 事件监听机制
    > 
    >     * 事件；一个事件
    >     
    >     * 事件源：事件发生的地方
    >     
    >     * 监听器：一个对象
    >     
    >     * 注册监听：将事件、事件源、监听器绑定在一起，当事件源发生某个事件后，执行监听器的代码
    >     
    > 3. 监听器对象
    > 
    >     * ServletContextListener：监听ServletContext对象的创建和销毁。接口，无提供好的的实现类，要自己写实现类。
    >     
    >         * 方法
    >         
    >             ```
    >             void contextDestoryed(SevletContextEven sce) -- ServletContext对象销毁前调用此方法
    >             ```
    >             
    >             ```
    >             void contextInitialized(ServletContextEven sce) -- ServletContext对象初始化后调用此方法
    >             ```
    > 4. 步骤
    >     1. 定义一个类实现ServletContextListener接口
    >     2. 复写方法
    >     3. 配置
    >         * web.xml配置
    >         * 注解配置：@webListener()
    >           
## day19
### 1. JQuery基础
1. JQuery基础
    > 1. 概念
    >
    >    JS的框架。
    >    
    >    JavaScript框架本质就是一些封装了原生JS的文件。
    >    
    > 2. JQuery对象和JS对象的转化
    >
    >    JQuery对象在操作时更加方便，JQuery对象和JS对象的语法不通用。
    >    
    >    JQuery转化为JS对象：```JQuery对象[索引]```
    >    
    >    JS对象转化为JQuery对象：```$(JS对象)```
    >    
    > 3. 基本语法
    >
    >     1. 事件绑定
    >     
    >        ```
    >        JQuery对象.事件名(function() {
    >        
    >        });
    >        ```
    >        
    >     2. 入口函数：DOM文档加载完毕后执行该函数
    >     
    >         ```
    >         $(function() {
    >         	函数体;
    >     })
    >         ```
    >         
    >         * window.onload和$(function)区别：
    >         
    >            window.onload只能使用一次，多次定义后边的会覆盖前边的；$(function)可以多次定义
    >         
    >     3. 样式
    >     
    >         ```
    >         JQuery.css("键", "值");
    >         ```
    >     
    > 4. 选择器：筛选具有相同特征的元素（标签）
    >
    >     1. 基本选择器
    >     
    >         1. 标签选择器
    >         
    >         2. 类选择器
    >         
    >         3. id选择器
    >         
    >         4. 并集选择器：```$("选择器1, 选择器2")```
    >     
    >     2. 层级选择器
    >     
    >         1. 后代选择器
    >         
    >         2. 子代选择器
    >     
    >     3. 属性选择器
    >     
    >         1. 属性名称选择器：```$("A[属性名]")```
    >         
    >         2. 属性值选择器：```$("A[属性名='属性值']")```
    >         
    >         3. 复合属性选择器：```$("A[属性名='属性值'][属性名='属性值']...")```
    >     
    >     4. 过滤选择器
    >     
    >         1. 首元素选择器：```$("A:first")```
    >         
    >         2. 末元素选择器：```$("A:last")```
    >         
    >         3. 非元素选择器：```$("A:not(选择器)")```
    >         
    >         4. 奇元素选择器：```$("A:odd")```，从0开始计算索引
    >         
    >         5. 偶元素选择器：```$("A:even")```，从0开始计算索引
    >         
    >         6. 等于索引选择器：```$("A:eq(index)")```
    >         
    >         7. 大于索引选择器：```$("A:gt(index)")```
    >         
    >         8. 小于索引选择器：```$("A:lt(index)")```
    >         
    >         9. 标题选择器：```$("A:header")```
    >     
    >     5. 表单过滤选择器
    >     
    >         1. 可用元素选择器：```$("A:enabled")```
    >         
    >         2. 不可用元素选择器：```$("A:disabled")```
    >         
    >         3. 选中选择器：```$("A:checked")```
    >         
    >         4. 选中选择器：```$("A:selected")```，注意，这是对select的option来说的option:selected
    >     
    > 5. DOM操作
    > 
    >     1. 内容操作
    >     
    >         1. ```选择器.html([内容]) -- 获取/设置元素的标签体内容，空参为获取，填写参数为设置```
    >         
    >         2. ```选择器.text([内容]) -- 获取/设置元素纯文本内容。空参为获取，填写参数为设置```
    >         
    >         3. ```选择器.val([属性值]) -- 获取/设置元素的value的属性值。空参为获取，填写参数为设置```
    >         
    >     2. 属性操作
    >     
    >         1. 通用属性操作
    >         
    >     	      1. ```选择器.attr([属性值]) -- 获取/设置元素的属性值```
    >     	      
    >     	      2. ```选择器.removeAttr() -- ```
    >     	      
    >     	      3. ```选择器.prop() -- 获取/设置元素的属性值```
    >     	      
    >     	      4. ```选择器.removeProp() -- ```
    >     	      
    >     	      5. ```选择器.css() -- ```
    >     	      
    >     	      * **操作固有属性使用prop()，操作自定义属性使用attr()**
    >     	      
    >         2. class属性操作
    >         
    >             1. ```选择器.addClass(属性值) -- 添加class属性值```
    >             
    >             2. ```选择器.removeClass() -- 删除class属性值```
    >             
    >             3. ```选择器.toggleClass() -- 切换class```
    >         
    >     3. CRUD操作
    >     
    >         1. ```选择器.append(子元素) -- 父元素将子元素添加到末尾```
    >         
    >         2. ```选择器.appendTo(父元素) -- 子元素添加给父元素的末尾```
    >         
    >         3. ```选择器.prepend(子元素) -- 父元素将子元素添加到开头```
    >         
    >         4. ```选择器.prependTo(父元素) -- 子元素添加给父元素开头```
    >         
    >         5. ```选择器.after(元素2) -- 前面元素将元素2添加到自己后边```
    >         
    >         6. ```选择器.insertAfter(前面的元素) -- 将该元素添加到前面元素的后边```
    >         
    >         7. ```选择器.before(元素2) -- 前面元素将元素2添加到自己前边```
    >         
    >         8. ```选择器.insertBefore(前面的元素) -- 将该元素添加到前面元素的前面```
    >         
    >         9. ```选择器.remove() -- 将该元素删除```
    >         
    >         10. ```选择器.empty() -- 将元素中的后代元素清除但保留元素和属性节点```
    >         
    >         11. ```选择器.clone() -- 克隆该元素```
    >         
    >         * **注意：在JS中，this是JS的对象，不能直接使用clone()方法，需要转成JQuery对象才能使用：```$(this).clone()```**
    >         
### 2. JQuery高级
2. JQuery高级
    > 1. 动画
    > 
    >     1. 三种方式显示和隐藏元素
    >     
    >         1. 默认的显示和隐藏方式
    >         
    >             1. show(speed, [essing], [fn])
    >         
    >             2. hide(speed, [essing], [fn])
    >         
    >             3. toggle(speed, [essing], [fn])
    >             
    >             * speed有三个预定义的值："slow", "normal", "fast"
    >             
    >             * essing：动画执行的毫秒值，可以不写；也可以写预定的两个值；swing--先慢后快，linear--匀速
    >             
    >             * fn：动画执行完毕后执行该方法，可以不写
    >             
    >         2. 滑动显示和隐藏
    >         
    >             1. slideDown(speed, [essing], [fn])
    >             
    >             2. slideUp(speed, [essing], [fn])
    >             
    >             3. slideToggle(speed, [essing], [fn])
    >             
    >         3. 淡入淡出显示和隐藏
    >         
    >             1. fadeIn(speed, [essing], [fn])
    >             
    >             2. fadeOut(speed, [essing], [fn])
    >             
    >             3. fadeToggle(speed, [essing], [fn])
    >     
    > 2. 遍历
    > 
    >     1. 方法1
    >     
    >         ```
    >         JQuery对象.each(callback)
    >         ```
    >         
    >        * callback写回调函数，该函数每一次遍历都会执行，回调函数中的this就是每一次遍历的JS元素
    >        
    >        * callback回调函数可以定义两个参数，第一个参数传递索引，第二个参数传递每次遍历的JS元素
    >        
    >        * 如果callback回调函数的返回值返回false，则会结束遍历，否则继续遍历，因此这里面如果想要提前结束遍历，必须使用return false，而不是break；如果想要提前结束此次遍历，使用return ture，则后续代码不执行，不能用continue
    >        
    >     2. 方法2
    >     
    >         ```
    >         $.each(obj, [callback])
    >         ```
    >         
    >     3. 方法3
    >     
    >         ```
    >         for...of -- 该方式必须是JQuery3.0之后才可以使用
    >         ```
    >     
    > 3. 事件绑定
    > 
    >     1. 绑定
    >     
    >     	  ```
    >     	JQuery对象.事件名称(callback) -- 标准方式
    >     	```
    >     	
    >         ```
    >         JQuery对象.on("事件名称", callback)
    >         ```
    >         
    >         * JQuery允许链式编程
    >         
    >     2. 解绑
    >     
    >         ```
    >         JQuery对象.off("事件名称")
    >         ```
    >         
    >     3. 事件切换
    >     
    >         ```
    >         JQuery对象.toggle(fn1, fn2, ...) -- 点击一次执行fn1逻辑，点击两次执行fn2，以此类推
    >         ```
    >         
    >         * 注意：1.9版本JQuery移除了此方法，可以使用jQuery Migrate插件来恢复此功能
    >         
## day20
### 1. Ajax
1. Ajax
    > 1. 概念
    >
    >    Asynchronous JavaScript And XML，异步的JavaScript和XML
    >    
    >     * Asynchronous（异步）和Synchronize（同步）区别：
    >    
    >        同步请求客户端发送请求后必须处于等待，服务端响应后客户端才能继续操作；异步请求，客户端发送请求后不用考虑服务端是否响应，在服务端处理请求时客户端可以继续操作
    >        
    >        通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新
    > 2. 实现方式
    >
    >     1. 原生JS方式（了解，使用不多）
    >     
    >         * 步骤
    >         
    >             1. 创建Ajax核心对象
    >             
    >                 ```
    >                 var xmlhttp;
    >                 if (window.XMLHttpRequest) {
    >                 	// IE7+, FireFox, Chrome, Opera, Safari
    >                 	xmlhttp = new XMLHttpRequest();
    >                 } else {
    >                 	// IE5, IE6
    >                 	xmlhttp = ActiveXObject("Microsoft.XMLHTTP");
    >                 }
    >                 ```
    >                 
    >             2. 建立连接
    >             
    >                 ```
    >                 xmlhttp.open("GET/POST", "请求的url路径", true/false) -- 参数1：请求方式get/post；参数2：请求的url，若为get请求参数写在url后，若为post请求，参数写在send()方法参数中；参数3：是否为异步请求，是为true，否为false
    >                 ```
    >                 
    >             3. 发送请求
    >             
    >                 ```
    >                 xmlhttp.send([String]) -- 发送请求。参数：若为post请求，参数写在这里
    >                 ```
    >                 
    >             4. 接收并处理来自服务器的响应结果
    >             
    >                 ```
    >                 // 当xmlhttp对象的就绪状态改变时，触发该事件
    >                 xml.onreadystatechange = function() {
    >                 	// 当xmlhttp对象的就绪状态变为已经变为就绪，且响应状态码也为成功时处理来自服务器的响应
    >                 	if (xml.readyState == 4 && xmlhttp.status == 200) {
    >                 		// xmlhttp.responseText -- 存储的是响应的文本结果
    >                 		document.getElementById("MyDiv").innerHTML = xmlhttp.responseText;
    >                 	}
    >                 }
    >                 ```
    >         
    >     2. JQuery方式 
    >     
    >         1. ```$.ajax()```
    >         
    >              * 语法：```$.ajax({键值对1, 键值对2, ...})```
    >              
    >                  * 键值对包括： 
    >                  
    >                      * ```url: "url路径"``` -- 请求路径
    >                  
    >                      * ```type: "get/post"```， -- 请求方式
    >                  
    >                      * ```data: "参数"``` -- 请求参数。请求参数格式有两种，1.```data: "username=xxx&age=12&email=xxx"```，2.```data: {"" : "xxx"; "age" : 12; "email" : "xxx"}```，使用第二种Json对象格式绑定参数
    >                  
    >                      * ```success: function(data) { xxx; }``` -- 成功的回调函数，```data```为成功后接收到的数据
    >                      * ```error: function() { xxx; }``` -- 请求出错的回调函数。
    >                      * ```dataType: "类型"``` -- 预期服务端返回的数据类型。类型取值有："json", "xml", "script", "text"
    >              
    >         2. ```$.get()```：专门用来发送get请求
    >         
    >             * 语法：```$.get(url, [data], [callback], [type])```
    >             
    >                 * url -- 访问资源路径
    >                 
    >                 * data -- 请求参数
    >                 
    >                 * callback -- 回调函数
    >                 
    >                 * type -- 预计服务端响应数据类型，类型取值有："json", "xml", "script", "text"。以后主要都写"json"
    >             
    >         3. ```$.post()```：专门用来发送post请求
    >         
    >             * 语法：```$.post(url, [data], [callback], [type])```
    >             
    >                 * url -- 访问资源路径
    >                   
    >                 * data -- 请求参数
    >                   
    >                 * callback -- 回调函数
    >                   
    >                 * type -- 预计服务端响应数据，类型类型取值有："json", "xml", "script", "text"。以后主要都写"json"
    >             
### 2. JSON
2. JSON
    > 1. 概念
    >
    >    JavaScript Object Notation, JavaScript对象表示法，是一个JavaScript对象格式的字符串表示，本质上是字符串。是一种用来网络中存储和交换信息的方法，类似于xml，但是比xml更小、更快、更容易解析
    >    
    > 2. 使用
    >
    >     1. JSON的语法规则
    >     
    >        JSON是JavaScript对象表示语法的子集
    >        
    >         * 数据存储为键值对
    >        
    >             * 键使用```""```或```''```引起来，也可以不引起来
    >             
    >             * 值的取值类型：
    >             
    >                 1. 数字：整形或浮点型
    >                 
    >                 2. 字符串：字符串的值要用双引号引起来
    >                 
    >                 3. 逻辑值：true/false
    >                 
    >                 4. 数组：在[]中
    >                 
    >                 5. 对象：在{}中
    >                 
    >                 6. null：不常用
    >             
    >         * 多个数据之间用,隔开：即键值对之间用,隔开
    >        
    >         * 花括号存储对象：使用[]定义json格式
    >        
    >         * 方括号存储数组：[]
    >        
    >     2. 获取json中的数据
    >     
    >         * 方式1：```json对象.键名``` -- 返回键对应的值
    >         
    >         * 方式2：```json对象["键名"]``` -- 返回键对应的值
    >         
    >         * 方式3：```json对象[索引]``` -- 如果json对象存储的是数组，可以使用该方式获取值
    >         
    >     3. JavaScript中遍历json对象：使用for ... in来遍历
    >     
    >         ```
    >         for (值 in json对象) {
    >         
    >         }
    >         ```
    >         
    >     4. Json对象和Java对象的相互转换
    >         * Json解析器
    >         
    >             * 常见的解析器：Jsonlib，Gson，fastjson，jackson 
    >             
    >             * 这里使用jackson，因为这是SpringMVC框架的解析器
    >             
    >         * Json字符串转为Java对象
    >         
    >             1. 步骤
    >             
    >                 1. 导入jackson的jar包
    >                 
    >                 2. 创建jackson的核心对象：ObjectMapper
    >                 
    >                 3. 调用ObjectMapper的相关方法来转换Java对象字符串和Json对象
    >                 
    >             2. ObjectMapp对象的Json对象转为Java对象的方法
    >             
    >                 * ```
    >                   readValue(参数1, 参数2) -- 
    >                   参数1：Json对象
    >                   参数2：要转换的对象的类的Class对象，xxx.class
    >                   ```
    >             
    >         * Java对象转为Json字符串，使用jackson
    >         
    >             1. 步骤
    >             
    >                 1. 导入jackson的jar包
    >                 
    >                 2. 创建jackson的核心对象：ObjectMapper
    >                 
    >                 3. 调用ObjectMapper的相关方法来转换Java对象和Json对象
    >                 
    >             2. ObjectMapper对象的Java对象转为Json对象方法：
    >             
    >                 * ```
    >                   void writeValue(参数1, 参数2) -- 
    >                   参数1：File，将obj对象转化为Json对象的字符串形式并存储到File对象对应的文件中
    >                   	  Writer，将obj对象转化为Json对象的字符串形式并填充到Writer字符串输出流中，一般这里以后传递reponse对象的response.getWriter()
    >                   	  OutputStream，将obj对象转化为Json对象的字符串形式并填充到OutputStream字节输出流中
    >                   参数2：obj对象
    >                   ```
    >                   
    >                 * ```
    >                   String writeValueAsString(Object obj) -- 将Java对象转为Json对象的字符串形式并返回
    >                   ```
    >                 
    >               3. 注解
    >               
    >                   * ```@JsonIgnore``` -- ：加在要转化成Json对象字符串形式的obj对象的类的属性上。转为Json对象字符串形式时忽略此属性
    >                   
    >                   * ```@JsonFormat(pattern = "格式")``` -- 加在要转化成Json对象字符串形式的obj对象的类的属性上。格式化该属性，格式和SimpleDataFormat的数据格式一样，如```"yyyy-MM-dd HH:ii:ss"```
    >                   
    >              4. 复杂的Java对象的转化
    >             
    >                  * List集合：转成Json对象字符串形式的样式为数组样式的，```"[{键值对}, {键值对}, {键值对}, {键值对}, ...]"```
    >                  
    >                  * Map集合：转成Json对象字符串形式的样式为对象样式的，```"{键值对, 键值对, 键值对, ...}"```
    >     
    > 3. 小细节 
    > 
    >     1. 服务器响应的数据给客户端使用，如果想要当成Json对象数据格式使用的方式
    >     
    >         * 方式一：
    >         
    >            1、JavaScript的ajax中别忘了设置type为```"json”```
    >     
    >            2、客户端响应时一定要先设置response的编码为中文:```response.setContextType("text/html;utf-8")```，然后再使用```ObjectMapper的writeValue(reponse.getWriter(), Java对象)```响应给客户端
    >            
    >         * 方式二：
    >         
    >            直接在服务器端响应时设置response编码为json:```response.setContextType("application/json;characte=utf-8")```即可
    >            
## day21
### 1. Redis
1. Redis
    > 1. 概念
    >
    >    Redis是一款高性能的NOSQL系列的非关系型数据库。常用于作为缓存（cache）
    >    
    >    * NOSQL：非关系型数据库
    >    
    >    * 关系型数据库和非关系型数据库的区别：
    >    
    >        * 关系型数据库：如MySql、Oracle等，数据被保存在数据表中，数据之间有关系。他们有如下特点：
    >        
    >           1、数据之间有关系，如多对一，多对多，一对一
    >           
    >           2、数据保存在硬盘中的文件上
    >           
    >        * 非关系型数据库：如Redis、hbase等。Redis中数据以键值对形式存在。有如下特点：
    >        
    >           1、数据之间没有关系
    >           
    >           2、数据保存在内存中 
    > 2. 下载 
    >    redis中文网(https://redis.net.cn)
    >    
    >     * 解压即可用，主要关系如下几个文件：
    >    
    >         * redis.windows.conf -- 配置文件
    >         
    >         * redis-cli.exe -- redis客户端，双击启动。默认访问6379端口
    >         
    >         * redis-server.exe -- redis服务器端 ，双击启动。默认端口6379
    >    
    > 3. 命令操作
    >
    >     1. redis数据结构：
    >     
    >         * redis存储的是key-value格式的数据，key全是字符串，value有五种数据结构：
    >             1. 字符串类型：string
    >         
    >             2. 哈希类型：hash
    >         
    >                可以理解为Map的格式
    >             
    >             3. 列表类型：list
    >         
    >                类似于LinkedList格式，列表允许重复元素
    >               
    >             4. 集合类型：set
    >         
    >                类似于HashSet格式，集合不允许重复元素
    >               
    >             5. 有序集合类型：sortedset
    >         
    >                类似于元素 排序过的HashSet格式，有序集合不允许重复元素
    >         
    >     2. 字符串类型：string
    >     
    >         * 存储命令：```set key value```
    >         
    >         * 获取命令：```get key```
    >         
    >         * 删除命令：```del key```
    >         
    >     3. 哈希类型：hash
    >     
    >         * 存储命令：```hset key field value -- 给key元素的field列设置值为value```
    >         
    >         * 获取命令：```hget key field -- 获取key元素中field列中的数据``` 和 ```hgetall key  -- 获取key元素中的所有列数据```
    >         
    >         * 删除命令：```hdel key field```
    >         
    >     4. 列表类型：list，可以添加一个元素到列表头或者列表尾部
    >     
    >         * 存储命令：```lpush key value -- 给key列表左边添加value的数据``` 和 ```rpush key value -- 给key列表右边添加value的数据```
    >         
    >         * 获取命令：```lrange key start end -- 从左到右范围查询key列表从start到 end的数据，想要获取全部key列表数据，则start为0，end为-1```
    >         
    >         * 删除命令：```lpop key -- 从key列表左边弹出元素``` 和 ```rpop key -- 从key列表右边弹出一个元素```
    >         
    >     4. 集合类型：set
    >     
    >         * 存储命令：```sadd key value -- 存储数据value到集合key中```
    >         
    >         * 获取命令：```smembers key -- 获取key集合所有元素```
    >         
    >         * 删除命令：```srem key value -- 删除key集合的value元素```
    >         
    >     5. 有序集合类型：sortedset。存储进有序集合的元素会关联一个double浮点数，有序集合通过关联的浮点数排列 
    >     
    >         * 存储命令：```zadd key score value -- 存储以score关联的value进key有序集合中```
    >         
    >         * 获取命令：```zrange key start end -- 获取key集合中范围为start到end的元素，想要获取全部key有序集合数据，则start为0，end为-1```
    >         
    >         * 删除命令：```zrem key value -- 删除key有序集合中的元素value```
    >         
    >     6. 通用的命令
    >     
    >         1. ```keys * -- 查询所有的key```
    >         
    >         2. ```type key -- 获取key存储的数据类型```
    >         
    >         3. ```del key -- 删除指定的key```
    >     
    > 4. 持久化操作
    >
    >     1. redis是一个内存数据库，当一个redis服务器重启时，或者电脑重启，数据会丢失，可以将redis内存中的数据持久化存储到硬盘。
    >     
    >     2. redis持久化机制
    >     
    >         1. RDB：默认方式，默认开启。不需要配置。
    >         
    >             * 在一定的间隔时间中，检测key的变化，然后持久化存储数据
    >             
    >             * 通过编辑redis.windows.conf文件中，然后重启redis即可完成RDB配置：			      
    >                 1. 编辑redis.windows.conf文件
    >                 
    >                     ```
    >                     # after 900 sec (15 min) if at least 1 changed
    >                     save 900 1 
    >                     # after 300 sec (5 min) if at least 10 changed
    >                     save 300 10
    >                     # after 60 sec (1 min) if at least 10000 changed 
    >                     save 60 10000
    >                     ```
    >                 2. 重启redis服务端并指定配置文件名称，通过命令行命令重启
    >                 
    >                     ```
    >                     D:\Redis\redis-2.8.9>redis-server.exe redis.windows.conf
    >                     ```
    >             
    >         2. AOF：日志记录的方式，可以记录每一条命令的操作。可以每一次命令操作后，持久化存储数据。默认关闭。不推荐，会很影响性能
    >     
    > 5. 使用Java客户端操作redis
    >
    >     * Jedis：一款java操作redis的工具
    >     
    >         1. 使用步骤
    >         
    >             1. 导入jar包
    >             
    >             2. 获取jedis连接
    >             
    >                 ```java
    >                 // 根据Ip地址，端口号创建jedis对象
    >                 Jedis jedis = new Jedis("Ip地址", 6379);
    >                 ```
    >                 
    >             3. 操作redis
    >             
    >             4. 释放资源
    >             
    >                 ```java
    >                 jedis.close();
    >                 ```
    >             
    >         2. Jedis操作各种的redis数据结构
    >         
    >             * 字符串：string
    >                 ```java
    >                 String get(key) -- 
    >                 void set(key, value) --
    >                 void setex(key, time, value) -- 存储指定过期时间的键值对，时间以秒为单位
    >                 void del(key, value) -- 
    >                 ```
    >                 
    >             * 哈希：hash
    >             
    >                 ```java
    >                 void hset(key, field, value) -- 
    >                 String hget(key, field) -- 
    >                 Map<String, String> hgetAll(key) -- 
    >                 void hdel(key, field) -- 
    >                 ```
    >                 
    >             * 列表：list
    >             
    >                 ```java
    >                 void lpush(key, value, value, ...) -- 从左往右存储 
    >                 String lpop(key, value) -- 从左边弹出一个元素
    >                 void rpush(key, value, value, ...) -- 从右往左存储
    >                 String rpop(key, value) -- 从右边弹出一个元素
    >                 list<String> lrange(key, start, end) -- 
    >                 ```
    >                 
    >             * 集合：set
    >             
    >                 ```java
    >                 void sadd(key, value, value, ...) -- 
    >                 Set<String> smembers(key) --
    >                 void srem(key)
    >                 ```
    >                 
    >             * 有序集合：sortedset
    >             
    >                 ```java
    >                 void zadd(key, score, value) -- 
    >                 set<String> zrange(key, start, value) --
    >                 void zrem(key, value) --
    >                 ```
    >         
    >     * jedis连接池：jedis自带连接池，JedisPool对象即为jedis连接池对象
    >     
    >         * 使用
    >         
    >             1. 创建JedisPool，并配置
    >             
    >                 * 创建JedisPoolConfig对象来完成对JedisPool的配置
    >                 
    >                     ```java
    >                     JedisPoolConfig jedisPoolConf = new JedisPoolConfig();
    >                     // 配置最大允许连接数
    >                     jedisPoolConf.setMaxTotal(50);
    >                     // 配置最大空闲连接
    >                     jedisPoolConf.setMaxIdle(10);
    >                     ```
    >                     
    >                 * 创建JedisPool对象
    >                 
    >                     ```java
    >                     // 根据配置，host，端口号创建jedisPool对象
    >                     JedisPool jedisPool = new JedisPool(jedisPoolConf, "Ip地址", 6379);
    >                     ```
    >                 
    >             2. 调用方法获取jedis连接
    >             
    >                 ```java
    >                 Jedis jedis = jedisPool.getResource();
    >                 ```
    >                 
    >             3. 使用jedis连接完成各种操作
    >             
    >         * 抽取JedisPool的工具类：JedisPoolUtils
    >         
## day22
### 1. Maven
1. Maven
    > 1. 概述
    > 
    >    是一个项目管理工具。它包含一个项目对象模型POM(Project Object Mode)，一套标准集合，一个生命周期Project Lifecycle，一个依赖管理系统，和用来定义在生命周期阶段中插件目标的逻辑
    >    
    > 2. 下载和使用
    > 
    >    下载解压
    >    
    >    配置环境变量
    >    
    > 3. Maven项目的标准目录结构
    > 
    >     * 核心代码部分
    >     
    >        src/main/java  
    >     
    >     * 配置文件部分
    >     
    >        src/main/resources
    >     
    >     * 测试代码部分
    >     
    >        src/test/java
    >     
    >     * 测试配置文件部分
    >     
    >        src/test/resources
    >        
    >     * 页面资源如js,css,图片等（web项目多了这个）
    >     
    >        src/main/webapp
    >     
    > 4. Maven的常用命令
    > 
    >     * ```mvn clean -- 删除本地编译的信息，删除target目录```
    >     
    >     * ```mvn compile -- 编译项目，生成target目录，target目录中放置着class文件````
    >     
    >     * ```mvn test -- 编译测试代码和核心代码，放入target目录```
    >     
    >     * ```mvn package -- 打包项目，放入target目录。打包的压缩包格式在配置文件中可以找到```
    >     
    >     * ```mvn install -- 安装，集成了compile和test和package的功能，同时会把包安装到本地仓库```
    >     
    > 5. Maven的生命周期
    > 
    >     * 准备生命周期：清空本地编译信息，相当于mvn clean的工作
    >     
    >     * 默认生命周期：编译-\>测试-\>打包-\>安装-\>发布，相当于从前到后依次执行了mvn compile、mvn test、mvn package、mvn install、mvn deploy
    >     
    >     * 站点生命周期：用的少，不做了解
    >     
    > 6. Maven概念模型
    > 
    >    见视频
    >    
    > 7. IDEA集成Maven插件
    >    见视频
    > 
## Web旅游网
1. Web旅游网架构
    > 1. 项目架构步骤
    >
    >     1. 项目导入
    >     
    >     2. 技术选型
    >     
    >         * Web层
    >         
    >            1.Servlet：前端控制；2.Html：视图（为保证用户访问速度快，不使用jsp）；3.Filter：过滤器；4.BeanUtils：数据封装；5.Jackson：json序列化工具
    >            
    >         * Service层
    >         
    >            1.JavaMail：java发送邮件工具；2.Redis：内存数据库；3.Jedis：java的redis客户端
    >         
    >         * Dao层
    >         
    >            1.Mysql数据库；2.Druid：数据库连接池；3.JdbcTempleta：jdbc工具
    >         
    >     3. 导入数据库
    >     
    >     4. 具体功能实现
    >     
    >         1. 完成注册功能
    >         
    >            1. 表单校验
    >            
    >            2. 异步提交：因为前台使用html作为视图，不能直接从servlet相关的域对象中获取值，因此必须使用ajax获取响应数据
    >            
    >                * 注意：异步提交需要1.让表单的submit()事件永远置为false，即永远不自动提交；2.需要获取表单数据然后通过ajax发送数据。
    >                * 注意：获取表单数据，在JQuery中提供了一个方法```serialize()```，该方法由表单的JQuery对象调用，返回序列化表单信息的字符串。字符串形式为"key1=value1&key2=value2..."，因此可以直接作为ajax的传参
    >                
    >            3. 后台代码
    >            
    >               1. 前置：编写一个过滤器，用来解决request和response中文乱码问题
    >            
    >               2. 编写RegisterServlet
    >               
    >               3. 编写UserService和UserServiceImpl
    >               
    >               4. 编写UserDao和UserDaoImpl
    >               
    >                   * 注意：使用template的query有关方法，如果查询不到数据，则会直接抛出异常。因此我们如果需要抓取异常
    >                   
    >                   * 注意：在JDBCUtils类中，加载recources目录下的资源，默认是```/资源名```，其实应该直接是```资源名```
    >         
    >           2. 验证码和前台数据处理
    >           
    >               1. Service层
    >               
    >                  验证码判断应该在Service层，并且应该在所有操作之前，如果验证码错误，直接不用进行操作。
    >                  
    >                   * 注意：从Session获取验证码后必须立刻销毁Session中对应的验证码信息，防止用户复用
    >                   * 注意：在比较验证码时，要考虑因为session中验证码被销毁后，如果用户继续访问导致的空指针异常问题
    >                  
    >               2. 视图层
    >               
    >                  html界面处理响应回来的json字符串
    >               
    >           3. 邮箱激活
    >           
    >               1. 发送邮件
    >               
    >                  功能实现应该在Service层
    >                  
    >                  在之前保存用户信息时，应该同时设置用户的激活状态和对应的激活码。保存用户信息的同时，应该发送激活邮件给用户。
    >                  
    >               2. 用户点击邮件激活
    >               
    >                  * 前置：修改之前在dao层写过的save方法中的sql语句，让其将user中的status和code也保存起来
    >                  
    >                  * web层：创建activeUserServlet用来接收用户点击激活邮件后发送来的数据
    >                  
    >                  * service层：在UserService中，定义一个激活邮件方法active()
    >                  
    >                  * dao层：在UserDao中，定义两个方法，findByCode通过激活码获取用户信息，updateStatus修改需要激活的用户激活状态
    >     
    > 2. 完成登录功能
    >
    >     1. 前台
    >     
    >         1. 异步提交
    >         
    >         2. 登录成功后应该在index.html界面头部，显示登录用户信息提示功能
    >         
    >             1. index.htm页面通过js加载了head.html和footer.html，这样达到了代码复用的目的。因此，要在index.html界面头部显示用户信息提示功能，需要在head.html获取标签。
    >             2. 需要在head.html界面定义js函数。js函数在加载完毕head.html后，访问findUserServlet。
    >             
    >             3. 定义findUserServlet
    >             
    >             4. 获取响应
    >     
    >     2. 后台
    >     
    >         1. web层
    >         
    >             1. 创建LoginServlet
    >             
    >             2. 在Service层编写login()方法
    >             
    >             3. 在Dao层编写findByUsernameAndPassword()方法
    >     
    > 3. 完成退出功能
    >
    >     1. 前台页面点击退出，触发事件
    >     
    >     2. 事件访问exitServlet，将Session销毁
    >     
    >     3. 跳转到登录页面 
    >     
    > 4. 优化Servlet
    >
    >     1. 思考
    >     
    >        之前的Servlet都是一个功能一个Servlet，将其优化为一个模块一个Servlet。相当于数据库中，一张表一个Servlet。
    >        
    >     2. 优化思路
    >     
    >        由于之前写的Servlet都是继承自HttpServlet，HttpServlet中，Service()方法会对于请求的类别不同分发给doGet()或者doPost()方法。由于HttpServlet这个类是接口规范，我们无法修改，因此我们自己定义一个BaseServlet类作为中间类，让BaseServlet继承HttpServlet，然后我们其他Servlet都继承自BaseServlet。
    >        
    >        我们在BaseServlet中完成对方法的分发
    >        
    >     3. 具体步骤
    >     
    >         1. 定义一个BaseServlet继承HttpServlet，重写service()方法。之后的如UserServlet等继承了BaseServlet，当UserServlet被访问时，会自动执行BaseServlet中的service()方法
    >         
    >         2. 在service()中，获取访问路径，根据访问路径，获取方法名称
    >         
    >         3. 根据方法名称，获取对应Servlet中的方法对象。如何获取对应Servlet的字节码文件？我们已经知道BaseServlet中的service()方法其实是其他的Servlet调用的，而```this```关键字谁调用就代表谁，因此this就代表了其他Servlet对象。因此，直接用this.getClass()即可获得对应Servlet的字节码文件
    >         
    >         4. 注意：在获取Method对象时，如果方法是受保护的或是私有的，则无法使用getMethod()方法获取，同时也无法直接使用invoke()执行。要想获取和执行有以下两个方法：1.使用getDeclaredMethod()方法，该方法会忽略权限访问修饰符，同时对Method对象使用暴力反射，这样才能调用invoke()执行。但是该做法很不推荐；2.修改我们需要的方法权限修饰符为public即可。该方法最为推荐，因为类中有些方法或属性确实不想被访问，则不要暴力访问。
    >     
    > 5. 整合冗余的Servlet
    >
    > 6. 发送ajax请求，访问服务器，加载真正的旅游分类数据进入head.html
    >
    >     1. 后台代码
    >     
    >         1. 先编写dao层代码
    >         
    >         2. 再编写service层代码
    >         
    >         3. 最后编写web层代码
    >         
    >         * 注意：因为我们视图层展示使用html，因此我们在web层进行序列化的操作会很多。由于我们使用了BaseServlet进行了冗余的整合，因此我们可以在BaseServlet中定义一个方法，抽取序列化的代码。之后其他Servlet想序列化对象时，直接使用它们父类BaseServlet方法即可。这一系列抽取BaseServlet的操作，和BaseServlet的各种方法，其实就是框架的基础。
    >         
    >     2. 前台代码
    >     
    >         1. 在header.html加载时，发送ajax请求，请求数据
    >         
    >         2. 缓存优化：对于不经常变化的数据，我们不应该让其在每次加载时都从数据库加载，否则会造成数据库压力过大。我们可以使用Redis缓存来解决这个问题
    >         
    >             1. 分类数据属于不经常变化数据，因此我们在service层查询分类数据时，应该从Redis缓存来查询。service层查询缓存，第一次查询时缓存没有数据，当没有数据时说明是第一次查询，我们应该直接从数据库查询数据，并将该数据放入Redis缓存；之后重复加载时，service层查询缓存，缓存有数据，直接从缓存获取数据
    >             
    >             2. 如果考虑分类数据，则我们使用Redis中的sortedset排序查询
    >     
    > 7. 旅游线路分页展示
    >
    >     1. 旅游的路线需要使用cid
    >     
    >         1. 我们之前把旅游分类数据放置到redis，从redis中查询数据时，只查询了旅游分类数据cname，没有查询cid。
    >     
    >         2. 我们需要继续修改service中查询数据的代码。需要使用jedis中能够同时查询数据和权值的方法jedis.zrangeWithScores()。
    >     
    >             ```
    >             Set<Tuple> jedis.zrangeWithScores(String key, int start, int end) -- 从redis中获取指定key的从start到end的数据和权值。
    >             **Tuple类存储了redis中数据和权值，调用getElement()方法获取数据，调用getScore()方法获取权值
    >         String getElement()
    >            double getScore()
    >            ```
    >         
    >    2. 在每个指定的旅游路线界面，通过JS获取从?开始的URL
    >    
    >       location对象的属性search，获取从?开始的URL包括?
    >       
    >    3. 根据id查询不同类别的旅游线路数据
    >    
    >        1. 创建PageBean类，用来保存分页数据
    >        
    >        2. 客户端代码编写
    >        
    >            1. 数据列表的展示
    >        
    >            2. 分页页码展示
    >        
    >                1. 分页数据跳转逻辑
    >                
    >                   因为我们是使用的ajax异步请求，因此每次都是加载不同的数据而已，因此我们可以：抽取发送ajax请求的逻辑封装为一个js函数load()。每一个页码按钮都调用自己这个js函数load()。每次发送ajax请求，返回不同的json数据，改变分页工具条的数据展示和列表数据的展示。同时，首页和尾页和上一页和下一页的按钮也这样，调用load()函数
    >                   
    >                    * 注意：因为如果只在超链接加load()方法，会导致用户只有在点击到超链接上时才会跳转，而点击到li标签不会跳转，用户体验差。因此超链接加上javacript:void(0)，在li上加onclick事件以保证用户体验。
    >                   
    >                2. 仿百度页码展示逻辑
    >                
    >                    1. 总共展示10个页码，达到前5后4效果
    >                    
    >                    2. 如果前边不够5个，后边自动补齐，共10个
    >                    
    >                    3. 如果后边不足4个，前边自动补齐，共10个
    >                    
    >                    4. 逻辑分析
    >                       
    >        
    >        3. 服务端代码编写
    >        
    >            1. 创建RouteServlet、RouteService、RouteDao
    >            
    >            2. 在RouteServlet中编写pageQuery()方法用来做分页查询
    >            
    >            3. 先编写RouteDao中的方法
    >    
    > 8. 旅游线路名称查询
    > 
    > 	  1. 前置：在提供的travel工程中，已经在js包下写好了一个js函数getParameter()，次函数可以根据传入参数的名称获取URL上指定参数名称的值。使用时只需要先导包，然后再使用即可。前面我们自己写的获取参数的逻辑可以用该函数替换掉了
    > 	  
    >     1. 查询参数的传递
    >     
    >     2. 注意：中文字符在URL上传递时，获取需要进行URL解码才能得到原样的数据
    >     
    >     3. 修改后台代码
    >     
    >         * 解决乱码问题（由于travel工程使用的是tomcat7，因此还没有自动解决中文乱码问题，需要手动解决）
    >         
    >             ```
    >             // 解决rname乱码问题
              rname = new String(rname.getBytes("iso-8859-1"), "utf-8");
    >           ```
    >         
    >     4. 继续修改前台代码
    >     
    >         * 注意：在页码的load()修改时，因为rname是个字符串，因此需要先转义一对引号，然后再拼接rname进引号里
    >         
    >         * 注意：首次进入时，由于cid没有值，因此会传入给服务器一个字符串"null"，服务器会对这个"null"进行int类型的转换，这会导致报错。因此需要在服务端对传入的cid为"null"做一个判断。
    >     
    > 9. 旅游详情页面
    > 
    >     1. 当点击查看详情超链接，则跳转到route_detail.html?rid=xx，根据路径后的rid判断点击的是哪个路线
    >     
    >     2. 当route_detail.html页面一加载，则发送ajax请求，请求对应信息
    >     
    >     3. 后台代码
    >     
    >     4. 前台代码
    >     
    >         * 注意：由于图片展示和切换需要在ajax请求访问数据后才行，因此，我们需要改变图片展示和切换的代码位置。
    >     
    >     
    

## Mybatis

