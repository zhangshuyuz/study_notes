#    Redis
## 1. 技术分类
1. 技术分类
    > 1. 解决功能性问题：Java、JSP、RDBMS、Tomcat、HTML、Linux、JDBC、SVN
    > 
    > 2. 解决扩展性问题：Struts、Spring、SpringMVC、Hibernate、MyBatis
    > 
    > 3. 解决性能问题：NoSQL、Java线程、Hadoop、Nginx、MQ、ElasticSearch
    > 
## 2. Session存储问题
2. Session存储问题
    > 1. 引言
    > 
    >    由于现在的服务器架构都是经过负载均衡的，即有多个服务器可以处理请求，通过负载均衡将请求发给不同服务器处理。
    >    
    >    因此Session就不可能存储在web服务器中了，因为无法知道一次会话中的多次请求是否会被发送到同一台服务器处理。
    >    
    >    所以我们需要新的存储Session的方式
    >    
    > 2. 将Session存储在Cookie中
    > 
    >     1. 不安全
    >     
    >     2. 网络负担效率低。因为我们每一次服务器都需要从客户端读Cookie获取Session，然后将Session写到Cookie，网络效率低。
    >     
    > 3. 存储在文件服务器或数据库服务器中

    >     1. 大量的IO效率问题
    >     
    > 4. Session复制，即每当Session验证成功后，平行复制Session到所有的web服务器
    > 
    >     1. Session数据冗余，节点越多浪费越大
    >     
    > 5. 存储在缓存服务器中
    > 
    >    最常用的方式，好处是：1、完全存储在内存中，速度快；2、数据结构简单
    >    
## 3. NoSQL数据库
3. NoSQL数据库
    > 1. 简介
    > 
    >    NoSQL泛指非关系型数据库
    >    
    >    NoSQL数据库不依赖业务逻辑方式存储，而是以简单的key-value模式存储，因此大大的增加了数据库的扩展能力。
    >    
    >    NoSQL不遵循SQL标准，不支持ACID（事务的四大特征，泛指事务），远超SQL的性能。
    >    NoSQL数据库数据存储在内存中
    >    
    > 2. NoSQL适用场景
    > 
    >    对数据高并发的读写操作
    >    
    >    海量数据的读写操作
    >    
    >    对数据高扩展性的要求
    >    
    > 3. NoSQL不适用场景
    > 
    >    需要事务支持的操作
    >    
    >    需要SQL的结构化查询数据，处理复杂的关系，需要条件查询
    >    
    > 4. 常见的NoSQL数据库
    > 
    >     1. Memcached：
    >     
    >        很早出现的NoSQL数据库
    >        
    >        数据存储在内存，不支持数据的持久化
    >        
    >        支持简单的key-value模式
    >        
    >        一般作为缓存数据库辅助持久化数据库
    >        
    >     2. Redis
    >     
    >        几乎覆盖了Memcached的绝大部分功能，可以理解为Memecached+
    >        
    >        数据存储在内存，支持持久化，主要用于数据备份
    >        
    >        除了简单的key-value模式，还支持多种数据结构存储，例如list，set，hash，zset等
    >        
    >        一般是作为缓存数据库辅助持久化数据库
    >        
    >     3. mongonDB
    >     
    >        高性能、开源、模式自由（schema free）的文档型数据库
    >        
    >        数据在内存中，如果内存不足，
    >        
    >        虽然是key-value模式，但是对value（尤其是json）提供把不常用的数据保存到硬盘
    >        支持二进制数据和大型对象
    >        
    >        可以根据数据特点代替RDBMS，成为独立数据库。或者配合RDBMS
    >        
    >     4. HBase
    >     
    >        HBase是Hadoop项目中的数据库
    >        
    >        用于对大量数据进行随机、实时的读写操作场景中
    >        
    >        HBase目标就是处理数据量非常庞大的表，可以用普通计算机处理10亿行数据，还可以处理数百万列元素的数据表。
    >        
    >     5. Cassandra
    >     
    >        Apache Cassndra是一款免费的开源NoSQL数据库，设计目的用于管理大量商用服务器构建起来的庞大集群上的海量数据（数据量达到PB级别）。
    >        
    >        长处是对写入和读操作进行规模调整
    >        
    >     6. Neo4j
    >     
    >        主要用于社会关系、公共交通网络、地图和网络拓扑的数据库
    >        
## 4. Redis
4. Redis
    > 1. 介绍
    > 
    >    Redis是一款开源key-value存储系统，和Memcached类似，支持的value类型更多，包括string(字符串)、list(链表)、set(集合)、zset(类似于Java中的sortedMap)、hash(哈希
    >    
    > 2. 应用场景
    > 
    >    配合关系型数据库做高速缓存
    >    
    >    存储高频次数据，降低IO
    >    
    >    存储Session，做Session共享
    > 
### 1. Linux环境下安装和启动Redis
1. Linux环境下安装和启动Redis
    > 1. Linux环境下安装Redis
    > 
    >     1. 将Redis的tar.gz包放入/opt下并解压
    >     
    >     2. cd redis-3.2.5
    >     
    >     3. 执行make命令，然后看报错
    >     
    >         * 因为Redis是由C语言开发的，它需要编译之后才能运行，因此需要有C的解析器和编译环境。下载gcc和gcc-c++。可以通过yum install直接下载这两个。
    >         
    >         * 安装完gcc和gcc-c++后使用```gcc -v```和```g++ -v```查看版本
    >         
    >     4. 之后再次进入redis-3.2.5的目录，清空之前的错误文件```make distclean```
    >     
    >     5. 再次执行make命令，进行编译
    >     
    >     6. 编译成功后，执行```make install```进行安装。至此安装完成
    >     
    > 4. Redis安装成功后，默认安装目录是/usr/local/bin
    > 
    >    在/usr/local/bin中，有多个redis的命令文件：因为是放在/usr/local/bin中，因此这些命令可以在任意位置启动
    >    
    >     * redis-benchmark：性能测试工具
    >    
    >     * redis-check-aof：修复有问题的AOF文件
    >    
    >     * redis-check-dump：修复有问题的dump.rdb文件
    >    
    >     * redis-sentinel：Redis集群使用
    >    
    >     * redis-server：Redis服务器启动命令
    >    
    >     * redis-cli：客户端启动命令，操作入口
    >    
    > 5. Redis的启动
    > 
    >    直接输入redis-server命令启动服务端，但这是前台启动，会一直占用前台。
    >    
    >    因此我们需要将Redis设置为后台启动：
    >    
    >     1. 先对redis配置文件备份，用以在启动Redis时按照备份的配置文件启动：拷贝redis.conf到其他目录，例如/myredis/
    >    
    >     2. 修改Redis启动为后台启动：备份的redis.conf中的daemonize no 改为 deamonize yes
    >    
    >     3. 启动命令，按照我们备份的配置文件启动：```redis-server 备份配置文件的路径```
    >    
    >     4. 可以通过查看进程的命令来看redis是否正常启动：```ps -ef | grep redis```
    >    
    > 6. Redis的客户端访问：
    > 
    >     1. 直接访问：```redis-cli ```
    >     
    >     2. 多个客户端访问redis：```redis-cli -h Redis所在服务器的IP -p Redis服务的端口，默认6379```
    >     
    >     3. 客户端访问后，可以使用Redis中的ping命令，看是否出现PONG
    >     
    >     4. 客户端访问后，退出客户端：```exit```
    >     
    >     5. 客户端访问后，退出客户端同时退出服务端：```shutdown```
    >     
    >     6. 开启了Redis服务端，在命令行中关闭客户端：```redis-cli shutdown``
    > 
### 2. Redis相关知识
2. Redis相关知识
    > 1. Redis默认端口6379
    > 
    > 2. Redis默认16个数据库，从0开始，默认使用第0号数据库，一般也不会使用别的库。登录客户端后，可以使用```select 数据库编号```切换数据库
    > 
    > 3. Redis实行统一密码管理，所有用户都是相同密码，要么都连接上要么都无法连接。
    > 
    > 4. **Redis是单线程+多路IO复用技术**
    > 
    >     * Memcached和Redis的第三个区别：Memcached是多线程+锁；Redis是单线程+多路IO复用
    >     
### 3. Redis数据类型
3. Redis数据类型
    > 1. Redis是key-value模式，但是value可以有五种类型
    > 
    > 2. Redis数据类型五种数据类型：string, list, set, hash, zset
    > 
### 4. Redis几个简单命令
4. Redis几个简单命令
    > 1. Redis简单命令
    > 
    >     * 查询当前数据库所有的键：```keys *```
    >     
    >     * 查询数据库是否有某个键：```eixts 键名```
    >     
    >     * 查询某个键对应的值类型：```type 键名```
    >     
    >     * 根据键名删除某个键值对：```del 键名```
    >     
    >     * 给某个键值设置过期时间：```expire 键名 过期时间（秒为单位）```。过期之后Redis不会立即删除，只是无法使用了。可以用来做手机号验证、秒杀等
    >     
    >     * 查看一个键值的过期时间：```ttl 键名```。-1代表永不过期，-2代表已经过期，正数代表还有多少秒过期
    >     
    >     * 查看当前数据库所有的key数量：```dbsize```
    >     
    >     * 清空当前数据库：```flushdb```
    >     
    >     * 清空所有的数据库：```flushall```
    >     
### 5. 原子操作
5. 原子操作
    > 1. 原子操作
    > 
    >     1. 介绍
    >     
    >        原子操作指的是不会被线程调度机制打断的操作
    >        
    >        单线程中，任何的单个指令都是原子操作，因为打断只可能发生在指令之间
    >        
    >        多线程中，任何不被其他线程打断的操作，叫原子操作
    >        
    >     2. **因为Redis是单线程的，因此Redis的单个命令，都是原子操作**
    >     
    >     3. 思考：java中的i++是否为原子操作？
    >     
    >        java中i++不是原子操作
    >        
    >        因为java是多线程的，i++做了三次指令操作，两次内存访问，第一次，从内存中读取i变量的值到CPU的寄存器，第二次在寄存器中的i自增1，第三次将寄存器中的值写入内存。这三次指令操作中任意两次如果同时执行的话，都会造成结果的差异性。
    > 
### 6. Redis中key如何设计
6. Redis中key如何设计
   
    > 1. Redis中，我们要保证设计的key都独一无二，否则会有覆盖重写的风险。因此我们一般使用```xxx:xxx:xxx```这样的格式，来设计key
### 7. Redis的数据结构：key-value模式中，value的类型
#### 1. string
1. string
    > 1. string
    > 
    >     1. 介绍
    >     
    >        string是最基本的类型，也是使用最频繁的类型
    >        
    >        string结构代表单键单值，值为字符串。
    >        
    >        string是二进制安全的类型，意思是Redis中的string类型可以存储任何数据，比如序列化的对象、jpg图片
    >        
    >     2. 操作string类型的命令
    >     
    >         * ```get 键```：查询键对应的值
    >         
    >         * ```set 键 string值```：设置string键值对
    >         
    >         * ```append 键 追加的string值```：往给定的string键值对的值末尾追加字符
    >         
    >         * ```strlen 键```：获取键对应的值的长度
    >         
    >         * ```setnx 键 string值```：只有在键不存在时，设置键值对。键存在没有效果，不存在则设置键值
    >         
    >         * ```incr 键```：数字值自增。将键对应的数字string自增1。如果为空，则新增值为1。只对数字string有效，否则报错。
    >         
    >         * ```decr 键```：数字值自减。将键对应的数字string自减1。如果为空，则新增值为1。
    >         
    >         * ```incrby 键 步长```：自定义数字值自增/自减步长。将键对应的数字string自增步长的值；```decrby 键 步长```，将键对应的数字string自减步长的值。
    >         
    >         * ```mset 键1 string值1 键2 string值2 ...```：批量设置键值对
    >         
    >         * ```mget 键1 键2 ...```：批量获取键对应的值
    >         
    >         * ```msetnx 键1 string值1 键2 string值2 ...```：当设置的键**全都**不存在时，批量设置键值对。任意一个键存在，不会执行
    >         
    >         * ```getrange 键 起始位置 结束位置```：获取键对应的值中，从起始位置包括起始位置，到结束位置包括结束位置的值。类似于java中的substring。位置从0开始计计算，从起始到结束```getrange 键 0 -1```
    >         
    >         * ```setrange 键 起始位置 string值```：给键对应的值中，从起始位置开始包括起始位置，覆写一段string值。位置从0开始计算
    >         
    >         * ```setex 键 过期时间 string值```：设置键值，同时设置过期时间，以秒为单位。
    >         
    >         * ```getset 键 新string值```：以新换旧。获取键对应的旧string值，同时设置新string值
    >         
#### 2. list
2. list
    > 1. 介绍
    > 
    >    list结构代表单键多值。多个值都是字符串
    >    
    >    Redis的list结构底层使用的是双向链表，因此对两端操作效率很高，但是通过索引对中间节点操作性较差 
    >    
    > 2. 操作list类型的命令
    > 
    >     * ```lpush 键 string值1 string值2 ...```：对键对应的list，从左边（头部）插入一个或多个值；```rpush 键 string值1 string值2 ...```：对键对应的list，从右边（尾部）插入一个或多个值
    >     
    >     * ```lpop 键```：对键对应的list，从左边（头部）弹出一个值 ；```rpop 键```：对键对应的list，从右边（尾部）弹出一个值
    >     
    >     * ```rpoplpush 键1 键2```：键1对应的list，右边（尾部）弹出一个值，插入键2对应的list左边（头部）
    >     
    >     * ```lrange 键 起始位置 结束位置```：查看键对应的list中，从起始位置，到结束位置的值。位置从0开始计算。从起始到结束，```lrange 键 0 -1```
    >     
    >     * ```lindex 键 索引```：查看键对应的list中，对应索引的值。索引从0开始计算，-1表示最后
    >     
    >     * ```llen 键```：查看键对应的list长度
    >     
    >     * ```linsert 键 before 原有的string值 新string值```：在键对应的list中，原有的string值前面，插入新string值；```linsert 键 after 原有string值 新string值```：在键对应的list中，原有的string值后面，插入新string值
    >     
    >     * ```lrem 键 n个 string值```：在键对应的list中，删除n个对应的string值。n个，如果是正数，代表从左往右删除n个；如果是负数，代表从右往左，删除n个；如果是0，代表删除所有
    >     
#### 3. set
3. set
    > 1. 介绍
    > 
    >    set功能和list相似，但是set可以进行自动排重。当存储多个数据，但是不想存储相同数据时，set是很好的选择
    >    
    >    并且，set提供了判断某个成员是否在set中的重要接口，这个也是list没有的。例如我们可以通过该接口，做秒杀商品时，一个人是否多次秒杀的判断。
    >    
    >    Redis中set结构底层是个value为null的hash表，因此添加、删除、查找的复杂度都为O(1)
    > 2. set的命令
    > 
    >     * ```sadd 键 string值1 string值2 ...```：将一个或多个string值加入键对应的set中，重复元素自动忽略。
    >     
    >     * ```smembers 键```：获取键对应的set中全部元素
    >     
    >     * ```sismember 键 string值```：判断键对应的set中，是否有对应的string值。有返回1，没有返回0
    >     
    >     * ```scard 键```：获取键对应的set中，元素个数
    >     
    >     * ```srem 键 string值1 string值2 ...```：在键对应的set中，删除一个或多个元素
    >     
    >     * ```spop 键```：随机从键对应的set中弹出一个元素。可以用来实现抽奖
    >     
    >     * ```srandmember 键 n个```：随机从键对应的set中，取出n个元素。不会从set中删除这些值。
    >     
    >     * ```sinter 键1 键2```：获取键1的set、键2的set之间的交集。set特有的
    >     
    >     * ```sunion 键1 键2```：获取键1的set、键2的set之间的并集。set特有的
    >     
    >     * ```sdiff 键1 键2```：获取键1的set、键2的set之间的差集。即键1的set，减去键1、键2的set的交集，键1的set剩下的元素。set特有的
    >     
#### 4. hash
4. hash
    > 1. 介绍
    > 
    >    hash类型，就是键值对的集合。hash类型特别适合存储对象
    >    
    >    类似于```Map<String, String>```
    >    
    > 2. hash的命令
    > 
    >     * ```hset 键 字段 值```：给键对应的hash中，一个字段，赋值
    >     
    >     * ```hget 键 字段```：从键对应的hash中，取出字段对应的value
    >     
    >     * ```hmset 键1 字段1 值1 字段2 值2 ...```：给键对应的hash中，多个字段，赋值
    >     
    >     * ```hexists 键 字段```：判断键对应的hash中，字段是否有值
    >     
    >     * ```hkeys 键```：列出键对应的hash中，所有的字段
    >     
    >     * ```hvalues 键```：列出键对应的hash中，所有的值
    >     
    >     * ```hincrby 键 字段 追加的值```：给键对应的hash中，一个字段对应的值，追加值。必须保证字段对应的值是数字string值，追加的值也是数字string值。可以追加正数值，负数值，0值
    >     
    >     * ```hsetnx 键 字段 值```：只有键对应的hash中字段不存在。给键对应的hash中，一个字段，赋值
    >     
    >     * ```hgetall 键```：获取键对应的hash中，所有的字段和值
    >     
#### 5. zset
5. zset
    > 1. 介绍
    > 
    >    Redis中最复杂的数据类型
    >    
    >    zset和set相似，但是zset可以保证有序
    >    
    >    zset有序是通过zset中，每个成员关联了一个score，根据score的从低到高来对zset排序
    >    
    >    zset中，成员不允许重复，但是score可以重复
    >    
    >    因为zset有序，因此可以很快的根据score或者次序来获取元素，同时访问zset中间元素也是很快的。所以可以使用zset做一个没有重复成员的智能列表。
    >    
    >    zset类似于java中的HashMap，以元素为HashMap中的key，以score为HashMap中的value。
    >    
    > 2. zset的命令
    > 
    >     * ```zadd 键 score1 元素1 score2 元素2 ...```：将一个或多个元素和其对应的score，存进键对应的zset中
    >     
    >         * 添加有四种情况：
    >         
    >             1. 不同的score和不同的值：按照score排列值
    >             
    >             2. 不同的score和相同的值：会替换值对应的score
    >             
    >             3. 相同score和不停的值：相同的score的值，会随机排列
    >             
    >             4. 相同score和相同的值：无法添加
    >     
    >     * ```zrange 键 开始 结束 [withscores]```：获取键对应的zset中，索引从开始包括开始到结束包括结束的元素。带withsocres会将score也查询出来。索引从0开始计算。
    >     
    >        查询全部只需``zrange 键 0 -1```。
    >        
    >        查询单个元素，只需要保证开始和结束索引相同即可
    >     
    >     * ```zrangebyscore 键 最小值 最大值 [withscores]```：获取键对应的zset中，score从最小值包括最小值到最大值包括最大值的元素。带withsocres会将score也查询出来。
    >     
    >        查询全部只需```zrangebyscore ```
    >        
    >        查询单个元素，只需要保证最小值和最大值相同即可
    >        
    >     * ```zrevrangebyscore 键 最大值 最小值 [withscores]```：获取键对应的zset中，score从最大值包括最大值到最小值包括最小值的元素，同时保证按照score从大到小排列展示。带withsocres会将score也查询出来。
    >     
    >     * ```zincrby 键 增量 元素```：为键对应的zset中，元素的score，添加增量。增量可以负数值，正数值，0值。
    >     
    >     * ```zrem 键 值```：删除键对应的zset中，元素
    >     
    >     * ```zcount 键 最小值 最大值```：统计该键对应的zset中，score在[最小值, 最大值]中，score最大的元素个数
    >     
    >     * ```zrank 键 元素```：统计该键对应的zset中，元素的排名。排名从0开始计算。
    >     
    > 3. 可以利用zset实现：访问量排行榜、热度排行等
    > 
## 5. Linux的Redis相关配置
5. Linux的Redis相关配置
    > 1. 打开备份过的redis配置：/myredis/redis.conf
    > 
    > 2. include：默认没有或者注释掉 
    > 
    >    include可以引入别的Redis配置文件
    >    
    >    在公共Redis配置文件中，引入特殊的Redis配置文件，达到个性化配置的目的
    >    
    > 3. bind：ip地址的绑定。默认绑定127.0.0.1
    > 
    >    用于绑定允许访问该Redis的服务器ip
    >    
    >    默认绑定127.0.0.1，即只允许本服务器访问
    >    
    >    生产环境中，要绑定应用服务器ip
    >    
    >    不写，无限制接收任何服务器的访问
    >    
    >     * 如果不写bind绑定或者注释掉bind，则Redis会去看配置文件中的protected-mode，如果protected-mode yes，则在没有设置Redis密码的情况下，仍然只允许本服务器访问。
    >    
    > 4. tcp-backlog
    > 
    >    可以理解为一个请求到达后，到接收进程处理前允许的请求队列
    >    
    >    tcp-backlog=未三次握手队列 + 已三次握手队列
    >    
    >    高并发环境下，tcp-backlog设置的值，由超时时限内Redis的吞吐量决定
    >    
    > 5. timeout
    > 
    >    决定空闲客户端多少秒后自动关闭。0代表永不关闭
    >    
    > 6. TCP keepalive
    > 
    >    对于访问客户端的一种心跳检测，每隔n秒检测一次。
    >    
    >    官方推荐设置60秒
    >    
    > 7. daemonize
    > 
    >    是否为后台进程。可以设置yes/no
    >    
    > 8. pidfile
    > 
    >    存放pid文件位置，每一个实例会产生一个不同的pid文件
    >    
    > 9. loglevel
    > 
    >    四个级别。根据使用阶段来选择，从上而下级别越来越高，日志记录信息越来越少
    >    
    >    生产环境设置为notice或warning
    >    
    > 10. logfile
    > 
    >    日志文件名称
    > 
    > 11. syslog
    > 
    >    是否将Redis的日志信息输送到Linux系统日志服务中
    > 
    > 12. syslog-ident
    > 
    >    日志的标志
    > 
    > 13. syslog-facility
    > 
    >    输出日志的设备
    > 
    > 14. database
    > 
    >    设置数据库数量，默认16个。
    > 
    >    一般只会用到第0个。
    > 
    > 15. security
    > 
    >    设置密码
    > 
    > 16. maxclient
    > 
    >    设置客户端最大连接数量
    > 
    > 17. maxmemory
    > 
    >    设置Redis可以使用的最大内存量。
    > 
    >    一旦达到了最大内存量，Redis会试图移除内部数据，移除规则可以通过maxmemory-policy设置。
    > 
    >    如果达到了最大内存狼，Redis无法移除内部数据，或者设置了不许移除，则Redis会对需要申请内存的指令返回错误信息，例如对于set，lpush等命令
    > 
    > 18. maxmemory-policy：设置移除规则。可选规则如下
    > 
    >     * volatile-lru：LRU算法移除，最少使用原则，只对设置了过期时间的键有效
    >     
    >     * allkeys-lru：使用LRU算法移除，最少使用原则，针对所有键
    >     
    >     * volatile-random：在过期的集合中移除随机的key，只针对设置了过期时间的键
    >     
    >     * allkey-random：移除随机的key
    >     
    >     * volatile-ttl（即将过期）：移除那些TTL最小的key，即即将过期的key
    >     
    >     * noeviction：不进行移除。针对写操作，返回错误信息
    >     
    > 19. maxmemory-samples
    > 
    >    设置样本数量。设置后，如果要移除数据，会先按样本取值，然后继续比较样本，删除应该移除的数据。这样做比LRU算法和TLL算法要精确
    > 
    >    样本数量一般设置在3~7之间，数据越小越不准确，但是性能消耗越小
    >
## 6. java连接Redis
6. java连接Redis
    > 1. java使用Jedis连接Redis，控制Redis客户端
    >
    > 2. 使用Jedis步骤
    >
    >     1. 导入Jedis的jar包。使用Maven导入依赖：
    >       
    >         ```
    >         <dependency>
    >         	<groupId>redis.clients</groupId>
    >             <artifactId>jedis</artifactId>
    >             <version>2.7.1</version><!--版本号可根据实际情况填写-->
    >         </dependency>
    >         <dependency>
    >             <groupId>org.apache.commons</groupId>
    >             <artifactId>commons-lang3</artifactId>
    >             <version>3.3.2</version>!--版本号可根据实际情况填写-->
    >          </dependency>
    >         ```
    >        
    >     2. 使用Jedis连接Redis。
    >       
    >         ```
    >         // 连接服务器下的Redis。Redis端口号6379
    >         Jedis jedis = new Jedis("Redis所在服务器IP", 端口号）);
    >         // 可以使用ping()方法，如果返回字符串"PONG"，则连通
    >         ```
    >        
    >     3. 使用Jedis
    >     
    >     4. 关闭Jedis
    >     
    >         ```
    >         jedis.close();
    >         ```
    >     
    > 3. Jedis操作Redis中的数据结构，使用和Redis中命令同名的方法。例如```jedis.set("a", "a");```
    >
    > 4. 使用Jedis，完成简单的手机验证码验证：参见D:\IDEAHome\verify
    > 
    >    要求：1、输入手机号，点击发送后随即生成6位数字验证码，2分钟有效；2、输入验证码，点击验证，返回true或不返回；3、每个手机每天只能点击3次
    >    
## 7. Redis之事务
7. Redis之事务
    > 1. 介绍
    >
    >    Redis中事务和关系型数据库中的事务不同，而且没有关系型数据库中事务的ACID特性。  
    >    Redis中事务，是一个单独的隔离操作：事务中所有的命令都会序列化，按顺序执行。事务在执行过程中，不会被其他客户端发送来的命令所打断。
    >    
    >    **Redis中事务本质，就是串联一些命令，防止别的命令插队。更像一种批量执行命令的操作**
    >    
    > 2. Redis中事务命令
    >
    >     1. ```multi```：输入multi开启事务，之后输入的命令都会进入命令队列，但不会执行。
    >     2. ```discard```：输入discard取消事务，释放命令队列。
    >     
    >     3. ```exec```：输入exec执行事务，将命令队列中的命令依次执行。
    >     
    > 3. 事务的错误处理
    >
    >    如果组队时某个命令报告错误，则执行时取消整个队列
    >    
    >    如果执行时某个命令出现错误，则只要出错的命令不会执行，其他命令照常执行，不会回滚。
    >    
    > 4. Redis事务开启前，可以对键进行监视
    >
    >     1. ```watch 键1 [键2] [键3] [...]```：Redis在调用multi开启事务前，可以使用watch对键进行监视，如果在exec执行事务前，被监视的键被其他命令改动，那么事务将被打断，命令队列被取消。
    >     
    >     2. ```unwatch```：取消对所有监视的键的监视。如果执行过exec或discard，就不用执行unwatch了
    >     
    > 5. Redis事务的三特性
    > 
    >     1. 单独的隔离操作：事务中的命令都会序列化，然后依次执行，事务执行过程中不会被其他命令打断。
    >     
    >     2. 没有隔离级别的概念
    >     
    >     3. 不保证原子性：Redis中同一个事务中，一个命令执行失败其他事务也会执行，没有回滚，因此不保证原子性。
    >     
    > 6. Redis事务完成秒杀案例：参见D:\IDEAHome\seckill
    > 
    >     * 题外话：解决maven控制台出现乱码情况，maven默认环境为jdk,只需要在IDEA中，打开File | Settings | Build, Execution, Deployment | Build Tools | Maven | Runner在VM Options中添加-Dfile.encoding=GBK，
    > 
    >     * 秒杀案例，解决超卖问题：该方式并不是实际中秒杀解决方式。实际中，我们使用lua脚本解决秒杀
    >     
    >        由于高并发时，可能会有多个用户同时点击，导致库存同时变少。
    >        
    >        因此，1、我们将秒杀的操作加入事务。2、我们可以使用watch监视库存，一旦有一个访问用户秒杀成功，其他准备操作库存在并发全部取消，保证高并发情况下，多个请求同时操作库存，只有一个请求可以秒杀成功。
    >        
    >     * 秒杀案例，解决库存遗留问题：
    >     
    >        上述通过监视和事务，解决了超卖问题。但是上述解决方案会导致，多个请求同时访问，只有一个能成功，高并发结束后，秒杀库存中还会有遗留的商品。
    >        
    >        我们可以使用Redis的链接池来解决该问题
    >     
    > 7. Redis链接池
    > 
    >     1. 好处
    >     
    >        节省每次连接redis服务带来的消耗，把连接好的Jedis反复使用
    >        
    >     2. 连接池
    >     
    > 8. LUA脚本
    > 
    >     1. 介绍
    >     
    >        LUA脚本可以被C/C++调用，也可以调用C/C++的函数。它很小巧，因此无法作为开发独立应用程序的语言，但是可以作为其他应用程序的嵌入语言
    >       
    >     2. LUA脚本在Redis中的优势
    >     
    >        1、把复杂的或者多步Redis操作，写为一个脚本，一次提交给Redis执行，减少反复连接Redis次数，提升性能
    >        
    >        2、LUA脚本类似于Redis中的事务，有一定的原子性，不会被其他命令插队，可以完成一些Redis事务性的操作
    >        
    >        3、**注意：Redis的lua脚本功能只在2.6以上版本可用**
    >    
    > 9. 可以使用ab工具模拟高并发。在centOS7中需要手动安装，通过```yum install httpd-tools```
    > 
    >     * ab工具使用：通过命令使用
    > 
    >        ```ab -n请求数 -c 并发数 -p 指定请求数据文件地址 -T "application/x-www-form-urlencoded" 测试的请求```。
    >        
## 8. Redis持久化
8. Redis持久化
    > 1. 介绍
    >
    >    Redis提供了两种不同形式的持久化方式。RDB和AOF
    >    
    > 2. RDB（RedisDataBase）
    >
    >     1. 介绍
    >
    >        在指定的时间间隔，将内存中数据集的快照（就是数据）写入磁盘。也就是常说的Snapshot快照，它恢复时是将快照文件重新读进内存
    >        
    >     2. 备份如何执行？
    >
    >        Redis单独创建(fork)一个子线程，专门用来持久化。先将数据写入临时文件，等持久化结束后，用临时文件替换上次持久化的文件。因为这个过程主进程不进行任何IO操作，因此确保了极高的效能
    >        
    >        如果要大规模恢复数据，且对数据的完整性不是特别敏感，用RDB方式更加高效
    >
    >     3. fork
    >
    >        在Linux中，fork会产生一个和父进程完全相同的子进程，但是子进程在此后多会exec系统调用。
    >        
    >        处于效率考虑，Linux中引入了“写时复制”技术：一般情况父进程和子进程使用同一块物理内存，只有进程空间内容的各段内容，将要发生变化时，将父进程内容复制给子进程。即需要写时，才复制内容给子进程。
    >        
    >     4. RDB持久化文件的名称和路径，在配置文件中可以查看和修改
    >
    >        redis配置文件中，```dbfilename```后面是rdb方式保存文件的文件名。```dir```后面是文件保存路径
    >
    >        默认rdb保存文件名为dump.rdb，默认保存位置为./即在哪开启redis就保存在该目录下。
    >
    >        默认保存位置不好，我们手动设置一个保存路径，例如：/myredis/save
    >        
    >     5. 可以在配置文件中，查看或更改RDB的保存策略
    >     
    >        在配置文件中，```save```后边就是保存策略  
    >        
    >     6. RDB的优点和缺点
    >     
    >         * 优点：因为RDB保存的是数据文件，因此节省磁盘空间，同时恢复速度也快
    >         
    >         * 缺点：数据庞大时还是比较消耗性能。在备份周期隔一段时间做一次备份，如果Redis意外down掉，就会丢失最后一次快照的数据。
    >
    > 3. AOF（AppendOfFile）
    >
    >     1. 介绍
    >     
    >        AOF会以日志的形式记录每一个写操作，将Redis执行过程中的所有写指令记录（读指令不记录），只需追加文件不许修改文件。
    >        
    >        Redis启动时，读取改文件重构数据。换言之，Redis重启就是根据日志文件内容将写指令从前往后执行一次以完成数据的恢复
    >        
    >     2. AOF默认不开启，需要手动在配置文件配置
    >     
    >        ```appendonly```后边就是是否开启AOF，默认为no
    >        
    >     3. 可以在配置文件中修改AOF文件名称
    >     
    >        ```appendfilename```后就是AOF文件名称。默认"appendonly.aof"
    >        
    >     4. AOF文件路径和RDB文件路径相同
    >     
    >     5. AOF同步频率
    >     
    >        AOF同步频率也在配置文件中设置。在```appendfsync```后设置。
    >        
    >        同步频率有三种：每次写操作都更新AOF文件(always)，每秒更新AOF文件(eversec)，不主动同步交给操作系统(no)。默认每秒同步(always)
    >        
    >     6. Rewrite
    >     
    >        AOF的重写机制。
    >        
    >        因为AOF每次都是追加写入AOF文件，因此文件会越来越大。当超过阈值，则Redis启动AOF文件的压缩，只保留文件中可以恢复数据的最小指令集。
    >        
    >        AOF重写机制具体步骤：和RDB相似，也会fork出一个子进程将文件重写。
    >        
    >        AOF重写要满足一定条件：因为AOF重写要消耗性能，因此要满足一些条件，条件写在Redis配置文件的```auto-aof-rewrite-percentage```和```auto-aof-rewrite-min-size```后
    >        
    >     7. AOF优点和缺点
    >     
    >         * AOF优点：备份机制更加健全，丢失数据概率更低。可读的日志文件
    >         
    >         * AOF缺点：占用更多磁盘空间。恢复备份速度慢。有一定读写压力。存在一些BUG导致无法恢复
    >     
    > 4. 如果同时开启RDB和AOF，Redis听谁的？
    >
    >    听AOF的
    >    
    > 5. 用哪个更好？
    > 
    >    官方建议RDB和AOF都使用。
    >    
    >    对数据不敏感，可以单独使用RDB
    >    
    >    不建议单独用AOF，因为有BUG
    >    
    >    单纯做内存缓存，可以都不使用
    >    
## 9. Redis主从复制
9. Redis主从复制
    > 1. 主从复制介绍
    >
    >    主从复制，针对于开启了多个Redis服务器而言的
    >    
    >    主从复制，就是从主服务器数据更新后，根据配置和策略，自动同步到从服务器的master/slaver机制，Master以写为主，Slaver以读为主。
    >    
    >    意思就是：应用写数据只写入主服务器。此时主服务器更新了数据。主服务器将数据复制给从服务器。应用读数据只从从服务器来读取。
    >    
    > 2. 主从复制的好处
    >
    >    读写分离，减少主服务器和从服务器的读写压力
    >    
    >    性能扩展
    >    
    >    容灾快速恢复
    >    
    >    * 其实读写分离后，写的服务器也可以读，但是读的服务器只能读
    >    
    > 3. Redis配置从服务器：不用配置主服务器，因为主服务器配置文件已经配好了
    >
    >     1. 拷贝多个redis.conf文件，include公共redis.conf
    >     
    >     2. 开启daemonize yes。公共redis.conf已经开启，不用写
    >     
    >     3. pid文件名字。可以不用配置
    >     
    >     4. 指定端口。必须配置
    >     
    >     5. 指定log。可以不用设置
    >     
    >     6. 修改RDB文件名字和地址。必须设置。
    >     
    >     7. 关闭AOF，或者开启AOF并修改AOF文件名字。公共redis.conf默认关闭，可以不用设置
    >     
    > 4. 因为我们当前就一个虚拟机，我们就在一个Linux上开启多个Redis服务器
    >
    > 5. 在Redis客户端中，输入```info replication```，打印主从信息
    >
    > 6. 在连接了从服务器的Redis客户端中，输入```slaveof 主服务器IP 主服务器端口```，即可让当前服务器成为从服务器，建立主从关系
    > 
    > 7. 主从复制的一些疑问
    > 
    >     1. 当使用```slaveof 主服务器IP 主服务器端口```建立主从关系后，当前这个从服务器掉线后，再次连接，是否还是从服务器？重新建立主从关系后，从服务器数据如何？
    >     
    >        掉线重连，不再是从服务器，需要重新使用```slaveof 主服务器IP 主服务器端口```建立主从关系
    >        
    >        重新建立主从关系后，从服务器数据仍然和主服务器当前数据保持一致
    >        
    >     2. 从服务器是否可以写？
    >     
    >        从服务器只读，不许写
    >        
    >     3. 主机down后如何？从机上位还是原地待命？
    >     
    >        主机关闭后，从机原地待命等待主机上线
    >        
    >     4. 主机down后上线，从机记录如何？
    >     
    >        从机记录和主机保持一致
    >        
    >     5. 综上，主从关系一旦建立，一定保持数据一致
    >     
    > 8. 使用```slaveof 主服务器IP 主服务器端口```建立的是临时主从关系，在从机down后会消失。因此，如果要建立永久主从关系，应该去从机的配置文件中，修改```slaveof 主机IP 主机端口```，即可建立永久主从关系。
    > 
    > 9. 主从复制原理（步骤）
    > 
    >     1. 从机建立主从关系后，给主机发送sync（synchronized）指令
    >     
    >     2. 主机接收到sync指令，发送RDB文件给从机
    >     
    >     3. 从机接收到RDB文件，根据RDB文件进行全盘加载
    >     
    >     4. 之后每次主机有写操作，都会立刻发送给从机，从机执行相同的指令
    >     
#### 1. 主从复制之薪火相传
1. 主从复制之薪火相传
    > 1. 介绍
    > 
    >    相当于链条状：A是主机，B是A从机，B从机可以是C服务器的主机；C同样也可以作为D服务器的主机。依次往下，是个链条。
    >    
    >    薪火相传一般使用```slaveof 主服务器IP 主服务器端口```建立主从关系，因为这样方便转向。
    >    
    > 2. 薪火相传好处
    > 
    >     1. 减轻A主机的写压力。因为B作为C主机，则B可以进行写操作，依次类推，直到最终的从机作为真正的从机。因此，A主机的写压力，由整个链条中，除了最后的从机的所有主机承担。
    >     
    >     2. 去中心化。当A主机down后，B可以作为新主机来使用。
    >     
    >         * 反客为主：让B作为新主机：在B主机的客户端写```slaveof no one```，即可去掉B从服务器身份，让B作为新主机
    >     
    > 3. 薪火相传坏处
    > 
    >    如果中间某个从机down了，后面的从机都没有备份了
    >    
#### 2. 主从复制之哨兵(sentinel)模式
2. 主从复制之哨兵(sentinel)模式
    > 1. 介绍
    >
    >    上述的反客为主操作的自动版
    >    
    >    哨兵模式不是基于薪火相传的，它用于普通的主从复制模式
    >    
    >    哨兵会监控主服务器，然后当主服务器down后，根据投票自动将一个从机转为主机
    >    
    > 2. 原理
    >
    >    哨兵中有两种协议：留言协议和投票协议
    >    
    >    留言协议让哨兵根据从服务器反馈，判断主服务器是否正常
    >    
    >    投票协议让哨兵投票让一个从服务器作为新主服务器
    >    
    > 3. 配置哨兵
    >
    >     1. 调整成普通主从复制模式
    >
    >     2. 在/myredis目录下，新建sentinel.conf文件
    >
    >     3. 配置哨兵：在sentinel.conf文件中，填写 
    >
    >         ```
    >         sentinel monitor mymaster 127.0.0.1 6379 1
    >         ```
    >         
    >        * mymaster 为自定义的监控服务器名称，可以随意起名
    >        
    >        * 127.0.0.1 6379 为该哨兵监视的服务器IP和端口
    >        
    >        * 1 为至少有多少个哨兵认为主服务器宕机，算其为宕机。
    >     
    > 4. 启动哨兵
    >
    >    在Linux命令行中，执行```redis-sentinal 哨兵的配置文件路径```，即可启动哨兵
    >
    >    有几个配置文件，可以启动几个哨兵
    >
    > 5. 哨兵模式故障恢复的步骤
    > 
    >     1. 新主登基：选择一个从服务器作为主服务器，选择顺序为：
    >     
    >         1. 优先级靠前的
    >         
    >         2. 偏移量大的：偏移量是指获得原主服务器数据最多的
    >         
    >         3. runid最小的：每个redis客户端启动，都会分配一个40位的runid
    >     
    >     2. 群臣俯首：原来的从服务器自动作为新服务器的从服务器
    >     
    >     3. 旧主俯首：宕机的主服务器，作为如今新主服务器的从服务器
    >     
## 10. Redis集群
10. Redis集群
    > 1. 前言
    >
    >    主从复制，解决了Redis读写的压力问题，但是Redis内存压力问题还在。
    >    
    >    Redis存储数据在内存，那么容量不够时，如何进行扩容？
    >    
    >    并发写操作时，Redis如何分摊？
    >    
    > 2. 什么是Redis集群
    >
    >    Redis集群实现了对Redis的水平扩容，即启动N个Redis节点，将整个数据库分步存储在这N个节点，每个节点存储总数据的1/N
    >    
    >    Redis集群通过分区来提供一定程度的可用性（availablity），即使集群中有一部分节点失效或者无法通讯，集群也可以继续处理命令
    >    
    > 3. Redis集群演示
    >
    >     1. 安装集群环境：安装ruby环境
    >
    >        ```yum install ruby```
    >       
    >        ```yum install rubygems```
    >        
    >     2. 创建多个Redis配置文件，从而保证可以创建多个Redis实例。每个配置文件中需要写入：
    >     
    >         1. 拷贝多个redis.conf文件，include公共redis.conf
    >
    >         2. 开启daemonize yes。公共redis.conf已经开启，不用写
    >           
    >         3. pid文件名字。可以不用配置
    >
    >         4. 指定端口。必须配置
    >
    >         5. 指定log。可以不用设置
    >     
    >         6. 修改RDB文件名字和地址。必须设置。
    >
    >         7. 关闭AOF，或者开启AOF并修改AOF文件名字。公共redis.conf默认关闭，可以不用设置
    >         
    >         8. 打开集群模式：```cluster-enabled yes```
    >         
    >         9. 设置节点配置文件：```cluster-config-file nodes-该实例端口号.conf```
    >         
    >         10. 设置节点失联时间：```cluster-node-timeout 15000```，超过设置的失联时间（毫秒为单位），集群可以进行自动的主从转换
    >         
    >     3. 根据上述的配置文件，启动多个Redis实例。**同时确保node-xxx.conf生成正常**
    >     
    >     4. 合体：将多个实例合成一个集群
    >     
    >         1. 进入文件夹：```cd /opt/redis-3.2.5/src```
    >         
    >         2. 执行合体指令：注意，这些Redis实例的IP必须写成真实IP，不可以写成127.0.0.1
    >         
    >             ```
    >             ./redis-trib.rb create --replicas 1 Redis实例IP:端口 Redis实例IP:端口 Redis实例IP:端口 ...
    >             ```
    >         
    >     5. 合体完毕后。以集群方式进入Redis客户端：```redis-cli -c -p 端口号```。只需要使用一个Redis服务器的端口即可
    >     
    >     6. 以集群方式进入Redis客户端后，直接可以进行Redis中数据操作
    >        
    >     7. 以集群方式进入Redis客户端后，可以使用```cluster nodes```查看集群信息
    >     
    > 4. **一个集群，必须保证至少有三个主节点，三个从节点。因此至少要六台机器**
    > 
    > 5. 我们上面写的--replicas代表每个主节点，分配一个从节点。分配原则尽量保证，每个主数据库运行在不同的IP地址，每个从库和主库不在一个IP地址上
    > 
    > 6. 什么是slots
    > 
    >     1. slots，插槽
    >     
    >     2. 在集群成功后，我们可以看到，每个主节点都对应了一些slots
    >     
    >     3. 一个Redis集群中，包含了16384个插槽（hash slot），Redis数据库中每个键，都属于这16384个插槽其中之一。集群使用公式CRC16 % 16384来计算数据库中每个键对应哪个插槽，CRC16用于计算键的CRC16检验和
    >     
    >     4. Redis集群中，每个节点用于处理一部分的插槽。例如：一个集群中刚好可以有主节点，其中：
    >     
    >        节点A处理0号到5500号插槽
    >        
    >        节点B处理5501号到11000号插槽
    >        
    >        节点A处理11001号到16383号插槽
    >        
    >     5. 在每次登陆Redis客户端，录入、查询键值时，Redis会先计算出键应该送往的插槽。如果客户端对应的服务器中没有该插槽，会报错并告知应该前往的Redis实例地址和端口
    >     
    >     6. 使用了```redis -c -p 端口```登陆客户端，-c参数实现自动重定向
    >     
    >     7. 不在一个slot下的键值，无法使用mget和mset等多键操作
    >     
    >     8. 可以使用{}，来规定组的概念。对一个键后加{}，{}中写组名，则相同组对应的内容会放入同一个slot。例如：
    >     
    >        ```set a{user} a```、```set b{user} b```。键a和键b都是user组的，因此它们的内容放入同一个slot
    >     
    > 7. 集群中的一些疑问
    > 
    >     1. 主节点下线，从节点怎么办？
    >     
    >        主节点下线后，从节点自动升级为主节点
    >        
    >     2. 主节点恢复，主从关系如何？
    >     
    >        主节点恢复后，主节点变为从服务器
    >     
    >     3. 如果一段插槽的主从节点全部down掉，Redis服务还会继续吗？
    >     
    >        在Redis的公共配置文件中，有一个```cluster-require-full-coverage yes```，代表了16384个slot只有全部正常，Redis才会工作。
    >     
    > 7. Redis集群的好处
    > 
    >     1. 实现了扩容
    >     
    >     2. 分摊了读写压力和内存压力
    >     
    >     3. 无中心配置，相对简单
    >     
    > 8. Redis集群的不足
    > 
    >     1. 多键操作不支持
    >     
    >     2. 多键的Redis事务不支持
    >     
    >     3. LUA脚本不支持
    >        
    >     



