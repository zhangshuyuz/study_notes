# 1. Spring
1.  Spring框架
    > 1. 框架简介
    >
    >    具备约束性，帮助用户完成各种功能的半成品软件。
    >    
    > 2. Spring简介
    >
    >    经典整合性框架（又叫设计性框架），SpringMVC是Spring的升级模块，Spring中包含了SpringMVC。spring框架主要是为了帮助管理JavaBean的生命周期。
    >    
    >    **Spring核心：IOC(DI)和AOP，其中最核心为IOC**
    >    
    > 3. Spring优良特性
    >
    >     1. 非侵入性：即轻量级，具体表现为基于Spring开发的应用中的对象可以不依赖于Spring的API
    >     
    >     2. 依赖注入：DI--DependencyInjection，反转控制（IOC）思想的最经典实现
    >     
    >     3. 面向切片编程：AspectOrientedProgramming，AOP
    >     
    >     4. 容器：Spring是一个容器，包含并且管理应用对象的生命周期
    >     
    >     5. 组件化：Spring实现了使用简单的组件配置组合成一个复杂应用。在Spring中可以使用XML和Java注解组合这些对象
    >     
    >     6. 一站式：在IOC和AOP基础上可以整合各种企业应用的开源框架和优秀的第三方类库（实际上Spring自身也提供了表述层的SpringMVC和持久层的SpringJDBC）
    >     
    > 4. 导入jar包（包括spring的jar包和日志的jar包）
    >
    > 5. spring配置文件：默认spring配置文件位置和文件名为：```WEB-INF/applicationContext.xml```
    >
    >      1. --conf文件夹：applicationContext.xml文件内配置
    >        
    >      2. 配置文件内：
    >
    >          1. ```<bean>```标签：管理JavaBean
    >          
    >              ```
    >              <bean class="类的全类名"></bean>
    >              ```
    >              2. ```<bean>```标签内部可以定义```<property>```标签，用于管理JavaBean的属性
    >                  ```
    >                  <bean class="com.yuu.spring.mod.Person" id="person">
    >         <!--注意：必须有get和set方法的属性才能调用property标签-->
    >                 <property name="id" value="30"></property> 
    >              <property name="name" value="zhangsan"></property>
    >                  </bean>
    >                 ```
    >                 
## 1. IOC容器和Bean配置
1. IOC容器和Bean配置
    > 1. IOC和DI
    >
    >     1. IOC(Inversion of Control)：反转控制
    >     
    >         1. 简介
    >         
    >         	 IOC(Inversion of Control)可以用来减低计算机代码之间的耦合度。IOC可以认为是一种全新的设计模式，是一种思想。
    >         	
    >         	 IOC可以理解为：正常控制为，我用电饭锅做饭，电饭锅把饭递出来；反转控制，电饭锅自动做饭，我直接接收饭来吃。
    >         	
    >         	 spring使用了IOC，它让我们将对JavaBean的控制反转给程序本身管理，我们只需要使用JavaBean对象，而不关心对象何时创建，何时销毁。
    >         
    >     2. DI(Dependency Injection)：依赖注入
    >     
    >         1. 简介 
    >         
    >            是IOC思想的一种表述方式，即：组件以一些预先定义好的方式来接收来自于容器的资源注入（赋值）。
    >            
    >            DI可以看做是IOC的实现方式之一。
    >     
    > 2. Bean配置
    >
    >     1. 配置位置
    >     
    >         在conf/applicationContext.xml中配置。applicationContext是spring加载配置文件时，默认的配置文件名称
    >         
    >     2. 配置详情
    >     
    >         ```
    >         <!--    在使用getBean()方法，参数传入String时，需要通过id来判断；使用getBean()方法，参数传入类.class字节码时，可以不需要设置id-->
    >             <bean class="com.yuu.spring.mod.Person" id="person">
    >         <!--        注意：必须有get和set方法的属性才能调用property标签-->
    >                 <property name="id" value="30"></property>
    >                 <property name="name" value="zhangsan"></property>
    >             </bean>
    >         
    >             <bean class="com.yuu.spring.mod.Person" id="person2">
    >                 <property name="id" value="100"></property>
    >                 <property name="name" value="lisi"></property>
    >             </bean>
    >         ```
    >         
    >     3. ```ApplicationContext```
    >     
    >         1. 简介
    >         
    >            spring容器对象
    >            
    >         2. 获取
    >         
    >             ```
    >             ApplicationContext ac = new ClassPathXmlApplicationContext("spring配置文件地址");
    >             ```
    >             
    >         3. 通过spring容器获取JavaBean对象
    >         
    >             ```
    >             getBean() -- ApplicationContext对象的获取JavaBean的方法
    >             getBean()方法有三个重载：
    >             getBean(String id) -- 通过配置文件定义的id获取对象
    >             getBean(Class<T> args) -- 通过类.class获取该类的对象
    >             getBean(String id, Class<T> args) -- 通过id和类.class获取该类的对象。该方法是最推荐的方式。
    >             ```
    >         
    >     4. 异常
    >     
    >         1. 当我们在xml中配置了多个相同对象，用getBean()方法传入类.class为参数时，会出异常：```org.springframework.beans.factory.NoUniqueBeanDefinitionException```。**用getBean()方法传入类.class为参数时，必须保证spring仅维护了一个该类的对象**   
    >         2. org.springframework.beans.factory.NoSuchBeanDefinitionException表示：配置文件中没有对应的对象
    >         
    >         3. **Spring看异常只需要看最后的异常，最后的一定是最根本的错**
    >         
    >     5. spring如何通过配置管理JavaBean？
    >     
    >        根据经验，写了全类名就很可能和反射有关。因此，spring从配置中加载bean标签，再通过反射创建对象。
    >        
    >        我们知道，通过反射创建对象是调用newInstance()方法，而spring通过反射创建对象就是调用的newInstance()方法。
    >        
    >        因此我们必须保证类中有无参构造，如果类中没有构造，则默认有一个无参构造，但是如果有带参构造，则会覆盖默认的无参构造。因此，**交给spring管理的类，要么不写构造，要么必须写无参构造**
    >        
    >     6. ApplicationContext的实现类
    >     
    >         * 查看spring源码可知：
    >     
    >            BeanFactory接口下，ApplicationContext接口继承了BeanFactory。ApplicationContext接口下，有两个实现类实现了ApplicationContext，一个ClassPathXmlApplicationContext和FileSystemXmlApplicationContext。**ClassPathXmlApplicationContext类用于当前项目下的加载；FileSystemXmlApplicationContext类用于文件服务器上配置文件的加载。即ClassPathXmlApplicationContext类参数写相对路径；FileSystemXmlApplicationContext类书写绝对路径**
    >         
    >     7. ConfigurableApplicationContext接口
    >     
    >         * ConfigurableApplicationContextt接口：ApplicationContext接口的子接口。是对ApplicationContext接口功能的扩展
    >         
    >         * ConfigurableApplicationContext接口扩展的功能：
    >         
    >             1. refresh() -- 刷新
    >             
    >             2. close() -- 关闭
### 1. 给Bean属性赋值
1. 给Bean属性赋值
    > 1. 依赖注入方式
    >
    >     1. 通过类中的```setXxx()```方法进行赋值：```<bean>```标签中的```<property>```标签注入。该方式是一般公司中最常用的
    >     
    >         ```
    >         <bean class="com.yuu.spring.mod.Person" id="person1">
    >         <property name="id" value="30"></property>
    > </bean>
    >         ```
    >         
    >         * **注意：该方法赋值，只看类中是否有```<property>```标签的name属性对应的```setXxx()```方法。**
    >         
    >     2. 通过类的构造方法进行赋值：```<bean>```标签中的```<construct-arg>```标签注入
    >         ```
    >         <bean class="com.yuu.spring.mod.Person" id="person3">
    >         <!--        index代表索引，value代表值，ref代表引用，name代表参数名，type代表类型-->
    >                 <constructor-arg value=""></constructor-arg>
    >         </bean>
    >         ```
    >         
    >         * **使用该方式赋值，必须要保证类中有相应参数的构造方法**
### 2. p命名空间
2. p命名空间
    > 1. 介绍
    > 
    >    spring2.5后出现。用来简化```<bean>```中```<property>```标签的。
    >    
    > 2. 使用
    > 
    >     1. 引入p命名空间：在```<beans>```中引入
    >     
    >         ```
    >         xmlns:p="http://www.springframework.org/schema/p"
    >         ```
    >         
    >     2. 在```<bean>```标签中直接使用
    >     
    >         ```
    >         <bean id="person3" class="com.yuu.spring.mod.Person" p:id="30" p:name="wangwu"></bean>
    >         ```
    >         
### 3. 可以使用的值
3. 可以使用的值
    > 1. 字面量：可以使用String表示的值，通过value属性或者value子节点指定。包括基本数据类型、基本数据类型的包装类、String。若字面值中包含特殊字符，可以使用CDATA块包裹特殊字符。
    >
    > 2. 引用：通过ref属性指定，指定一个当前spring管理的JavaBean的id。同理p命名空间的p:xxxx-ref就是设置引用类型值的，该值一定是当前spring管理的JavaBean的id
    >
    >     ```
    >     <bean id="student1" class="com.yuu.spring.mod.Student">
    >         <property name="name" value="zhaoliu"></property>
    >         <property name="id" value="101"></property>
    >         <property name="teacher" ref="teacher1"></property>
    >     </bean>
    >     
    >     <bean id="teacher1" class="com.yuu.spring.mod.Teacher">
    >         <property name="name" value="teacherMa"></property>
    >         <property name="id" value="01"></property>
    >     </bean>
    >     ```
    >     
    > 3. 内部bean
    >     1. 介绍
    >     
    >        定义在一个Bean中的Bean，如:
    >        
    >         ```
    >         <bean id="student1" class="com.yuu.spring.mod.Student">
    >                <property name="name" value="zhaoliu"></property>
    >                <property name="id" value="101"></property>
    >                <property name="teacher">
    >                    <bean id="teacher2" class="com.yuu.spring.mod.Teacher">
    >                        <property name="name" value="teacherMa"></property>
    >                        <property name="id" value="01"></property>
    >                    </bean>
    >                </property>
    >            </bean>
    >         ```
    >        
    >     2. 区别
    >        内部Bean和正常Bean区别：内部Bean定义在哪个Bean中，就只属于哪个Bean，其他的Bean或者spring容器都无法直接访问该Bean。例如其他的Bean想用ref引用其他Bean中内部Bean的id，无法引用
    >     
    > 4. 集合属性
    >
    >     1. 通过spring提供的各种```<list>```、```<array>```、```<map>```等标签进行赋值
    >     
    >          ```
    >          <bean id="teacher1" class="com.yuu.spring.mod.Teacher">
    >                  <property name="name" value="teacherMa"></property>
    >                  <property name="id" value="01"></property>
    >                  <property name="cls">
    >                      <list>
    >                          <value>a</value>
    >                          <value>b</value>
    >                          <value>c</value>
    >                      </list>
    >                  </property>
    >          </bean>
    >          ```
    >          
    >          ```
    >          <property name="cls">
    >                      <array>
    >                          <value>1</value>
    >                          <value>1</value>
    >                          <value>1</value>
    >                      </array>
    >                  </property>
    >          ```
    >          
    >          ```
    >          <property name="cls">
    >                      <map>
    >                          <entry>
    >                              <key>
    >                                  <value>1</value>
    >                              </key>
    >                              <value>1</value>
    >                          </entry>
    >                      </map>
    >                  </property>
    >          ```
    >          
    >      2. 让spring管理一个集合对象，用ref引用的方式引入集合。要想让spring管理集合对象，需要先引入util命名空间```xmlns:util="http://www.springframework.org/schema/util"```，然后使用```<util:list>```等标签
    >     
    >          ```
    >          <bean id="teacher1" class="com.yuu.spring.mod.Teacher">
    >                  <property name="name" value="teacherMa"></property>
    >                  <property name="id" value="01"></property>
    >                  <property name="cls" ref="listStudents"></property>
    >          </bean>
    >          <util:list id="listStudents">
    >              <value>1</value>
    >              <value>2</value>
    >          </util:list>
    >          ```
    >          
    >      3. 集合元素如果为其他Bean对象，则使用list标签中的```<ref>```或```<bean>```标签
    >     
    >          ```
    >          <bean id="teacher1" class="com.yuu.spring.mod.Teacher">
    >                  <property name="name" value="teacherMa"></property>
    >                  <property name="id" value="01"></property>
    >                  <property name="studentList">
    >                      <list>
    >                          <ref bean="student1"></ref>
    >                          <bean id="student2" class="com.yuu.spring.mod.Student" p:id="01" p:name="zhansi" p:teacher-ref=""></bean>
    >                      </list>
    >                  </property>
    >              </bean>
    >          ```
    >     
    >      * **注意：如果一个类中成员变量取名为xXxx，例如sList，则自动生成的get和set方法是getsList()和setsList()，spring框架无法解析这两个方法。绝对禁止使用这种命名方式**
    >     
### 4. FactoryBean
4. FactoryBean
    > 1. 介绍
    >
    >    spring中有两种类型的Bean，一种普通的Bean，一种工厂Bean即FactoryBean
    >    
    >    FactoryBean是一个接口，使用了工厂模式，能帮助我们生产JavaBean。
    >    
    >    * 工厂模式：不在乎生产值的过程，只要使用工厂类中的方法来获取值即可。
    >    
    > 2. 使用
    >
    >     1. 创建一个类，实现FactoryBean，泛型规定生产的JavaBean类型
    >     2. 重写FactoryBean的三个抽象方法
    >     
    >         ```
    >         /**
    >              * 生产JavaBean
    >              * @return
    >              * @throws Exception
    >              */
    >             @Override
    >             public Car getObject() throws Exception {
    >                 return null;
    >             }
    >         @Override
    >             public Car getObject() throws Exception {
    >                 return null;
    >             }
    >         ```
    >         
    >         ```
    >         /**
    >              * 生产的JavaBean所属的类
    >              * @return
    >              */
    >         @Override
    >             public Class<?> getObjectType() {
    >                 return null;
    >             }
    >         ```
    >         
    >         ```
    >         /**
    >              * 是否为单例
    >              * true，是单例；false，不是单例
    >              * @return
    >              */
    >         @Override
    >             public boolean isSingleton() {
    >                 return false;
    >             }
    >         ```
    >         
    >     3. 在spring配置文件中配置工厂类
    >     
    >         ```
    >         <bean id="factory" class="com.yuu.spring.mod.MyFactory"></bean>
    >         ```
    >     
    >3. **工厂Bean的特点**
    >
    >    通过调用getBean()方法，传入工厂类的id为参数后，获取到的对象是工厂所创建的JavaBean的对象。
    >    
    >    原因是：我们定义的工厂类实现了FactoryBean接口，因此我们获取工厂类的对象和工厂类的字节码时，变成了获取工厂类生产的JavaBean对象和JavaBean的字节码。
    >    
    >     * 异常：使用getBean()，传入工厂类的id和工厂类类名.class会抛出：```org.springframework.beans.factory.BeanNotOfRequiredTypeException```异常，因此工厂类此时的字节码其实是工厂类生产的JavaBean的字节码，导致了这个异常。解决方法：只使用getBean()参数为id的方法即可。
    >    
    > 4. BeanFactory和FactoryBean
    > 
    >    BeanFactory是spring中原始的IOC容器接口，提供了最基本的IOC容器规范，例如ApplicationContext接口就是继承了BeanFactory接口
    >    FactoryBean是工厂类生产接口
    >    
### 5. spring默认JavaBean创建是单例模式
5. spring默认JavaBean创建是单例模式
    > 1. 经过验证可知，让spring管理的JavaBean，默认都是单例的
    >
    >     ```
    >     @Test
    >         public void test() {
    >             // 1. 初始化容器
    >             ApplicationContext ac = new ClassPathXmlApplicationContext("applicationContext.xml");
    >             // 2. 获取对象
    >             Car car1 = ac.getBean("car", Car.class);
    >             Car car2 = ac.getBean("car", Car.class);
    >             System.out.println(car1);
    >             System.out.println(car2);
    >         }
    >     ```
    >     
    >     ```
    >     // 打印结果如下
    >     com.yuu.spring.mod.Car@58e1d9d
    >     com.yuu.spring.mod.Car@58e1d9d
    >     ```
    >     
    > 2. 可以通过修改配置文件中```<bean>```中的scope属性为prototype达到多例。如果```<bean>```不写scope属性，就是默认的单例模式。
    > 
### 6. Bean作用域
6. Bean作用域
    > 1. Bean的作用域通过```<bean>```标签的scope属性来设置
    > 
    >     1. scope属性值有四种：
    >     
    >         * singleton：单例。
    >         
    >         * prototype：原型，即多例
    >         
    >         * request：请求。一次请求中
    >         
    >         * session：会话。一次会话中。
    >     
    > 2. 单例模式的Bean和原型模式的Bean创建时间
    >    
    >     * ```scope="singleton"```
    >       
    >        容器初始化时，就会创建。因为单例的对象永远只有一个，因此在容器初始化时，单例的对象就会被创建。
    >        
    >     * ```scope="prototype"```
    >       
    >        容器初始化时不创建，获取对象时创建。
    >            
### 7. Bean的生命周期
7. Bean的生命周期
    > 1. springIOC容器可以管理Bean的生命周期，让Bean在生命周期内的特定时间点执行特定的任务
    >
    > 2. springIOC对Bean生命周期管理过程，即Bean的默认生命周期：
    >
    >     1. 通过工厂或者构造器创建Bean实例
    >     
    >     2. 为Bean属性设置值和对其他Bean的引用
    >     
    >     3. 调用Bean的初始化方法
    >     
    >     4. Bean可以被使用
    >     
    >     5. **容器关闭时**，调用Bean的销毁方法。
    >     
    > 3. 如何让springIOC调用JavaBean中的初始化方法和销毁方法？
    >
    >    在配置文件中配置两个属性，init-method="初始化方法名"和destroy-method="销毁方法名"，这样，容器就会执行我们在JavaBean中写的初始化方法和销毁方法了。
    >    
### 8. Bean的后置处理器
8. Bean的后置处理器
    > 1. 介绍
    >
    >    Bean的默认生命周期只有五步，我们可能需要在原本的默认周期之间做些操作
    >    
    >    Bean的后置处理器可以延长Bean的默认生命周期，将原本的五步延长至七步
    >    
    >    Bean后置处理器是一个接口BeanPostProcessor，定义一个类实现该接口
    >    
    > 2. 作用
    >
    >    Bean的后置处理器允许：在调用**初始化方法的前后**对Bean进行额外操作。
    >    
    >    Bean后置处理器会对IOC容器中管理的所有Bean都逐一操作，而非只对单一的Bean操作
    > 3. 操作步骤
    >
    >     1. 定义一个类实现BeanPostProcessor
    >     
    >     2. 实现方法，一个用来处理初始化之前，一个用来处理初始化之后
    >     
    >         ```
    >         public class AfterHandle implements BeanPostProcessor {
    >             /**
    >              * 初始化之前处理bean
    >              * @param o bean
    >              * @param s beanName
    >              * @return
    >              * @throws BeansException
    >              */
    >             @Override
    >             public Object postProcessBeforeInitialization(Object o, String s) throws BeansException {
    >             	// 初始化之前处理bean逻辑
    >             	// 将处理后的bean返回
    >                 return o;
    >             }
    >         
    >             /**
    >              * 构造器之后处理bean
    >              * @param o bean
    >              * @param s beanName
    >              * @return
    >              * @throws BeansException
    >              */
    >             @Override
    >             public Object postProcessAfterInitialization(Object o, String s) throws BeansException {
    >             	// 初始化之后处理bean逻辑
    >             	// 将处理后的bean返回
    >                 return o;
    >             }
    >         }
    >         ```
    >         
    >     3. 将Bean后置处理器的类加入spring，让spring管理即可
    >     
    > 4. 无论spring管理的bean是否有初始化方法，bean后置处理器都会处理bean。
    >
### 9. 引用外部属性文件：使用properties资源文件
9. 引用外部属性文件：使用properties资源文件
   
    > 1. 介绍
    >
    >    当bean的配置信息变的越来越多时，查找与修改一些bean配置信息会变的困难。
    >
    >    这时可以将一部分信息提取到bean配置文件的外部，以properties格式将属性文件保存起来。
    >
    >    同时，bean配置文件中引用properties属性文件中的内容即可，从而实现一部分属性值发生变化时仅修改properties文件即可。
    >
    >    该技术一般用于连接数据库在spring的基本信息配置。
    >    
    > 2. 使用：例如管理druid数据库连接池
    >
    >     1. 导入Druidjar包和mysql数据库连接池jar包
    >     
    >     2. 创建一个新spring配置文件，用来管理数据库连接池的基本信息配置
    >     
    >     3.  引入外部属性文件：
    >     
    >         * 方式1、在spring配置中，配置一个spring中自带的类的bean，通过该类来加载；
    >     
    >             ```
    >         <!-- 方式1 -->
    >             <bean class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer">
    >                 <!--指定资源文件路径-->
    >                 <property name="location" value="db.properties"></property>
    >             </bean>
    >             ```
    >             
    >         * 方式2、使用spring专门提供的context命名空间来导入资源文件：1.导入context命名空间，同时还要配置context的相关解析文件；2.使用context
    >         
    >             ```
    >             xmlns:context="http://www.springframework.org/schema/context"
    >             xsi:schemaLocation="
    >                    http://www.springframework.org/schema/beans
    >                     http://www.springframework.org/schema/beans/spring-beans.xsd
    >                      http://www.springframework.org/schema/context
    >                      http://www.springframework.org/schema/context/spring-context-4.2.xsd"
    >             ```
    >             
    >             ```
    >             <context:property-placeholder location="db.properties" />
    >             ```
    >         
    >     4. 在配置文件中，管理数据库连接池类对象：使用固定语法```${键名}```来获取资源文件中指定键的值
    >     
    >         ```
    >         <bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource">
    >             <property name="driverClassName" value="${jdbc.driver}"></property>
    >             <property name="url" value="${jdbc.url}"></property>
    >             <property name="username" value="${jdbc.username}"></property>
    >             <property name="password" value="${jdbc.password}"></property>
    >         </bean>
    >         ```
    >         
### 10. 自动装配和兼容性
10. 自动装配和兼容性
    > 1. 自动装配
    >
    >     1. 介绍
    >     
    >        手动装配：以value或ref的方式**明确指定属性值**；
    >        
    >        自动装配：根据指定的装配规则，**不需要明确指定**，spring**自动**将匹配的属性值**注入**bean中
    >        
    >     2. 注意：自动装配的属性，必须保证是非字面量的即要用ref
    >     
    >     3. 使用
    >     
    >        在```<bean>```标签中，```autowire=""```就是自动装配属性，如果要开启自动装配，则设置属性值为byName或者byType
    >        
    >         * ```autowire="byName"```：根据需要装载的```<property>```的name属性进行自动装载。装载策略为：寻找和name相同的spring容器```<bean>```的id，将该```<bean>```装载给```<property>```，此时```<property>```可以不用写。
    >        
    >         * ```autowire="byType"```：在spring管理的bean中，寻找可以为该属性装配的bean，找到了就为其赋值。例如，spring管理了子类，则可以为其父类属性赋值；spring管理了接口的实现类，则可以为接口属性赋值
    >        * spring配置文件管理的对象，可以给**属性类型为该对象的属性**赋值，还可以为**属性类型为该对象的父类或接口的属性**赋值。这体现了兼容性。
    >          
    >        * byName和byType选用：选用byType进行自动装载，必须保证spring管理的bean中，有且只能有一个bean可以为属性进行装载，否则会抛出该异常```org.springframework.beans.factory.NoUniqueBeanDefinitionException```；选用byName进行装载，必须保证属性的name和bean的id必须相同。
    >        
    >    4. autowire属性的自动装载会作用于bean中所有的非字面量属性，因此我们不使用该方式做自动装载
    >
### 11. 通过注解配置bean    
11. 通过注解配置bean
    > 1. 介绍
    >
    >    相对于xml方式，通过注解配置bean，更加简洁和优雅，而且和MVC组件的开发理念十分契合，是开发中常用的方式
    >    
    >    **注意：要想使用注解配置bean，必须导入一个jar包：spring-aop-**
    >    
    > 2. 使用注解标识组件：spring管理的组件就是一个个的bean，因此注解都是加载bean对应的类上
    >
    >     1. 普通组件：```@Component```
    >     
    >        标识一个受springIOC容器管理的组件。一个类加上该注解，spring就会去管理这个类
    >        
    >     2. 持久化层（dao层）组件：```@Repository```
    >     
    >        标识一个受springIOC容器管理的持久层组件
    >        
    >     3. 业务逻辑层组件：```@Service```
    >     
    >        标识一个受springIOC容器管理的业务逻辑层组件
    >        
    >     4. 表述层控制组件：```@Controller```
    >     
    >        标识一个受springIOC容器管理的表述层控制组件
    >     
    > 3. 组件命名规则
    >
    >     1. 默认情况下：使用组建的简单类名首字母小写得到的字符串作为bean的id
    >     
    >     2. 使用组件注解的value属性手动指定bean的id，例如@Component("xxx")
    >     
    >     3. 注意：spring没有能力识别一个组件是不是它标记的类型，所以spring的上述几个注解是用来给开发人员做标注的。
    >     
    > 4. 注解配置使用步骤
    >
    >     1. 给要交给spring管理的类加上注解（注意：spring管理的bean必须是能够实例化的类，因此不能给接口加，必须要给实现类加）
    >
    >     2. 配置配置文件：在配置文件中加入扫描组件```<context:component-scan base-package="com"></context:component-scan>```。只有加上扫描组件，spring才会在加载配置文件后，扫描所有的类，选择加了注解的类进行作为spring的组件进行加载。context命名空间要想使用，要先在xsi:schemaLocation中引入。base-package中写入要管理的类所在的包
    >     																																																																																																																																																																																																																																																																																																																																																		
    >         ```
    >         <?xml version="1.0" encoding="UTF-8"?>
    >         <beans xmlns="http://www.springframework.org/schema/beans"
    >                xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    >                xmlns:context="http://www.springframework.org/schema/context"
    >                xsi:schemaLocation="
    >                http://www.springframework.org/schema/beans
    >                 http://www.springframework.org/schema/beans/spring-beans.xsd
    >                  http://www.springframework.org/schema/context
    >                  http://www.springframework.org/schema/context/spring-context-4.2.xsd
    >         "
    >         >
    >             <context:component-scan base-package="com"></context:component-scan>
    >         </beans>
    >         ```
    >         
    >     3. 扫描组件```<context:component-scan base-package="">```
    >
    >         1. 介绍
    >
    >            扫描组件，spring才会在加载配置文件后，扫描所有的类，选择加了注解的类进行作为spring的组件进行加载
    >
    >             * 组件：spring管理的bean
    >
    >             * 作为spring的组件进行加载：会自动在spring配置文件中生成相应的bean，bean的id会以类的首字母小写为值
    >            
    >         2. base-package：
    >
    >            要扫描的类所处的包，如果有多个包要扫描，可以使用,隔开，多个类必须是平行关系。如```base-package="com.yuu.spring.mod.user, com.yuu.spring.mod.admin"```
    >            
    >         3. 扫描组件的包含和过滤
    >
    >            1. 介绍 
    >
    >               如果要加载的类位于很多包中，使用base-package指定包则太过繁琐。因此，我们使用扫描组件的包含和过滤
    >               
    >            2. 在```<context:component-scan>```中使用包含和过滤标签步骤
    >
    >                * **```<context:componet-scan>```标签中的user-default-filters属性，表示是否启用自动扫描，自动扫描启用会扫描整个base-package指定的包，禁用会什么都不扫描**
    >
    >                * 包含标签：<context:include-filter type="" expression="">，在base-package下，再次通过注解或类型包含到某个或某几个类。
    >
    >                    * **注意：使用包含标签，必须修改```<context:componet-scan>```标签中设置user-default-filters属性为false。**
    >
    >                    * type属性属性值：
    >                      
    >                        1. ```annotation```：注解类。意思为在base-package中的含具体注解的类。
    >                           
    >                        2. ```assignable```：具体的类。意思为在base-package中的具体的类
    >                        
    >                    * expression属性属性值：全类名
    >                    
    >                * 过滤标签：```<context:exclude-filter type="" expression="">```，在base-package下，再次通过注解或类型排除某个或某几个类.
    >
    >                    * **注意：因为必须先扫描了，才能知道过滤什么。因此使用过滤标签，必须修改```<context:componet-scan>```标签中设置user-default-filters属性为true或者删除user-default-filters标签 。**
    >                      
    >                    * type属性和expressin属性和包含标签相同
    >                
    >            3. 注意：一个扫描组件内，可以使用多个包含，也可以使用多个排除，**禁止包含和排除混用**
    >            
### 12. 基于注解的自动装配
12. 基于注解的自动装配
    > 1. 介绍
    > 
    >    由于我们前边是通过注释自动装配，然后再配置文件中通过扫描组件扫描类进行装配的，因此，在配置文件中我们无法看到具体的```<bean>```标签。
    >    
    >    我们在需要自动装配的属性上，写上@Autowired注解进行自动装配
    >    
    > 2. 注意：由于我们使用@Autowired注解进行自动装配时，使用byType进行装配，因此，我们必须保证spring管理的对象中有能为其装配的对象。@Autowired可以切换装配模式，如果默认的byType方式不行，会切换成byName再次寻找可以装配的bean。如果两种方式都找不到可以装配的bean，则抛出```org.springframework.beans.factory.NoSuchBeanDefinitionException```
    > 
    > 3. @Autowired注解有一个参数required，默认@Autowired([required=true])，说明如果该自动装载的属性必须被装载否则抛出异常；如果修改@Autowired(required=false),则该属性可以不被自动装载，无法装载则spring不会抛出异常，该属性为默认值null。
    > 
    > 4. @Autowired在spring中如果有多个管理的bean可以装载，则可以在@Autowired下添加一个注解：@Qualifier来选择要装载的bean，@Qualifier("要装载的bean的id")
    > 
    > 5. 通过查看源码可知，@Autowired和@Qualifier注解也可以注解方法，它们注解方法的原理：@Qualifier注解自动装载的bean赋值给方法的参数，方法的参数给类的属性赋值。这两个注解注解方法和方法名无关。
    >             
## 2. AOP
2. AOP
    > 1. AOP前奏
    >
    >     1. 代理模式
    >     
    >         1. 动态代理
    >     
    >            代理对象和目标对象其实都**实现了相同的接口**，代理对象的重写接口的方法时通过InvocationHandler来管理，代理对象想调用任何方法，都会执行InvocationHandler中的方法。
    >            
    >             代理对象和实现类的对象是兄弟关系，因此代理对象应该转型为接口，不能转为实现类
    >            
    >        2. **注意：jdk实现动态代理，前提是有接口**
    >        
    >        3. cglib：spring的第二种代理模式，如果目标对象没有实现接口，spring会使用cglib实现动态代理。cglib是基于继承的代理模式，因此它要求目标类必须不是final修饰的。
    >     
    > 2. AOP概述
    > 
    >    AOP(Aspect-Oriented Programming，面向切面编程)，是对传统OOP(Object-Oriented Programming，面向对象编程)的补充。
    >    
    >    SpringAOP最经典的两大实现：日志管理和事务管理。日志管理需要开发人员自己写，事务管理spring已经帮助我们完成了
    >    
    >    面向对象，是纵向继承机制
    >    
    >    面向切面，是横向抽取机制
    >    
    >     * 横向抽取：将非业务代码抽取出来，通过动态代理，在处理业务时再添加上
    >    
    > 3. AOP操作的主要对象是切面。
    > 
    >     * 切面：存储横切关注点(即抽取的公共功能)的类。
    >     
    > 4. AOP其实就是使用了动态代理
    > 
### 1. AOP好处   
1. AOP好处
    > 
    > 1. 每个事物的逻辑位于同一个位置，同一功能的代码不分散，易于维护与升级
    >    
    > 2. 业务模块更加简洁，只包含核心代码
### 2. AOP专业术语
2. AOP专业术语
    > 1. 横切关注点：从每个方法中抽取出来的同一类非业务代码
    >    
    > 2. 切面(Aspect)：封装横切关注点信息的类
    >    
    > 3. 通知(Advice)：切面必须要完成的具体工作。共有**五种通知：前置通知、后置通知、返回通知、异常通知、环绕通知**
    >    
    > 4. 目标(Target)：被通知的对象
    >    
    > 5. 代理(Proxy)：向目标对象应用通知之后的创建的代理对象
    >    
    > 6. 连接点(Joinpoint)：横切关注点在代码中的具体体现，对应在程序执行的某个特定位置。
    >    在程序中可以使用横纵坐标定义一个具体连接点，横坐标为每个模块的具体的方法；纵坐标为方法中各个关注点，关注点有四种：方法前、方法后、抛出异常、finally中。
    >    
    >    横纵坐标定位一个连接点。具体参见视频
    >    
    > 7. 切入点(pointcut)：定位到具体连接点的条件。每个类中有多个连接点，每个连接点都是客观存在的。如果把不同的类中每个连接点都看成数据库数据，则切入点就是查询条件，AOP通过及切入点定位具体的连接点。切入点通过org.springframework.aop.Pointcut接口进行描述，它使用类与方法作为连接点的查询条件。
    > 
### 3. AOP的实现
3. AOP的实现
    > 1. spring中AOP使用的是jdk中的动态代理，jdk动态代理要求目标对象必须要有接口。但是spring的AOP对动态代理进行了优化，**只要导入```com.springsource.net.sf.cglib-xx.xx.x.jar```包，则AOP中动态代理时，如果没有接口，则可以用继承实现动态代理**
    >
    > 2. AspectJ
    >
    >     1. 介绍
    >
    >        java社区最流行的AOP框架，它可以理解为spring中AOP思想的具体实现方式之一。
    >        
    >        在spring2.0及以上的版本中，可以使用基于AspectJ注解或基于XML配置的AOP
    >        
    >     2. 在spring中启用AspectJ注解支持步骤：
    >     
    >         1. 导入jar包
    >         
    >             * com.springsource.net.sf.cglib-xx.xx.x.jar：能够让AOP动态代理时优化
    >             
    >             * com.springsource.org.aopalliance-xx.xx.x.jar
    >             
    >             * com.springsource.org.aspectj.weaver-xx.xx.x.RELEASE.jar
    >             
    >             * spring-aop-xx.xx.x.RELEASE.jar
    >             
    >             * spring-aspectj-xx.xx.x.RELEASE.jar
    >             
    >         2. 引入aop命名空间：在spring配置文件中引入
    >         
    >             ```
    >             先引入
    >             xmlns:aop="http://www.springframework.org/schema/aop"
    >             ```
    >             
    >             ```
    >             再在xsi:schemaLocation中引入解析
    >              http://www.springframework.org/schema/aop
    >            http://www.springframework.org/schema/aop/spring-aop.xsd
    >            ```
    >            
    >         3. 配置文件中开启AspectJ的自动代理  
    >         
    >             ```
    >             <aop:aspectj-autoproxy />
    >             ```
    >         
    >     3. 使用AspectJ注解定义切面和通知
    >     
    >         1. 切面：
    >         
    >            在目标类上，加@Aspect注解
    >         
    >         2. 前置通知：
    >         
    >            方法执行前执行前置通知。在方法上，加@Before("xxx")注解。**@Before("xxx")中必须写入value属性，value中写入切入点表达式**
    >         
    >         3. 切入点表达式：
    >         
    >             1. ```execution(方法权限修饰符 方法返回值类型 方法所在类的全类名.方法名(参数1类型, ...))```，具体实例如：```@Before("execution(public int com.yuu.spring.mod.user.Calculator.add(int, int))")```。
    >             
    >             2. 如果想要全部方法，则只需将**方法名换成\***：```execution(public int com.yuu.spring.mod.user.Calculator.*(参数1类型, ...))```
    >             
    >             3. 如果任意权限的修饰符和返回值的方法，其他要求同上，则只需将**权限修饰符和返回值整体换成\***：```@Before("execution(* com.yuu.spring.mod.user.Calculator.*(int, int))")```。**禁止将权限和返回值写两个\*\***
    >             
    >             4. 如果想要某个包下的所有类，其他要求同上，则将**具体类名改成\***，其他同上：```@Before("execution(* com.yuu.spring.mod.user.*.*(int, int))")```
    >             5. 如果想要选中任意参数，其他要求同上，则将**方法中参数类型改为\.\.**，其他同上：```@Before("execution(* com.yuu.spring.mod.user.*.*(..))")```
    >             
    >         4. 后置通知：
    >         
    >            无论方法是否抛出异常，方法执行后都会执行后置通知。finally中执行后置通知。
    >            
    >            在方法上，加@After("xxx")注解。@After("xxx")必须要写入value属性，value中写入切入点表达式
    >            
    >            后置通知由于是在finally中执行，因此一般都是些关闭资源的逻辑
    >            
    >         5. 返回通知
    >         
    >            方法没有异常，则执行返回通知，有异常方法中断，返回通知不执行。方法执行后执行返回通知。
    >            
    >            在方法上，加@AfterReturning(value="xxx",returning="xxx")。
    >            
    >            **@AfterReturning(value="xx",returning="xxx")，@AfterReturning注解除了必须设置value的切入点表达式，还要在returning中设置目标方法返回值赋给的一个变量的变量名**
    >            
    >            在返回通知方法中，参数除了设置JoinPoint，再设置一个Object对象，参数名为@AfterRetruning中returning中设置的参数名，则可以在返回通知方法体中，使用目标方法的返回值对象。
    >            
    >         6. 异常通知
    >         
    >            方法抛出异常，则执行该异常通知。
    >            
    >            在方法上加@AfterThorwing(value="xxx", throwing="xxx")
    >            
    >            **@AfterThrowing(value="xx",throwing="xxx")，@AfterThrowing注解除了必须设置value的切入点表达式，还要在throwing中设置目标方法抛出的异常赋给的一个变量的变量名**
    >            
    >            在异常通知方法中，参数除了设置JoinPoint，再设置一个异常对象，参数名为@AfterThrowing中throwing中设置的参数名，则可以在异常通知方法体中，使用目标方法的异常。我们在参数上写的异常如果不是抛出异常的父类，则不会执行异常通知方法体中关于异常的代码，因此，我们可以通过参数异常类型，来指定我们在方法体中处理目标方法抛出的哪些异常。
    >         
    >         7. 环绕通知
    >         
    >            使用的非常少，实际上也是用动态代理实现，即在环绕通知方法体中控制目标方法
    >            
    >            在方法上加@Around(value="xxx")
    >            
    >            在环绕通知方法参数中设置ProceedingJoinPoint，在方法体的使用ProceedingJoinPoint的proceed()方法执行目标方法，**proceed()方法会抛出异常，必须捕获处理异常，不允许抛出**。
    >            
    >            可见，使用了环绕通知，则我们之前的四个通知的逻辑写在环绕通知方法体中。
    >         
    >     4. **注意：因为spring中AOP是基于IOC的，因此想要使用切面，必须让切面作为spring的组件交给spring管理才可以使用。**
    >
    >     5. **注意：目标对象也需要被spring管理。同时，因为AOP用的动态代理思想，因此IOC容器对象获取目标对象时，使用的getBean()方法必须用接口.class**
    >     
    >     6. **注意：因为所有的类都继承了Object，因此被spring管理的类如果没有接口也没有继承其他类，则springAOP也可以通过继承来实现动态代理**
    >     
    >     6. JoinPoint接口
    >     
    >         1. 介绍
    >         
    >            JoinPoint即连接点接口。
    >            
    >            JoinPoint对象会封装目标方法的基本信息，因此**JoinPoint一般作为切面中通知的参数**。
    >        2. JoinPoint中的方法
    >        
    >            ```
    >            Signature getSignature() -- 该方法可以获取封装了署名信息的对象Signature。在Signature中可以获取到目标方法名,所属类的Class等信息
    >            
    >            Signature对象调用getName()方法可以获取目标方法名
    >            ```
    >            
    >            ```
    >            Object[] getArgs() -- 获取传入目标方法的参数对象
    >            ```
    >            
    >            ```
    >            Object getTarget() -- 获取被代理的对象
    >            ```
    >            
    >            ```
    >            Object getThis() -- 获取代理对象
    >            ```
    >     7. ProceedingJoinPoint接口
    >        
    >         1. 介绍
    >            
    >            是JoinPoint的子接口，**它只用于环绕通知方法的参数**
    >            
    >            ProceedingJoinPoint对象可以控制目标方法
    >            
    >         2. 方法
    >            
    >             ```
    >             Object proceed() -- 执行目标方法
    >             ```
    >             
    >             ```
    >             Object proceed(Object[] var1)-- 传入新的参数去执行目标方法 
    >             ```
    >         
    >     9. 公共切入点（又叫切入点重用）
    >     
    >         1. 为什么使用公共切入点
    >         
    >            之前我们在用注解写通知时，需要在每个注解中配置专属的切入点表达式
    >            
    >            如果多个通知的切入点表达式相同，我们可以使用公共切入点
    >            
    >         2. 使用
    >         
    >         	 在切面中定义一个空方法，假设为```public void test(){}```
    >         	
    >         	 在空方法上使用@Pointcut(value="xxx")公共切入点注解
    >         	
    >         	 让每个通知注解的value属性为空方法定义的公共切入点，例如```@Before(value="test()")```、```@After(value="test()")```
    >         
    >     10. 切面的优先级
    >     
    >         1. 切面优先级默认和spring加载切面的顺序有关
    >         
    >         2. 管理切面的优先级
    >         
    >            在切面的@Aspect注解下，再添加@Order(正整数)注解，在注解中的正整数大小就是切面的优先级，值越小优先级越大。如果不写，则默认值为int类型最大值
    >            
### 4. 以xml方式配置切面（使用spring原生方式配置切面）
4. 以xml方式配置切面步骤（使用spring原生方式配置切面）
    > 1. 配置切面前先配置IOC
    > 
    >     1. 引入aop命名空间和context命名空间
    >     
    >     2. 使用扫描器扫描bean，交给spring管理
    >     
    > 2. 配置切面
    > 
    >     1. 使用```<aop:config>```标签，在标签体中配置
    >     
    >         1. 指定切面：使用```<aop:aspect>```标签，通过属性ref="bean的id"引入切面。在```<aop:aspect>```标签中配置各种通知。
    >         
    >             1. 指定前置通知：```<aop:before>```标签，通过method="方法名"指定方法为通知，通过pointcut="execution(xxx)"指定切入点
    >             
    >                 * 可以使用一个```<aop:pointcut>```标签，设置标签属性id，expression切入点表达式，来做公共切入点。其他通知标签如果要使用公共切入点标签，则不用pointcut属性改用pointcut-ref属性，属性值写公共切入点标签id。
    >             
    >             2. 指定后置通知：同上
    >             
    >             3. 同上
    >             
## 3. JdbcTemplate
3. JdbcTemplate
    > 1. 概述
    >
    >    spring提供的，以JDBCAPI为基础定义的存取框架。
    >    
    >    可以将JdbcTemplate看作是一个小型的轻量级持久化层框架
    >    
    > 2. 环境准备
    >
    >     1. 导入jar包
    >     
    >         1. IOC容器所需jar包：老五样
    >         
    >         2. JdbcTemplate所需jar包
    >         
    >             * spring-jdbc-xx.xx.x.RELEASE.jar
    >             
    >             * spring-orm-xx.xx.x.RELEASE.jar
    >             
    >             * spring-tx-xx.xx.x.RELEASE.jar
    >             
    >         3. 数据库驱动jar包和数据源jar包(Druid)
    >         
    >     2. 为Jdbc创建xml配置文件
    >     
    >     3. 创建bean，将JdbcTemplate对象交给spring管理
    >     
    >     4. 依赖注入JdbcTemplate的bean的属性
    >     
    >         1. 注入DataSource：创建DruidDataSource的bean交给spring管理，将该bean注入JdbcTemplate的bean
    >     
    > 3. 使用JdbcTemplate
    >
    >     1. 增删改操作
    >     
    >         ```
    >         int update(String sql) -- 增删改功能
    >         int update(String sql, Object... args) -- 增删改功能
    >         ```
    >         
    >         ```
    >         // 批量增删改通常用于传入复选框时
    >         int[] batchUpdate(String[] sql) -- 批量增删改
    >         int[] batchUpdate(String sql, List<Object[]> batchArgs) -- 批量增删改。参数1：写增删改一条记录的语句；参数2：每个数组中，按顺序存放要增删改的数据，整个List就是一共要增删改多少条记录
    >         ```
    >         
    >         * 注意：我们做批量删除和修改操作时，也可以使用普通update()，例如删除只用将sql写成：```"delete from `表名` where 字段名 in (多个条件)"```即可。**特别注意，in()括号中无法使用一个通配符?进行赋值，例如in(?)。同理，模糊查询like后边也无法使用通配符?进行赋值**，原因见视频。
    >         
    >     2. 查询操作
    >     
    >         ```
    >         T queryForObject(String sql, Class<T> type[, Object... args]) -- 根据sql语句查询，并且将结果封装为T类型的数据。必须使用基本数据类型的包装类的字节码
    >         通常该方法用来查询聚合函数的值
    >         
    >         T queryForObject(String sql[, Object[] args], RowMapper<T> rowMapper) -- 根据sql语句查询，并且将结果封装为T类型的数据。RowMapper作用：将列名（字段名或者字段名的别名）和要封装到的类中的属性名进行映射。
    >         用来获取单条数据并封装
    >         ```
    >         
    >         ```
    >         List<T> query(String sql[, Object[] args], RowMapper<T> rowMapper) -- 根据sql查询所有数据，并将数据封装为T对象的List集合
    >         ```
    > 
### 1. 事务管理
1. 事务
    > 1. 概述
    >    
    >     为保证数据的完成性和一致性，引入了事务的概念。
    >     
    > 2. 事务的关键属性
    >    
    >     1. 原子性(atomicity)：原子性即无法继续分割，事务原子性体现为整个事务中，多个操作缺一不可，要么都执行，要么都不执行。
    >        
    >      2. 一致性(consistency)：一致指的是数据一致，所有数据满足一致性原则。一致性原则：数据在执行事务前是正确的，执行后仍然是正确的。如果事务执行期间任意的操作失败，必须回滚到事务处理之前。
    >         
    >     3. 隔离性(isolation)：要求并发处理多个事务时，互不干扰。
    >        
    >     4. 持久性(durability)：要求事务执行完毕，数据必须永久保存。
    >     
    > 3. 编程式事务管理
    >    
    >    通过原生JDBCAPI实现事务管理。**原生JDBCAPI事务管理是其他事务管理的基石**。编程式事务管理需要将事务管理逻辑嵌入到业务逻辑中。
    >    相较于业务代码，事务管理就是非业务代码，如果多个模块使用相同模式的代码进行事务管理，使用编程式事务管理方式会造成大量代码的冗余。
    >    
    > 4. 声明式业务管理
    >
    >    一般情况下声明式业务管理都比编程式业务管理要好，声明式业务管理：将事务管理逻辑从业务代码中抽取出来，以声明的方式进行事务管理。
    >    
    >    声明式业务管理是一种固定模式，因此可以将其作为横切关注点，通过springAOP框架实现声明式业务管理。
    >    
    > 5. DataSourceTransactionManager(数据源事务管理器)类
    >
    >     1. 介绍
    >     
    > 	     DataSourceTransactionManager类继承自AbstractPlatformTransactionManager抽象类   
    > 	     
    > 	     AbstractPlatformTransactionManager抽象类是spring为开发者抽取出的基本事务实现方式和功能。在该抽象类下，由于事务实现技术的不同，分别有多个子类继承了该抽象类。例如：DataSourceTransactionManager、HibernateTransactionManager等
    > 	     
    > 	     DataSourceTransactionManager类就是使用原生JDBC管理事务时的类。
    > 	     
    > 	     HibernateTransactionManager类就是使用Hibernate框架管理事务时的类。
    > 	     
    > 	 2. 由于我们在这里使用的JdbcTemplate框架是基于JDBCAPI的封装，因此事务管理就是使用的原生JDBC，所以使用DataSourceTransactionManager类
    > 	
    > 3. 使用事务：事务管理器通过注解管理事务
    > 
    >     1. 配置文件：配置事务管理器和开启事务注解驱动
    > 	   
    > 	      1. 让spring管理DataSourceTransactionManager。配置bean标签，属性为需要事务管理的数据源。因为事务管理依赖于数据库连接，连接成功了才能管理，因此属性为数据源
    > 	         
    > 	          ```
    > 	             <bean id="jdbcTransaction"   class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
    > 	                     <property name="dataSource" ref="datasource" />
    > 	             </bean>
    > 	          ```
    > 	          
    > 	      2. 引入tx命名空间：tx就是专门用来管理事务的
    > 	         
    > 	          1. 导入spring-tx-xx.xx.x.RELEASE.jar包
    > 	             
    > 	          2. 引入tx命名空间和解析
    > 	          
    > 	              ```
    > 	              xmlns:tx="http://www.springframework.org/schema/tx"
    > 	              ```
    > 	              
    > 	              ```
    > http://www.springframework.org/schema/tx
    > 	              http://www.springframework.org/schema/tx/spring-tx-3.0.xsd
    > 	              ```
    > 	              
    > 	          3. 使用tx：开启事务注解驱动，并且指定事务注解驱动的事务管理器
    > 	             
    > 	              ```
    > 	              <!--    开启事务的注解驱动，即对注解相关的事务进行扫描解析含义并执行功能-->
    > 	              <tx:annotation-driven transaction-manager="jdbcTransaction"/>
    > 	              <!--	transaction-manager属性：事务管理器的id-->
    > 	              ```
    > 	              
    > 	              * 注意：使用注解管理事务，必须保证引入过AspectJ相关的jar包。
    > 	      
    >     2. 在需要进行事务操作的方法或类上加@Transactional注解
    >     
    > 4. @Transactional注解
    >
    >     1. 介绍
    >     
    >     	 对将方法中的所有操作作为一个事务进行管理
    >     
    >        在方法或者类上使用。根据注解的作用范围可知，@Transactional用在方法上，只能在方法上有作用；@Transactional用在类上，在类中所有方法都有效果
    >     
    >     2. @Transactional注解中的属性
    >     
    >         1. @Transactional注解既可以加在类上，又可以加在方法上，如果两个@Transactional注解设置的同样的属性，则方法到底要遵循哪个注解遵循就近原则；如果两个@Transactional注解设置不同属性，则方法遵循的注解效果叠加。
    >         
    >         2. @Transactional注解中属性详解
    >         
    >             1. value属性：一般不写，没有大的影响
    >             
    >             2. propagation属性：事务的传播行为。
    >             
    >                 1. 介绍
    >                 
    >                    假设A和B方法都有事务注解，如果A调用B，则会将A的事务传播给B，B方法对于事务的处理方法，即使用自身的事务还是调用者A的事务。就是事务的传播行为。
    >                    
    >                 2. 属性值：通过Propagation.给定的属性值来设置。共有七种，常用以下两种：
    >                 
    >                     * Propagation.REQUIRED：必须使用调用者A的事务。这是默认的选择
    >                     
    >                     * Propagation.REQUIRES_NEW：不使用调用者A的事务，创建自身的新事务，把调用者A的事务先挂起
    >                     
    >                 
    >             3. isolation属性：事务的隔离级别。一般用于并发的情况下。默认和数据库隔离级别相同。
    >             
    >                 1. 多个事务操作同一批数据会引发的问题
    >                 
    >                     1. 脏读：一个事务读取到另一个事务未提交的数据，即读到无意义数据
    >                     
    >                     2. 不可重复读：同一个事务，两次读取到的数据不同
    >                     
    >                     3. 幻读：一个事务进行DML(增删改)操作已经存在的数据，如果另一个事务**添加**了数据，则第一个事务不知道哪个是自己的修改
    >                     
    >                 2. 事务隔离级别有四级：从上而下，越来越安全，性能越来越低
    >                 
    >                     * 读未提交：isolation属性值为1(2^0)。可以读到别人未提交的数据。脏读、不可重复读、幻读
    >                     
    >                     * 读已提交：isolation属性值为2(2^1)。只能读到别人提交的数据。解决脏读，还是不可重复读、幻读
    >                     
    >                     * 可重复读：isolation属性值为4(2^2)。当前存在数据，不允许其他事务进行操作，保证同一事务多次读取时数据的一致性。解决脏读、不可重复度，未解决幻读。
    >                     
    >                     * 串行化：isolation属性值为8(2^3)。给表中每个记录间加入间隙锁，阻止新记录的插入。相当于单线程，好像将每个数据库操作串起来。解决所有问题
    >             
    >             4. timeout属性：超时。在**事务强制回滚前**，最多可以执行的时间。一般我们先模拟高并发，估算数据库处理请求时间，如果发生意外情况超过该时间直接强制回滚关闭连接。多用于高并发。
    >                
    >                 * 属性值：int类型的一个数字，单位为秒
    >               
    >             5. readOnly属性：只读。指定当前事务中的所有操作对数据库是否为只读操作。默认为否。
    >             
    >                 * 注意：并不是规定了该属性为只读，事务中就只能写读操作了。
    >                 
    >                 * 注意：如果指定了该事务为只读，则spring会通知数据库不用给事务加锁，则所有只读事务就可以同时读取数据，大大提升了效率，减轻数据库压力。
    >                 
    >                 * **注意：只要设置readOnly为true，则数据库都不会给该事务加锁，绝对不允许在事务中有写操作时设置该属性为true**
    >             
    >             6. rollbackFor属性：设置事务**只因为某事而回滚**。
    >             
    >                 * 属性值：默认为{}，代表只要抛出异常就会回滚。可以设置为某个类的class对象，如果有多个用,隔开
    >             
    >             7. rollbackForClassName属性：设置事务只因为某个抛出某个类而回滚
    >                
    >             * 属性值：默认为{}。可以设置字符串类型的类名，如果有多个用,隔开
    >               
    >             8. noRollbackFor属性：设置事务不因为某事回滚
    >             
    >                 * 属性值：默认为{}。可以设置为某个类的class对象，如果有多个用,隔开
    >             
    >             9. noRollbackForClassName属性：设置事务不因为某个类回滚
    >             
    >                 * 属性值：默认为{}。可以设置为字符串类型的类名，如果有多个用,隔开
    >     
    > 8. 基于xml的声明式事务管理：通过在xml配置具体的事务通知，事务通知使用事务管理器；配置具体的切入点表达式，让事务通知和切入点表达式关联
    >    
    >     1. 配置DataSourceTransactionManager事务管理器（注解配置方式和xml配置方式都需要事务管理器支持）
    >     
    >     3. 配置切入点表达式
    >     
    >     4. 由于并不是所有的service都会使用到数据库，都需要进行事务操作，因此需要进一步配置事务通知
    >
    >         ```
    >         <tx:advice transaction-manager="jdbcTransaction">
    >             <tx:attributes>
    >         <!-- 在设置好了的切入点表达式下，继续进行事务设置，name属性值为要被事务管理的具体方法名，其他属性和注解中属性作用相同-->
    >         <!-- 如果方法过多，可以使用通配符*来简化操作-->
    >                 <tx:method name="buyBook"/>
    >                 <tx:method name="checkOut"/>
    >                 <!-- 所有的以select开头的方法-->
    >                 <tx:method name="select*" />
    >             </tx:attributes>
    >         </tx:advice>
    >         ```
    >         
    >         * 注意：事务通知也需要获得事务管理器的支持，因此需要设置事务通知的transaction-manager属性
    >         
    >     5. 让切入点表达式和通知进行关联
    >     
    >         ```
    >         <aop:config>
    >         <aop:pointcut id="pointcut" expression="execution(* com.yuu.spring.mod.user.*.*(..))"/>
    >     <!-- 让pointcut和事务通知关联-->
    >         <aop:advisor advice-ref="tx" pointcut-ref="pointcut" />
    >         </aop:config>
    >         ```
    > 
# 2. SpringMVC
### 1. SpringMVC简单使用
1. SpringMVC简单使用
    > 1. 简介
    >
    >    spring为展现层提供的基于MVC设计理念的web框架，是目前主流的MVC框架之一
    >    
    >    springMVC提供一套MVC注解，让POJO成为处理请求的控制器，从而无需实现任何接口。 POJO：Plain Old Java Object，即原始Java对象
    >    
    >    支持REST风格的URL请求 REST：Restful
    >    
    >    采用了松散耦合可插拔组件结构，更加具有扩展性和灵活性。
    >    
    >    SpringMVC是轻量级、基于MVC的Web层应用框架。是spring框架的后续产品
    >    
    > 2. 环境搭建
    >
    >     1. 创建web项目
    >     
    >     2. 导包
    >     
    >        SpringMVC是基于spring，因此先导入spring需要的jar包，然后导入springMVC的两个jar包：```spring-web-xx.xx.x.RELEASE.jar```、```spring-webmvc-xx.xx.x.RELEASE.jar```
    >        
    >     3. 在web.xml中配置SpringMVC的核心(前端)控制器
    >     
    >         ```
    >         <servlet>
    >                 <servlet-name>springMVC</servlet-name>
    >                 <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
    >             </servlet>
    >             <servlet-mapping>
    >                 <servlet-name>springMVC</servlet-name>
    >                 <!-- 注意，这里不能写/*，/*说明所有url都要被核心处理器处理。我们这里写/，说明只有请求才会被核心处理器处理。-->
    >                 <url-pattern>/</url-pattern>
    >             </servlet-mapping>
    >         ```
    >         
    >         * 核心控制器作用：加载springMVC的配置文件。上述配置的核心控制器，SpringMVC配置文件默认位置和默认名称为```WEB-INF/springMVC-servlet.xml```，如果```<servlet-name>springMVC</servlet-name>```改变了，假如改变为mvc，则SpringMVC配置文件默认名称也变为mvc-serlvet.xml
    >         
    >     4. 配置SpringMVC配置文件
    >     
    >         1. 加入扫描组件：扫描组件将加了@Controller的POJO作为springMVC的控制层
    >     
    >             ```
    >             <context:component-scan base-package="xxx.xxx.xx.xx"></context:component-scan>
    >             ```
    >             
    >         2. 配置视图解析器：视图解析器作用，将prefix+视图名称+suffix确定最终要跳转的页面
    >         
    >             ```
    >             <bean id="viewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver">
    >             	<!-- prefix，前缀；suffix，后缀-->
    >             	<property name="prefix" value="/"></property>
    >             	<property name="suffix" value=".jsp"></property>
    >             </bean>
    >             ```
    >         
    >     5. 在扫描组件所扫描的xxx.xxx.xx.xx下创建POJO类，加入@Controller注解。此时SpringMVC就会让此类作为控制层加载，让其处理请求响应
    >     
    >     6. 在POJO类的方法上，加入@RequestMapping("xxx")注解。@RequestMapping("xxx")注解的value属性属性值为该方法要解决请求的请求路径名
    >
### 2. @RequestMapping()注解
2. @RequestMapp()注解
    > 1. 作用
    >
    >    设置请求映射，将请求和控制层方法之间设置映射关系。
    >    
    >    约束方法处理那些请求
    >    
    > 2. @RequestMapping()属性：属性越多，对请求的url约束性越强，请求越精确
    >
    >     * value属性：String类型，请求路径。必须要有
    >     
    >     * method属性：RequestMethod枚举类型，请求方式，共有八种，常用的有四种：RequestMethod.GET,RequestMethod.POST,RequestMethod.DELETE,RequestMethod.PUT，分别对应增删改查
    >     
    >         1. RequestMethod.GET -- 查询
    >         
    >         2. RequestMethod.POST -- 添加
    >         
    >         3. RequestMethod.DELETE -- 删除
    >         
    >         4. RequestMethod.PUT -- 修改
    >         
    >     * params属性：String数组类型，用来约束客户端传输到服务端的数据。支持表达式，params属性值：{"表达式1", "表达式2", ...}，要求传输数据必须满足多个表达式的要求
    >     
    >         * 表达式包括：
    >         
    >            name--存在属性名为name的属性,
    >         
    >            !name--不存在属性名为name的属性,
    >         
    >            name=value--存在属性名为name且属性值为value的属性，
    >         
    >            name!=value--不存在属性名为name属性值为value的属性
    >         
    >     * headers属性：String数组类型，用来约束请求头信息。headers属性值：{"请求头1", "请求头2"}
    >     
    > 3. @RequestMapping()注解作用位置
    >
    >     1. 方法上：对该方法有效
    >     
    >     2. 类上：对类中所有方法有效。加在类上的@RequestMapping()注解最多设置一个value属性
    >     3. 如果类和方法上都加有@RequestMapping()注解，则先访问类的注解，再访问方法注解
    > 4. @RequestMapping()注解支持Ant路径风格
    >
    >     1. 含义
    >     
    >        在value属性中写入的请求路径，可以使用Ant路径风格
    >        
    >     2. Ant风格
    >     
    >         * Ant风格路径支持三种通配符：
    >         
    >             1. ?:匹配文件名中一个字符
    >             
    >             2. \*:匹配文件名中任意的字符
    >             
    >             3. \*\*:匹配任意多层路径
    >     
    > 5. @RequestMapping()注解中的映射请求占位符@PathVariable()注解
    >
    >     1. 含义
    >     
    >        带占位符的URL是spring3.0新特性。通过@PathVariable()注解可以获得URL中占位符参数，传入到控制器处理方法的形参中。
    >        
    >        即URL中的{xxx}占位符可以通过@PahtVariable("xxx")传入到方法的形参中。
    >        
    >        以前的URL：```"/testReq?id=xxx&username=xxx&password=xxx"```
    >        
    >        使用占位符的URL：```"/testReq/{id}/{username}/{password}"```
    >        
    >     2. 例子
    >     
    >         ```
    >         @RequestMapping("/testReq/{id}/{username}/{password}")
    >         public String testReq(@PahtVariable("id") Integer id, @PahtVariable("username") String username, @PathVariable("password") String password) {
    >         	逻辑代码;
    >         }
    >         ```
    >     
### 3. REST
3. REST
    > 1. 简介
    > 
    >    Representational State Transfer，表现状态转化。
    >    
    >    是目前最流行的互联网软件架构
    >    
    > 2. 互联网专业术语
    > 
    >     * 资源(Resource)：网络上的一个实体或者说是网络上的一个具体信息，包括一段文本、一张图片、一个视频等。可以用一个URI(统一资源标识符)指向它，每个资源对应一个特定的URI。要想获取一个资源，获取该资源的URI即可，因此URI就是每个资源独一无二的标识
    >     
    >     * 表现层(Representation)：把资源具体呈现出来的形式，叫做它的表现层。例如文本资源，可以使用TXT格式，或者HTML格式，或者json格式，甚至可以用二进制格式。
    >     
    >     * 状态转化(State Transfer)：每发出一个请求，就代表了客户端和服务器端的一次交互过程。因为HTTP协议是无状态协议，即所有状态信息都保存在服务器端，因此，如果客户端想要操作服务器端，必须通过某种手段，让服务器端发生状态的转化(State Transfer)。这种状态转化是建立在表现层的，因此叫做表现层的状态转化。
    >     
    > 3. REST的简单概念
    > 
    >    HTTP协议里面，通过四个表示操作的动词：GET、POST、PUT、DELETE，来表示四种操作：GET--获取资源、POST--新建资源、PUT--更新资源、DELETE--删除资源
    >    
    >    URL中利用占位符传递参数，用上述的四种动词表示要进行的操作。服务器中，判断请求方法来决定操作，通过@PathVariable()注解来获取占位符的值，传给参数
    > 
### 4. HiddenHttpMethodFilter  
4. HiddenHttpMethodFilter
    > 1. 前言
    >    
    >    虽然服务器端可以对HTTP的四种动词进行操作，但是实际上客户端发送HTTP只能通过GET/POST方式，没有其他方式。
    >    
    >    我们可以：客户端获取资源用普通GET，新建资源用普通POST，剩下的更新资源PUT、删除资源DELETE也用普通POST，但是传入一个参数，该参数有不同的参数值。我们在客户端和服务器端之间，按照POST是否有参数、参数的参数值，对这些POST请求做转换，转换成应该对应的方式。
    >    
    >    **如果要传参，传参方式可以用占位符方式，即```/user/参数值```**
    >    
    > 2. HiddenHttpMethodFilter介绍
    >
    >    HiddenHttpMethodFilter是SpringMVC提供的已经写好的过滤器类，用以对URL的POST请求方式和服务器端需要的四种请求方式做转换。
    >    
    > 3.  HiddenHttpMethodFilter源码分析
    >
    >    根据源码分析可知，HiddenHttpMethodFilter会先接收URL请求，获取URL请求的访问类型。
    >    
    >    如果是GET方式，不做操作
    >    
    >    如果是POST方式，会做如下判断：如果没有**"\_method"参数**，作为普通POST请求；如果有**"\_method"参数**，将**"\_method"参数值**转换为大写，然后转换为服务器需要的访问方式。
    >    
    > 4. HiddenHttpMethodFilter过滤器使用
    >
    >     1. 将其配置在web.xml的配置文件中即可，一般配置在编码过滤器之后。
    >     
    >         ```
    >         <filter>
    >                 <filter-name>HiddenHttpMethodFilter</filter-name>
    >                 <filter-class>org.springframework.web.filter.HiddenHttpMethodFilter</filter-class>
    >             </filter>
    >             <filter-mapping>
    >                 <filter-name>HiddenHttpMethodFilter</filter-name>
    >                 <!-- 过滤器必须对所有请求都进行过滤，因此用/*-->
    >                 <url-pattern>/*</url-pattern>
    >             </filter-mapping>
    >         ```
    >
### 5. REST风格的URL完成CRUD
5. REST风格的URL完成CRUD
    > 1. 前端
    >
    >     ```
    >     查看资源
    >     <a href="/user/1001">点击查看1001号资源</a>
    >     ```
    >     
    >     ```
    >     创建资源
    >     <form action="/user" method="POST">
    >     	资源信息标签
    >     	<input type="submit" value="创建资源">
    >     </form>
    >     ```
    >     
    >     ```
    >     修改资源
    >     <form action="/user" method="POST">
    >     	修改后的资源标签
    >     	<input type="hidden" name="_method" value="PUT">
    >     	<input type="submit" value="修改资源">
    >     </form>
    >     ```
    >     
    >     ```
    >     删除资源
    >     <form action="/user" method="POST">
    >     	修改后的资源标签
    >     	<input type="hidden" name="_method" value="DELETE">
    >     	<input type="submit" value="删除资源">
    >     </form>
    >     ```
    >     
    > 2. 后台
    >
    >     ```java
    >     @Controller
    >     public class RESTController {
    >         // 获取资源
    >         @RequestMapping(value="/user/{id}", method=RequestMethod.GET)
    >         public String getById(@PathVariable("id") Integer id) {
    >             逻辑代码;
    >         }
    >         
    >         // 创建资源
    >         @RequestMappint(value="/user", method=RequestMethod.POST)
    >         public String createResource() {
    >             逻辑代码;
    >         }
    >         
    >         // 修改资源
    >         @RequestMapping(value="/user", method=RequestMethod.PUT)
    >         public String updateResource() {
    >             逻辑代码;
    >         }
    >         
    >         // 删除资源
    >         @RequestMapping(value="/user", method=RequestMethod.DELETE)
    >         public String deleteResource() {
    >             逻辑代码;
    >         }
    >     }
    >     ```
    >     
    > 3. ajax发送请求时，可以发送八种；普通的form表单发送请求时，只能发送两种
    > 
    >    因此，我们使用ajax发送请求时，可以不使用HiddenHttpMethodFilter进行转化。但是，ajax想要的就是不跳转就能够和服务器进行数据交互，因此**使用ajax一定要保证控制层方法没有返回值**。
    >    
### 6. 处理请求数据
6. 处理请求数据
    > 1. 前言
    >
    >    请求数据包括：请求参数，cookie信息，请求头信息等。在JavaWeb中，我们使用HTTPRequest对象获取。
    >    
    > 2. springMVC中获取请求参数数据方式
    >
    >     1. 最基础方式
    >
    >        在控制层方法上，写上对应参数的形参，保证形参名和参数名相同，类型能够承载参数值。
    >        
    >         * 最基础方式必须保证形参名和参数名一致，如果不一致，可以在每个形参上使用@RequestParam()注解。
    >        
    >         * @RequestParam()注解：设置value属性为参数名，则该参数名会和形参指定映射关系；设置required属性为false，则即便映射关系无法形成，就重新考虑形参名和参数名的一致性；设置defaultValue属性，如果参数的参数值为空或者参数不存在，则使用该值作为参数值，例如分页的第一次访问、模糊查询如果不传值时查询所有。
    >        
    >         * 模糊查询如果不传值时查询所有：不传值，则参数的参数值为空。模糊查询中，如果模糊查询关键字是空字符串，即模糊查询语句为"%%时，查询所有数据。因此，只要将模糊查询参数的@RequestParam()注解的defaultValue属性值设置为""，就可以做到模糊查询不传值查询所有的效果。
    >     
    > 3. springMVC获取请求头信息数据方式
    > 
    >     1. 将请求头信息绑定到方法的形参上
    >     
    >        使用@RequestHeader()注解修饰形参，就可以将某个请求头信息和形参绑定。
    >        
    >        @RequestHeader()注解的属性类型和属性的用法和上述的@RequiredPram()注解相同。value属性，请求头信息参数名；required属性，设置为false，则如果没有该请求头信息就不用获取；defaultValue属性，则如果没有该请求头信息则使用默认值
    >     
    > 4. SpringMVC获取cookie信息方式
    > 
    >     1. 将cookie信息绑定到方法的形参上
    >     
    >        使用@CookieValue()注解修饰形参，就可以将某个Cookie参数信息和形参绑定。
    >        
    >        @CookieValue()注解的属性类型和属性的用法和上述的@RequiredPram()注解相同。value属性，Cookie信息参数名；required属性，设置为false，则如果没有该Cookie信息就不用获取；defaultValue属性，则如果没有该Cookie信息则使用默认值
    >     
    > 5. 使用POJO获取客户端的数据
    > 
    >     1. 将POJO作为控制层方法的形参，则SpringMVC会自动将参数信息和POJO对象的属性名比较，如果参数名等于属性名，则直接绑定。
    >     
    >     2. SpringMVC支持级联关系，即如果参数名是"address.city"，springMVC会自动寻找POJO中的address属性，如果address属性也是个POJO，则寻找address对象的city属性，然后赋值。
    >     
    > 6. 在方法形参上，使用Servlet中的原生API作为参数
    > 
    >     1. 因为我们请求访问的是SpringMVC的DispatcherServlet核心控制器，而DispatcherServlet会调用控制层的方法处理请求，因此我们可以在控制层方法的形参上写很多Servlet原生API作为参数，因为DispatcherServlet也是Servlet，它可以将请求封住成Servlet中的各种对象，然后赋值给方法的形参。
    >     2. 方法上可以写的ServletAPI：
    >     
    >         * HttpServletRequest
    >         
    >         * HttpServletResponse
    >         
    >         * HttpSession
    >         
    >         * java.security.Principal
    >         
    >         * Locale
    >         
    >         * inputStream
    >         
    >         * OutputStream
    >         
    >         * Reader
    >         
    >         * Writer
    >         
### 8. 在作用域中操作值
8. 在作用域中操作值
    > 1. 前言
    >
    >    控制层方法中，如果想要操作作用域，传统的Servlet中会通过HttpServletRequest对象然后操作。
    >    
    >    在springMVC的控制层方法中，我们根据之前的经验，第一个想到的也是，在方法参数上设置HttpServletRequest形参，然后通过形参直接操作。
    >    
    >    但是，springMVC封装了Servlet，则springMVC中必然存在操作作用域的方式。
    >    
    > 2. springMVC提供三种方式在作用域中操作值
    > 
    >     1. 方式1：使用ModelAndView类作为控制层方法的返回值
    >
    >         1. 介绍
    >     
    >            springMVC提供的一个用来操作Model层和View层的类
    >           
    >         2. ModelAndView类的功能
    >     
    >             1. 见名知意，该类可以操作数据和视图
    >         
    >             2. 操作数据
    >         
    >                 ```
    >                 addObject(String attributeName, Object attributeValue) --  在作用域中放值。放入的是request作用域
    >                 ```
    >             
    >             3. 操作视图
    >         
    >                 ```
    >                 setViewName(String viewName) -- 指定要使用的视图名称，实现跳转
    >                 ```
    >           
    >         3. 使用
    >     
    >             1. 获取ModelAndView对象：new ModelAndView()，有多个构造方法的重载。
    >         
    >             2. 使用ModelAndView对象的放入request作用域方法和设置视图方法
    >         
    >             3. 将ModelAndView对象返回，通知视图解析器解析哪张视图
    >         
    >             4. 视图层(jsp)从作用域中取出值，然后展示
    >         
    >        4. 部分英语单词及含义： annotation：注解；resolve：解析；process：执行；render：提交；dispatch：转发
    >        
    >        5. 查看ModelAndView源码以及debug工作原理可知：
    >        
    >           整个DispatcherServlet操作ModelAndView对象的逻辑，和我们之前写的Servlet将数据放入request作用域和页面跳转的逻辑一样，都是将数据存入request作用域，然后获取转发对象，执行转发对象的forward()方法转发实现页面跳转的。
    >        
    >    2. 方式2
    >    
    >       控制层方法还是使用String类型作为返回值，进行页面跳转。
    >       
    >       控制层方法上定义一个形参```Map<String, Objcet> map```，将数据放入形参的map中，这样就相当于将数据放入了作用域
    >       
    >        * 通过debug可知，方式2最终还是会将map和返回的String，封装到DispatcherServlet创建的一个ModelAndView对象中。可见，springMVC最终还是使用的ModelAndView对象，因此，最标准、最好的方式就是方式1
    >       
    >    3. 方式3
    >    
    >        控制层方法还是使用String类型作为返回值，进行页面跳转。
    >        
    >        控制层方法上定义一个形参```Model model```，调用```model.addAllAttributes(Map<String, ?> attributes)```方法设置所有的参数，或者调用```model.addAllAttribute(String attributeName, Object attributeValue)```方法设置单个参数
    >        
    >         * 通过debug可知，方式3最终也是靠ModelAndView对象
    >        
### 9. 视图解析
9. 视图解析
    > 1. 前言
    > 
    >    无论控制器方法返回的是String、ModelAndView、View，最终都会转换为ModelAndView对象，由视图解析器解析视图变成各种视图对象，然后，进行页面跳转
    >    
    > 2. springMVC视图源码分析
    > 
    >     1. 视图从上而下
    >     
    >         * View(最顶层的视图接口)
    >         
    >             * AbstractView(View唯一的实现类，抽象类)
    >     
    > 3. 视图对象类型：控制器方法返回的String，或者设置ModelAndView的View，最终执行时，创建的视图对象类型不同
    > 
    >     InternalResourceView：转发视图，转发时默认生成InternalResourceView对象。
    >     
    >     JstlView：也是转发视图，主要就是为了支持视图中的Jstl。继承了InternalResourceView，更加强大。加入jstl的jar包，转发时就不会生成InternalResourceView对象而是生成JstlView对象
    >     
    >     RedirectView：重定向视图
    >     
    > 4. View作用
    > 
    >     1. 处理Model模型数据
    >     
    >     2. 实现页面跳转：转发和重定向
    >     
    > 5. debug
    > 
    >     1. debug可知，SpringMVC的配置文件中可以配置多个视图解析器，但是，我们一般只会配置一个。
    >     2. debug可知，SpringMVC创建了View对象后，会将View对象放入缓存，如果下次需要同样的View对象，则从缓存中获取，不用多次创建。除非重启服务器，刷新缓存区
    >     3. 可见，如果要转发到一个页面，则最终是View会根据视图解析器的前缀，ViewName，后缀确定最终转发的页面
    >     4. 可见，如果要重定向到一个页面，只需要控制器方法返回String为```redirect:重定向路径/重定向页面名.xxx```，或者调用ModelANdView对象的setViewName方法，设置为```redirect:重定向路径重定向页面名.xxx```即可。最终，会调用response对象的重定向方法进行重定向
    >     
### 10. 在web.xml中：自定义SpringMVC的配置文件位置和名称；控制Servlet加载时间
10. 在web.xml中：自定义SpringMVC的配置文件位置和名称；控制Servlet加载时间
    > 1. 自定义SpringMVC的配置文件位置和名称和控制Servlet加载时间
    >
    >     ```
    >     <servlet>
    >             <servlet-name>springMVC</servlet-name>
    >             <servlet-class>org.springframework.web.servlet.DispatchServlet</servlet-class>
    >             <!-- 主动设置DisPatchServlet中的contextConfigLocation属性，该属性控制SpringMVC的配置文件名称和地址-->
    >             <init-param>
    >                 <!-- 固定的param-name，写上该属性名就可以在值上设置SpringMVC的配置名称和地址-->
    >                 <param-name>contextConfigLocation</param-name>
    >                 <!-- 设置配置文件名称-->
    >                 <!-- 如果想放在自定义的资源文件夹conf下，需要写成classpath:文件名称-->
    >                 <param-value>classpath:springMVC.xml</param-value>
    >             </init-param>
    >             <!-- 
    >             	设置Servlet加载时间
    >             	默认第一次被访问时加载，如果设置此标签，并且标签生效，则会提前Servlet加载时间到项目启动时
    >             	此标签中可以写整数，但是只有写正整数才能生效
    >             	如果有多个Servlet都设置了其标签且需要都有效，则必须设置不同的值，并且值越小优先级越高
    >             	>
    >             <load-on-startup>1</load-on-startup>
    >         </servlet>
    >         <servlet-mapping>
    >             <servlet-name>springMVC</servlet-name>
    >             <!-- 注意，这里不能写/*，/*说明所有url都要被核心处理器处理。我们这里写/，说明只有请求才会被核心处理器处理。-->
    >             <url-pattern>/</url-pattern>
    >         </servlet-mapping>
    >     ```
    >     
### 11. CharacterEncodingFilter编码过滤器
11. CharacterEncodingFilter编码过滤器
    > 1. CharacterEncodingFilter过滤器
    >     1. 介绍
    >     
    >        SpringMVC提供的解决编码问题的过滤器
    >        
    >     2. 原理
    >     
    >        在CharacterEncodingFilter过滤器类中，有个encoding属性，该属性为我们要设置request的编码方式。。
    >        
    >        在过滤器的doFilterInternal()方法中，会将request编码方式转为encoding属性的值
    >        
    >     3. 使用
    >     
    >         1. 在web.xml配置CharacterEncodingFilter过滤器。**编码过滤器必须配置为所有标签的第一个**
    >         
    >         2. 配置CharacterEncodingFilter过滤器的encoding属性，写上我们需要的编码格式
    >         
    >             ```
    >             <filter>
    >                     <filter-name>CharacterEncodingFilter</filter-name>
    >                     <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>
    >                     <init-param>
    >                         <param-name>encoding</param-name>
    >                         <param-value>UTF-8</param-value>
    >                     </init-param>
    >                 </filter>
    >                 <filter-mapping>
    >                     <filter-name>CharacterEncodingFilter</filter-name>
    >                     <!-- 过滤器必须对所有请求都进行过滤，因此用/*-->
    >                     <url-pattern>/*</url-pattern>
    >                 </filter-mapping>
    >             ```
    >             
### 12. 使用REST完成CRUD小项目：D:\IDEAhome\rest
12. 使用REST完成CRUD小项目：D:\IDEAhome\rest
    > 1. Maven环境搭建
    >
    >    搭建Maven，为了更快的创建，添加新属性和属性值：archetypeCatalog、internal
    >    
    > 2. 静态资源访问问题
    >
    >    访问静态资源时，我们不应该交给SpringMVC的Servlet处理，应该交给Tomcat的原始Servlet处理。
    >    
    >    在SpringMVC配置文件中，引入mvc命名空间，然后使用
    >    
    >     ```
    >    <mvc:default-servlet-handler />
    >    <mvc:annotation-driven />
    >     ```
    >    
    > 2. 删除要做到：
    > 
    >    使用删除的a标签，控制一个form表单，该form表单的action和a标签的href相同且有_method为DELETE的隐藏域，通过a标签提交form表单做到删除 
    >    
    >    **注意：如果要点击a标签，禁止其跳转功能，只需要在js代码中，让a标签的clik事件返回false即可**
### 13. form
13. form
    > 1. 介绍 
    >    在jsp界面使用，引入方式和jstl相同
    >
    >    替换普通form标签
    >
    >    用于数据的回显，或者java数据展示
    >
    > 2. from回显原理
    >
    >    在jsp中的form，会自动获取作用域中的command属性对应的对象，根据该对象知道回显哪些数据。**command属性在控制器方法中必须设置**
    >
    > 3. 部分具体标签
    >
    >     1. ```<form:form action="" method=""></form:form>```：
    >     
    >        主体标签
    >     
    >     2. ```<form:input path="xxx" />```：
    >     
    >        替换普通的input:text标签。path为input中的name属性值
    >     
    >     3. ```<form:radiobuttons path="xxx" items="${xxx}" />```：
    >     
    >        替换普通的input:radio标签。
    >        
    >        path为name属性值；items为作用域中的map集合，map集合一般是在控制器方法中定义并设置的普通HashMap，然后放入作用域。form:radio会遍历map集合的键值对，生成普通的input:radio的value和代表的值的对应关系
    >        
    >        如果和对应的回显数据相同，自动为checked，自动选中
    >     
    >     4. ```<form:select path="xxx" items="${xxx}" itemLabel="xxx" itemValue="xxx" />```：
    >     
    >        替换普通的input:select标签。
    >     
    >        path属性，name属性；items属性，遍历作用域中的指定map集合；itemLabel属性，展示在原始options标签中间的值，如果是遍历后的对象属性，直接写属性名；itemValue属性，原始options标签value属性的值，如果是遍历后的对象属性，直接写属性名
    >     
    >        如果和对应的回显数据相同，自动为selected，自动选中
    >     
    >     5. ```<form:hidden path="xxx"/>```
    >     
    >        替换普通的input:hidden标签
    >        
    >        隐藏域回显数据
    >     
    > 4. 使用步骤
    >
    >     1. **非常重要：先在作用域中设置comman属性，属性值为回显数据的依据对象，不回显则new一个空的对象**
    >     
    >     2. jsp界面，引入form命名空间
    >     
    >         ```
    >         <%@ taglib uri="http://www.springframework.org/tags/form" prefix="form" %>
    >         ```
    >         
    >     3. 使用form
    >     
    >         1. 替换form标签
    >         
    >         2. 替换input标签，保证回显数据
    >     
    > 5. 可以通过设置```<form:form>```标签的modelAttribute属性，自定义回显对象的名字，不用使用默认的command。注意，设置了该属性，必须保证控制器方法中有该属性的对象传入到作用域。
    >
    > 6. 使用了form，就不用使用两个jsp来做添加和修改信息了。因为回显的信息存在于回显对象，如果回显对象为空的对象，则就是添加界面；如果回显对象不为空的对象，则就是修改。只不过对jsp页面需要进行一些小的修改
    >
    >     * 对jsp界面的修改：
    >     
    >        对于添加页面：没有_method为PUT、没有存储id的隐藏域。
    >        
    >        对于修改页面：有_method为PUT、form:hidden隐藏域中有id
    >        
    >        通过c:if判断，判断回显对象是否为空的对象，即回显对象中某个属性是否有值，如果有值，为修改，有_method为PUT、form:hidden隐藏域中有id
    >        
    >         ```
    >        <c:if test="${not empty command.id}">
    >        <%-- 不是空的对象，为修改界面--%>
    >         <form:hidden path="id" />
    >            <input type="hidden" name="_method" value="PUT">
    >        </c:if>
    >         ```
    >        
    >         * **注意：从原理上说form:hidden中没有设置值的属性，因此，如果要传递\_method，必须用普通的input:hidden才能设置。从逻辑上说，form中是为了将数据最终在服务端封装，而\_method是为了在改变请求状态为PUT的，因此\_method不能用form，要用普通的input:hidden **
    >        
### 14. 静态资源处理
14. 静态资源处理 
    > 1. 前言
    >
    >    springMVC中，默认从客户端发送的请求都是交给SpringMVC的DispatcherServlet处理。但是DispatcherServlet只能处理与控制层方法映射的请求，无法处理静态资源请求
    >    
    >    因此，我们需要使用Tomcat自带的Servlet来处理静态资源的请求。
    >    
    >    我们之前的普通项目，之所以静态资源能够加载，都是靠的Tomcat的Servlet处理静态资源的请求。
    >    
    > 2. Tomcat的Servlet
    >
    >    在Tomcat的web.xml中，我们可以看到它自带了一个名为defaultServlet的Servlet，同时可以看到该Servlet的url-pattern也是/。
    >    
    > 3. 处理静态资源请求
    >
    >     1. 方式
    >     
    >        在springMVC的配置文件中，添加如下配置
    >        
    >         ```
    >        <mvc:default-servlet-handler />
    >        <mvc:annotation-driven />
    >         ```
    >        
    >     2. ```<mvc:default-servlet-handler />```作用
    >     
    >         1. 配置Tomcat中的名为defaultServlet的Servlet
    >         
    >         2. 让客户端的请求分流。**如果多个Servlet的url-pattern都相同，则由开发人员配置的Servlet优先级高**。因此请求先经过springMVC的DispatcherServlet处理，处理不了的静态资源经过Tomcat的Servlet处理。
    >         
    >     3. ```<mvc:annotation-driven />```作用
    >     
    >        注册mvc驱动，非常强大。之后的json处理等都需要配置该标签
    >        
    >        如果和```<mvc:delfault-servlet-handler />```一起使用，可以处理静态资源
    >        
### 15. SpringMVC处理json
15. SpringMVC处理json
    > 1. json回顾
    >
    >     1. json介绍
    >
    >        **json是JS中的内置对象，或者说是JS中的一种数据类型**。作为数据交互的数据格式。
    >     2. json的格式
    >     
    >        json对象和json数组
    >     
    > 2. 部分状态码介绍（和springMVC处理json无关，只是介绍）
    >
    >     * 405：客户单请求方式和服务端解析请求方式不匹配
    >     
    >     * 400：客户端请求，服务端无法处理
    >     
    >     * 406：服务端响应，客户端无法处理
    >     
    > 3. SpringMVC处理json：springMVC默认使用jackson将Java对象转为json
    >
    >    1. @ResponseBody注解
    >    
    >       该注解用在@RequestMapping()注解的方法上，表示该控制层方法时专门用来做响应，而不是用来页面跳转的
    >       。
    >       加了@ResponseBody注解的控制层方法的返回值，会作为响应的数据返回给客户端。
    >    
    > 2. SpringMVC响应json给客户端步骤：
    >    
    >        1. 保证jackson的三个jar包已经引入
    >        
    >        2. 保证```<mvc:annotation-driven />```在SpringMVC中已经配置，该标签会让jackson自动解析java对象为json 
    >    
    >     3. 控制层中，响应json数据的方法加上@ResponseBody注解
    >    
    >     4. 如果想要响应json数据给客户端，只需方法返回值写为要转换为json的Java数据，如JavaBean对象、ArrayList等即可。
    >    
    >            * jackson的jar包导入并且配置了```<mvc:annotation-driven />```标签，SpringMVC会自动使用jackson将Java对象转为json响应给客户端
    >    
    > 4. 源码剖析
    >
    >     1. HttpMessageConverter原理
    >     
    >         1. 介绍
    >         
    >            HttpMessageConverter<T>是spring3.0新添加的接口负责：1.将请求信息转为Java对象发给SpringMVC；2.将SpringMVC返回的Java对象转为响应信息
    >            
    >         2. SpringMVC能够通过jackson转化Java对象原理
    >         
    >            DispatcherServlet默认装配了RequestMappingHandlerAdapter，	加入jackson的jar包后RequestMappingHandlerAdapter默认装配MappingJackson2HttpMessageConverter
    >            
    >             * HandleAdapter：翻译为，处理器适配器
    >         
    >     2. 广度剖析
    >     
    >         1. **使用了@ResponseBody注解，可以开启消息转换器，即HttpMessageConverter<T>的实现类，来帮助做Java对象的json转换。**
    >         
    >         2. **HttpMessageConverter<T>重要的实现类：MappingJackson2HttpMessageConverter、StringHttpMessageConverter。**
    >         
    >            如果返回结果为Java对象，则启用MappingJackson2HttpMessageConverter，使用jackson2组件将Java对象序列化为json；
    >            
    >            如果返回结果为String，则启用StringHttpMessageConverter，String原样输出
    >            
    >         3. **Java自带的对象都实现了Serializable接口，可以序列化为json；自己定义的Java对象必须手动实现Serializable接口才可以进行序列化**
    >            
### 16. 文件上传和下载
16. 文件上传和下载：一般不自己写
    > 1. 文件下载
    >
    >     * 前端：点击a标签发送下载请求
    >     
    >     * 后台：
    >     
    >         ```
    >         	@RequestMapping(value = "/xxx", method = RequestMethod.GET)
    >             public ResponseEntity<byte[]> download(HttpServletSession session) {
    >                 // 获取文件路径
    >                 String realPath = session.getServletContext().getRealPath("下载文件所在的文件夹路径");
    >                 String finalPath = realPath + File.separator + "请求的下载文件文件名";
    >                 // 使用输入流读取文件到内存
    >                 InputStream inputStream = null;
    >                 byte[] bytes = null;
    >                 try {
    >                     inputStream = new FileInputStream(finalPath);
    >                     // 创建ResponseEntity<byte[]>，new ResponseEntity<>(文件的字节数组, 响应头信息, 设置状态码)
    >                     bytes = new byte[inputStream.available()]; // inputStream.available() -- 获取输入流所读取文件的最大字节
    >                     inputStream.read(bytes);
    >                 } catch (FileNotFoundException e) {
    >                     e.printStackTrace();
    >                 } catch (IOException e) {
    >                     e.printStackTrace();
    >                 }
    >                 HttpHeaders headers = new HttpHeaders(); // 通过HttpHeaders设置响应头信息，设置以附件形式下载
    >                 headers.add("Content-Disposition", "attachment;filename=" + "下载文件文件名" + ".文件MIME类型");
    >                 HttpStatus status = HttpStatus.OK; //设置状态码
    >                 ResponseEntity<byte[]> entity = new ResponseEntity<>(bytes, headers, status);
    >                 return entity;
    >             }
    >         ```
    >     
    > 2. 文件上传
    >
    >     1. 介绍
    >     
    >        SpringMVC对上传到服务器的文件会做一个简单的封装，由File类型封装成MultipartFile类型
    >        
    >     2. 注意事项：
    >     
    >        1. MultipartResolver接口
    >     
    >           可以封装File对象为MultipartFile对象。实现类为CommonsMultipartResolver
    >           
    >           Java中只有File对象才能表示一个文件，因此，上传的文件会变成File对象，然后经过MultipartResolver实现类封装，才能最终成为我们需要的MultipartFile对象。
    >           
    >           因此，**SpringMVC中上传文件必须先在SpringMVC配置文件中，配置CommonsMultipartResolver**
    >     
    >     3. 步骤
    >     
    >         * 配置CommonsMultipartResolver：**注意，id必须为multipartResolver**
    >         
    >             1. 导入commons-fileupload-xx.xx.x.jar和comons-io-xx.x.jar 
    >             
    >             2. 配置 
    >         
    >                 ```
    >             <bean class="org.springframework.web.multipart.commons.CommonsMultipartResolver" id="multipartResolver">
    >                     <!-- 所有属性都有默认值，一般不配置属性。如果要配置，用以下两种属性举例-->
    >                     <!-- 字符编码，必须和页面的编码保持一致。有默认值，一般不配置-->
    >                     <property name="defaultEncoding" value="UTF-8" />
    >                     <!-- 支持最大上传文件大小，因为xml的纯文本特性，无法解析表达式，必须写具体大小，单位是字节。有默认值，一般不配置-->
    >                     <property name="maxUploadSize" value="65535" />
    >             </bean>
    >                 ```
    >         
    >         * 前端：form表单设置enctype="multipart/form-data"，上传文件
    >         
    >         * 后台：
    >         
    >             * 普通方式
    >         
    >                 ```
    >             /**
    >                  * 上传文件
    >                  * @param desc 上传文件描述
    >                  * @param multipartFile 上传文件封装成的MultipartFile对象
    >                  * @return
    >                  */
    >                 @RequestMapping(value = "/upLoad", method = RequestMethod.POST)
    >                 public String upload(String desc, MultipartFile multipartFile, HttpSession httpSession) throws IOException {
    >                     // 获取上传文件名称
    >                     String filename = multipartFile.getOriginalFilename();
    >                     // 获取想要文件上传文件夹的真实路径
    >                     String realPath = httpSession.getServletContext().getRealPath("上传文件的文件夹名称");
    >                     // 拼接地址
    >                     // 通过uuid解决文件重名问题。uuid + .原来文件后缀
    >                 String finalFileName = UUID.randomUUID() + filename.substring(filename.lastIndexOf("."));
    >                     String path = realPath + File.separator + finalFileName;
    >                 
    >                     // 获取输入流
    >                     InputStream is = multipartFile.getInputStream();
    >                     // 获取输出流
    >                 File file = new File(path);
    >                     OutputStream os = new FileOutputStream(file);
    >                 
    >                     // 上传文件到服务器文件夹
    >                     int i = 0;
    >                     byte[] bytes = new byte[1024];
    >                     while ((i = is.read(bytes)) != -1) {
    >                         os.write(bytes, 0, i);
    >                     }
    >                 os.close();
    >                     is.close();
    >                 
    >                     // 跳转到上传成功页面
    >                     return "success";
    >                 }
    >                 ```
    >                 
    >             * SpringMVC提供的简单方式（推荐）
    >             
    >                 ```
    >                 /**
    >                      * 上传文件
    >                      * @param desc 上传文件描述
    >                      * @param multipartFile 上传文件封装成的MultipartFile对象
    >                      * @return
    >                      */
    >                     @RequestMapping(value = "/upLoad", method = RequestMethod.POST)
    >                     public String upload(String desc, MultipartFile multipartFile, HttpSession httpSession) throws IOException {
    >                         // 获取上传文件名称
    >                         String filename = multipartFile.getOriginalFilename();
    >                         // 获取想要文件上传文件夹的真实路径
    >                         String realPath = httpSession.getServletContext().getRealPath("上传文件的文件夹名称");
    >                         // 拼接地址
    >                     	// 通过uuid解决文件重名问题。uuid + .原来文件后缀
    >                     	String finalFileName = UUID.randomUUID() + filename.substring(filename.lastIndexOf("."));
    >                    	    String path = realPath + File.separator + finalFileName;
    >                     
    >                         // 获取File对象
    >                         File file = new File(path);
    >                 
    >                         multipartFile.transferTo(file);
    >                         
    >                         return "success";
    >                     }
    >                 ```
    >                 
    >         4. 多文件上传
    >         
    >             * 前端：多文件上传的form表单
    >             
    >             * 后台：只需要将MultipartFile改为MultipartFile[]，然后遍历即可
    >             
    >                 * 使用SpringMVC简单方式
    >                 
    >                     ```
    >                 /**
    >                          * 上传文件
    >                          * @param desc 上传文件描述
    >                          * @param multipartFile 上传文件封装成的MultipartFile对象数组
    >                          * @return
    >                          */
    >                         @RequestMapping(value = "/upLoad", method = RequestMethod.POST)
    >                         public String upload(String desc, MultipartFile[] multipartFile, HttpSession httpSession) throws IOException {
    >                             
    >                             for (MultipartFile mul:
    >                                  multipartFile) {
    >                     
    >                                 // 获取上传文件名称
    >                                 String filename = mul.getOriginalFilename();
    >                                 // 获取想要文件上传文件夹的真实路径
    >                                 String realPath = httpSession.getServletContext().getRealPath("上传文件的文件夹名称");
    >                                 // 拼接地址
    >                                 // 通过uuid解决文件重名问题。uuid + .原来文件后缀
    >                                 String finalFileName = UUID.randomUUID() + filename.substring(filename.lastIndexOf("."));
    >                                 String path = realPath + File.separator + finalFileName;
    >                     
    >                     
    >                                 // 获取File对象
    >                                 File file = new File(path);
    >                     
    >                                 mul.transferTo(file);
    >                                 
    >                             }
    >                     
    >                             return "success";
    >                         }
    >                     ```
    >                     
### 17. 拦截器
17. 拦截器
    > 1. 自定义拦截器概述
    >
    >    SpringMVC可以使用拦截器对请求进行拦截处理，用户可以自定义拦截器来实现特定功能
    >    自定义拦截器可以实现HandlerInterceptor接口，也可以继承HandlerInterceptorAdapter适配器类。
    >    
    >    HandlerInterceptorAdapter适配器，其实只是单纯的实现了HandlerInterceptor接口，是个空的类。
    >    
    > 2. HandlerInterceptor接口的方法
    >
    >     * preHandle()
    >
    >        该方法在业务处理器处理请求之前调用，该方法对用户请求request进行处理
    >        。
    >        
    >        **可以理解为在控制器方法的return之前，或者说是获取ModelANdView对象之前调用。**
    >        
    >        如果程序要需要在该拦截器进行拦截处理后，还需要调用其他的拦截器或者使用业务处理器进行处理，则返回true。可以理解为返回true，放行。
    >        
    >        如果不需要调用其他组件处理请求，则直接返回false。可以理解为返回false，拦截。	
    >        
    >     * postHandle() 
    >
    >        该方法在业务处理器处理请求之后，但是DispatcherServlet向客户端返回响应之前调用，对用户请求request进行处理。
    >        
    >        **可以理解为在控制器方法的return之后，或者说是获取ModelAndView对象之后调用。**
    >        
    >     * afterCompletion()
    >
    >        在DispatcherServlet完全处理请求之后被调用。可以在该方法中进行一些资源清理的操作。
    >        
    >        **可以理解为类似AOP中的后置通知，finally中的代码。无论是否return或者说是否获取到ModelAndView对象，都要执行该方法。**
    >
    > 3. 过滤器和拦截器区别
    >
    >    SpringMVC添加过滤器，添加在客户端和DispatherServlet之间。用来对客户端发送的请求进行过滤。
    >    
    >    SpringMVC添加拦截器，添加在DispatcherServlet和控制层之间。
    >    
    > 4. 拦截器定义
    >
    > 5. 拦截器使用
    >
    >     1. 自定义拦截器类
    >     
    >     2. 在SpringMVC的配置文件中配置拦截器
    >     
    >         ```
    >         <!-- 在mvc:interceptors标签中配置全部的拦截器-->
    >             <mvc:interceptors>
    >                 <!-- 默认拦截所有请求的配置-->
    >                 <!-- 如果自定的拦截器类，没有使用@Component注解-->
    >                 <bean class="自定义拦截器的全类名"></bean>
    >                 <!-- 如果自定义的拦截器类，使用@Component注解交给spring管理了，这里只需要用ref来引入即可-->
    >                 <ref bean="bean的id" />
    >                 
    >                 <!-- 自定义拦截方式-->
    >         		<mvc:interceptor>
    >         			<bean></bean>
    >         			<!-- 拦截哪些请求 -->
    >         			<mvc:mapping path"" />
    >         			<!-- 排除哪些情趣 -->
    >         			<mvc:exclude-mapping path="" />
    >         		</mvc:interceptor>
    >             </mvc:interceptors>
    >         ```
    >     
    > 6. **拦截器执行顺序（非常重要）**
    > 
    >     * SpringMVC底层设置好了拦截器执行顺序，通过设置多个拦截器，然后debug可知：
    >         1. 所有拦截器默认按照配置中定义的顺序从前往后
    >         
    >         2. 请求进来，先获取处理该请求的拦截器数组，从前往后遍历拦截器，执行他们的preHandle()方法。如果有任何拦截器的preHadle()方法返回false，从后往前依次调用之前为true的拦截器的afterCompletion()方法释放资源，然后终止请求。
    >         
    >         3. 获取处理请求的拦截器数组，从后往前遍历拦截器，执行postHandle()方法
    >         4. 获取处理请求的拦截器数组，从后往前遍历拦截器，执行方法afterCompletion()方法
    >         
### 18. 异常处理
18. 异常处理
    > 1. 概述
    >
    >    SpringMVC用HandlerExceptionResolver接口的实现类处理程序的异常，包括Handler映射、数据绑定、目标方法执行时发生的异常。  
    >    
    > 2. HandlerExceptionResolver接口
    >
    >     1. DefaultHandlerExceptionResolver类：
    >     
    >        SpringMVC提供的，处理普通的异常的类。它将一些普通的异常做了处理。出现普通的异常，SpringMVC会自动调用该类处理该异常。
    >        
    >     2. SimpleMappingExceptionResolver类
    >     
    >         1. 介绍
    >         
    >            SpringMVC对于DefaultHandlerExceptionResolver解决不了的异常，定义的异常处理类。
    >            
    >            在该类中，自定义异常处理的方式
    >            
    >         2. 使用方式
    >         
    >             * 在SpringMVC中配置该类
    >             
    >                 ```
    >                 <bean class="org.springframework.web.servlet.handler.SimpleMappingExceptionResolver">
    >                         <property name="exceptionMappings" >
    >                             <props>
    >                                 <!-- 出现某个异常，跳转到某个可以被视图解析器解析的页面，可以定义多个-->
    >                                 <prop key="异常全类名">出现该异常后跳转的页面名称</prop>
    >                             </props>
    >                         </property>
    >                     </bean>
    >                 ```
    >             
    >          3. SimpleMappingExceptionResolver类将出现的异常放入request作用域中，键名就为exception。我们可以在跳转的页面中获取异常，通过```${exception}```从作用域中获取
    > 
### 19. SpringMVC工作流程
19. SpringMVC工作流程
    > 1. 见视频
    > 
### 20. Spring整合SpringMVC
20. Spring整合SpringMVC
    > 1. SpringMVC和Spring不整合带来的问题
    >
    >    SpringMVC的配置文件中有扫描组件，即SpringMVC的容器已经管理了Java类。因此，不整合的话Spring就将需要管理的组件也交给SpringMVC管理。这样就只需要一个SpringMVC的配置文件即可。
    >    
    >    但是，这样会导致SpringMVC的逻辑混乱，不好。
    >    
    > 2. 如何整合Spring和SpringMVC
    >
    >    整合的关键点就是Spring配置文件什么时候加载，如何加载
    >    
    > 3. spring配置加载
    >
    >    spring必须保证在项目启动时就加载，并且是在Servlet加载前就必须加载。
    >    
    >    在web.xml配置文件中，Servlet永远是最晚加载的，Filter稍快加载，Listner最快加载。
    >    
    >    因为Filter在每次请求时都会起作用，如果将spring加载放入Filter就会导致每次请求都会创建对象，因此不允许将spring加载放入Filter
    >    
    >    因为Listner作用是，监听程序运行过程中的各种事件，如某个参数是否被创建等。因此，我们可以创建一个Listner监听Servlet的生命周期，只要Servlet被创建，就立刻加载Spring配置文件。 
    >    
    > 4. 整合Spring
    >
    >    通过上述可知，我们要使用Listner来加载spring。在spring中已经提供了加载spring的监听器，只用在web.xml中引入：
    >    
    >     ```
    >    <listener>
    >            <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
    > </listener>
    >     ```
    >    
    >     * 注意：只是单纯引入了Listne，**此时启动会报错```BeanFactory not initialized or already closed```，出现该错说明找不到spring配置文件或spring配置文件没创建或spring配置文件有错误**。因此，我们需要创建spring配置文件。spring配置文件默认应该放在WEB-INF中，为了制定spring配置文件的位置和名称，我们需要在web.xml中，一般是加载spring的监听器标签后添加以下标签：
    >    
    >          ```
    >          <context-param>
    >              <param-name>contextConfigLocation</param-name>
    >              <param-value>classpath:spring配置文件名称</param-value>
    >          </context-param>
    >          ```
    >    
    > 5. bean被创建两次的问题
    >
    >    spring配置文件和SpringMVC的配置文件都有扫描器，@Controller注解的bean会被创建两次。
    >    
    >     * 解决方法：SpringMVC只扫描控制层；spring扫描时，排除控制层
    >    
    > 6. Spring和SpringMVC关系
    >
    >    Spring的容器是父容器，SpringMVC的容器是子容器
    >    
    >     * **规定：子容器可以调用自己或者父容器的bean；父容器只能调用自己的bean，不可以访问子容器的bean**。因此SpringMVC管理的Controller的类，可以自动装配Service、Dao的类。
    >    
# 3. MyBatis
## 1. MyBatis简单介绍
1. MyBatis简单介绍
    > 1. MyBatis简介
    > 
    >     1. MyBatis支持定制化SQL、存储过程以及高级映射的优秀的持久层框架
    >        
    >     2. MyBatis避免了几乎所有JDBC代码和手动设置参数以及获取结果集
    >        
    >     3. MyBatis可以使用简单的XML或注解用于配置和原始映射，将接口和Java的POJO映射成数据库中的记录
    >     
    >     4. MyBatis是半自动的ORM框架
    >     
    >         * ORM：Object Relation Mapping，对象关系映射
    >     
    > 2. 现有持久化技术对比
    > 
    >     1. JDBC：
    >     
    >         1. sql语句夹杂在Java代码块中，耦合度高导致代码硬伤
    >         
    >         2. 维护不易，且实际开发中SQL有变化，频繁修改的情况很常见
    >         
    >     2. Hibernate和JPA：
    >     
    >         1. 长难的复杂SQL对于Hibernate维护也不容易
    >         
    >         2. 内部自动生产SQL，不易做特殊优化
    >         
    >         3. 基于全映射的全自动框架，大量字段的POJO进行部分映射比较困难，导致数据库性能下降。
    >         
    >     3. MyBatis：
    >     
    >         1. 对开发人员而言，核心SQL还需要自己优化
    >         
    >         2. SQL和Java编程分开，功能边界清晰，一个专注业务、一个专注数据
    >         
## 2. 环境搭建
2. 环境搭建
    > 1. 导入jar包和配置文件
    >
    >     * log4j.jar和log4j.xml
    >     
    >         * 要将log4j.xml中的配置文件中修改：```<log4j:configuration xmlns:log4j="http://logging.apache.org/log4j/1.2/apidocs/org/apache/log4j/xml/doc-files/log4j.dtd">```
    >         
    >         * dtd文件就是定义XML文档的合法构建模块
    >     
    >     * mysql-connection.xx.xx.x.jar
    >     
    >     * mybatis-xx.x.x.jar
    >
    > 2. 创建MyBatis核心（全局）配置文件mybatis-config.xml，并配置。核心配置文件体现如何连接数据库以及一些基本配置。
    >
    >     * 如果xml中出现了```URI 未注册(设置 | 语言和框架 | 架构和 DTD)错误```，则需要导入外部资源
    >
    >     * 以test数据库举例：
    >
    >         ```
    >         <?xml version="1.0" encoding="UTF-8" ?>
    >         <!DOCTYPE configuration
    >                 PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
    >                 "http://mybatis.org/dtd/mybatis-3-config.dtd">
    >         <configuration>
    >             <environments default="development">
    >                 <environment id="development">
    >                     <!-- 用原始的JDBC方式连接数据库，之后我们对数据库管理都会交给spring管理-->
    >                     <transactionManager type="JDBC"/>
    >                     <dataSource type="POOLED">
    >                         <property name="driver" value="com.mysql.jdbc.Driver"/>
    >                         <property name="url" value="jdbc:mysql:///test"/>
    >                         <property name="username" value="root"/>
    >                         <property name="password" value="root"/>
    >                     </dataSource>
    >                 </environment>
    >             </environments>
    >             <!-- 在<mappers>中，引入所有的映射文件。-->
    >             <mappers>
    >                 <mapper resource="UserMapper.xml"/>
    >             </mappers>
    >         </configuration>
    >         ```
    >
    > 3. 创建映射文件并配置。每个表都有一个映射文件，命名格式为XxxMapper.xml，如User表的映射文件为UserMapper.xml。映射文件体现如何操作数据库。
    >
    >     * 以User表举例，映射文件：
    >
    >         ```
    >         <?xml version="1.0" encoding="UTF-8" ?>
    >         <!DOCTYPE mapper
    >                 PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
    >                 "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
    >         
    >         <mapper namespace="org.mybatis.example.BlogMapper">
    >             <select id="selectBlog" resultType="Blog">
    >                 select * from Blog where id = #{id}
    >             </select>
    >         </mapper>
    >         ```
    >
    > 4. 创建Mapper接口，实现两个绑定
    >
    >     * 以User表的Mapper接口举例。先创建User实体类，然后创建UserMapper接口并实现绑定
    >         1. 创建UserMapper接口：
    >
    >             ```
    >             package com.yuu.mapper;
    >             
    >             import com.yuu.bean.User;
    >             
    >             public interface UserMapper {
    >                 /**
    >                  * 根据传入的用户id获取用户信息
    >                  * @param uid
    >                  * @return
    >                  */
    >                 User getUserByUid(String uid);
    >             }
    >             
    >             ```
    >             
    >         2. 将映射文件和接口进行绑定：将映射文件中的namespace改为接口的全类名
    >         
    >         3. 将映射文件中的sql语句所在标签的id和接口中方法名绑定，将resultType和实体类对象全类名进行绑定：
    >         
    >             ```
    >             <mapper namespace="com.yuu.mapper.UserMapper">
    >             	<!-- <select> 定义查询语句-->
    >                 <select id="getUserByUid" resultType="com.yuu.bean.User">
    >                     select * from user where uid = #{id}
    >                 </select>
    >             </mapper>
    >             ```
    >
    > 5. 创建MyBatis操作数据库的会话对象SqlSession，然后使用getMapper()方法获取Mapper接口的动态代理实现类
    >
    >     * 在测试类的测试方法中，做一个测试：
    >
    >         ```
    >         @Test
    >         public void test1() {
    >               try {
    >                   InputStream resourceAsStream = Resources.getResourceAsStream("mybatis-config.xml");
    >                   SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream);
    >                   SqlSession sqlSession = sqlSessionFactory.openSession();
    >                   UserMapper mapper = sqlSession.getMapper(UserMapper.class);
    >                   User userByUid = mapper.getUserByUid("1");
    >                   System.out.println(userByUid.toString());
    >               } catch (IOException e) {
    >                   e.printStackTrace();
    >               }
    >           }
    >         ```
    >         
## 3. 映射文件中的SQL语句
3. 映射文件中的SQL语句
    > 1. 通过实际测试可知，在映射文件中的SQL语句中，有两种使用传入值的方式：
    > 
    >     1. 使用```#{任意需要的名称}```
    >     
    >         使用这种方式，底层默认会使用PreparedStatement，即使用?通配符赋值方式。
    >         
    >     2. 使用```${value}```，固定写法，{}里面必须写成value。
    >     
    >	     使用该方式，底层使用Statement方式，即使用单纯的字符串拼接。该方式适合用于批量修改和删除。
    >	     
## 4. SqlSession创建和使用过程分析
4. SqlSession创建和使用过程分析
    > 1. 创建和使用过程，以上述为例
    >
    >     ```
    >     // 通过MyBatis提供的Resources类中的静态方法获取MyBatis核心文件的输入流
    >     InputStream resourceAsStream = Resources.getResourceAsStream("mybatis-config.xml");
    >     
    >     // 根据核心配置文件创建SqlSessionFactory
    >     SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream);
    >     
    >     // 使用SqlSessionFactory的openSession()方法创建SqlSession
    >     SqlSession sqlSession = sqlSessionFactory.openSession();
    >     
    >     // 我们定义的XxxMapper是接口，必须有实现类实现了接口后，我们使用实现类的对象才可以使用接口中的各种方法
    >     // getMapper()是MyBatis最核心的方法。getMapper()使用了动态代理，可以动态生成Mapper接口的代理实现类。代理对象就是接口的实现对象。然后我们使用代理对象代理的接口中的方法
    >     UserMapper mapper = sqlSession.getMapper(UserMapper.class);
    >     ```
    >
## 5. MyBatis核心配置文件中全局标签的内部标签配置
5. MyBatis核心配置文件中全局标签的内部配置
    > 1. ```<configuration>```：MyBatis核心配置文件的全局标签。**注意，MyBatis中的标签有先后顺序，必须按照顺序来写。下列常用标签顺序已经给定：properties -> settings -> typeAliases -> plugins->environments -> mappers，如果要写，必须按照顺序**
    >    
    >     1. ```<properties>```：定义一些属性给其他标签使用。
    >     
    >         1. ```<property />```：预定义的一些属性。name属性：给其他标签使用的别名。value属性：别名代表的属性。如果要用到预定义的属性，则只需要使用：${property标签name属性的值}
    >         
    >         * 由于单纯的使用property标签还是很繁琐，所以我们可以使用一个properties文件专门存储这些属性，然后使用```<properties>```标签的的resource属性或url属性引入该properties文件即可。resource属性指的是类路径引入，url属性指的是网路路径或磁盘路径下引入
    >     
    >     2. ```<settings>```：一些设置。
    >     
    >         1. ```<setting>```：具体设置。name属性：属性值参见参考文档。value属性：参见参考文档。
    >         
    >         * setting标签一些常用的name属性值及对应的value值：
    >         
    >             1. name="mapUnderscoreToCamelCase"，value="true|false"：表中字段和实体类中属性之间映射，是否可以将下划线转化为驼峰命名然后比对。以后必须保证字段名和实体类属性名一样，因此该name一般不用
    >     
    >     3. ```<typeAliases>```：类别名。别名用在需要全类名的地方
    >     
    >         1. ```<typeAlias>```：为Java类起一个更短的别名。type属性：具体的Java类全类名。alias属性：Java类的别名，可以不写，默认别名就是Java类名且不区分大小写
    >     
    >     
    >     4. ```<plugins>```：MyBatis需要的插件。
    >     
    >         1. ```<plugin>```：```<plugins>```标签的内部标签，用来配置具体的插件。inteceptor属性：具体插件的全类名
    >     
    >     5. ```<enviroments>```：在标签体中，设置连接数据库的环境，可以设置多个。default属性：用来设置默认使用的数据库环境，属性值为```<enviroment>```标签的id
    >     
    >         1. ```<enviroment>```：具体的数据库环境。id属性：数据库环境唯一标识
    >         
    >           1. ```<transactionManager>```：设置事务的管理方式。type属性：事务管理方式，属性值有两种JDBC和MANAGED，JDBC代表原生JDBC管理，MANAGED代表交给能管理的管理如spring中的声明式事务管理，之后都是交给spring管理
    >              
    >           2. ```<datasource>```：设置数据源。type属性：属性值有，POOLED表示使用MyBatis自己建立的数据库连接池，UNPOOLED表示不创建数据库连接池，JNDI使用很少。以后其实都会交给spring
    >         
    >     6. ```<mappers>```：引入映射文件，或者说是注册映射
    >     
    >         1. ```<mapper />```：具体的映射文件。resource属性：具体的映射文件的类路径。url属性：具体的映射文件的网路路径或者磁盘路径
    >     
## 6. mapper和xml的增删改查：以对Emp表的增删改查为例
6. mapper和xml的增删改查：以对Emp表的增删改查为例
    > 1. 数据库创建对应的表
    >
    > 2. 创建对应的实体类
    >
    > 3. 创建Mapper接口和映射文件  
    >
    >     * 接口
    >     
    >         ```
    >         package com.yuu.mapper;
    >         
    >         import com.yuu.bean.Emp;
    >         
    >         import java.util.List;
    >         
    >         public interface EmpMapper {
    >         
    >             // 根据id查询一个员工信息
    >             Emp getEmpByEid(String eid);
    >         
    >             // 获取所有的员工信息
    >             List<Emp> getAllEmp();
    >         
    >             // 添加员工信息
    >             void addEmp(Emp emp);
    >         
    >             // 修改员工信息
    >             void updateEmp(Emp emp);
    >         
    >             // 删除员工信息
    >             void deleteEmp(String eid);
    >         
    >         }
    >         
    >         ```
    >         
    >     * 映射文件
    >     
    >         ```
    >         <?xml version="1.0" encoding="UTF-8" ?>
    >         <!DOCTYPE mapper
    >                 PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
    >                 "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
    >         
    >         <mapper namespace="com.yuu.mapper.EmpMapper">
    >             <!-- Emp getEmpByEid(String eid); -->
    >             <select id="getEmpByEid" resultType="com.yuu.bean.Emp">
    >                 select eid, ename, age, sex from emp where eid = #{eid}
    >             </select>
    >         
    >             <!-- List<Emp> getAllEmp(); -->
    >             <!--
    >                 Mybatis非常智能，我们只需要告诉查询的数据应该放入哪一个实体类对象。
    >                 MyBatis会根据我们设置的返回值自动将实体类对象放入对应的容器中
    >             -->
    >             <select id="getAllEmp" resultType="com.yuu.bean.Emp">
    >                 select eid, ename, age, sex from emp
    >             </select>
    >         
    >             <!-- void addEmp(Emp emp); -->
    >             <insert id="addEmp">
    >                 insert into emp values(null, #{ename}, #{age}, #{sex})
    >             </insert>
    >         
    >             <!-- void updateEmp(Emp emp); -->
    >             <update id="updateEmp">
    >                 update emp set ename = #{ename}, age = #{age}, sex = #{sex} where eid = #{eid}
    >             </update>
    >         
    >             <!-- void deleteEmp(String eid); -->
    >             <delete id="deleteEmp" >
    >                 delete from emp where eid = #{eid}
    >             </delete>
    >         </mapper>
    >         ```
    >     
    > 4. 在MyBatis配置文件中注册映射文件
    >
    > 5. 使用 
    >
    >     * 使用时，因为我们在MyBatis的配置文件中写入了  ```<transactionManager>```：设置事务的管理方式。我们设置的type=JDBC即使用JDBC原生的事务管理。因此在删除、添加、修改表中数据时都是通过事务来操作的，提交和回滚需要手动处理。因此我们需要手动提交事务。一个SqlSession代表了一个数据库连接。如果要提交事务，使用sqlSession.commit()
    >     
    >     * 我们在获取SqlSession时，使用```SqlSession sqlSession = sqlSessionFactory.openSession();```，则需要手动提交事务。如果使用```SqlSession sqlSession = sqlSessionFactory.openSession(true);```，则可以自动提交事务
    >     
    >     * 增删改语句对应的方法，可以有三种返回值：void、Integer、Boolean。Integer代表受影响行数，Boolean代表操作是否成功
    >     
## 7. 通过package标签管理映射文件的注册
7. 通过package标签管理映射文件的注册  
    > 1. 在MyBatis配置文件中，引入映射文件如果使用```<mapper>```标签一个个引入，对于映射文件过于多的情况会十分繁琐
    > 
    > 2. 通过```<package>```标签引入映射文件：**使用这种方式引入映射文件必须保证映射文件放在Mapper接口的包中。**
    > 
## 8. MyBatis查询
8. MyBatis查询
    > 1. MyBatis查询：
    >
    >     1. 查询单个信息，返回一个实体类对象：
    >     
    >         * 接口
    >         
    >             ```
    >             // 根据id查询一个员工信息
    >             Emp getEmpByEid(String eid);
    >             ```
    >             
    >         * 映射文件中
    >         
    >             ```
    >             <!-- Emp getEmpByEid(String eid); -->
    >             <select id="getEmpByEid" resultType="com.yuu.bean.Emp">
    >                select eid, ename, age, sex from emp where eid = #{eid}
    >             </select>
    >             ```
    >         
    >     2. 查询单个信息，返回一个Map对象：返回一个List集合的情况，上述已知了，resultType只需要写实体类即可。但是返回Map对象，resultType要写Map对象的全类名。Map对象中将字段名和值作为键值对存储。
    >     
    >         * 接口
    >         
    >             ```
    >             // 根据id查询一个员工信息
    >             Map<String, Object> getEmpByEid(String eid);
    >             ```
    >             
    >         * 映射文件
    >         
    >             ```
    >             <!-- Map<String, Object> getEmpByEid(String eid); -->
    >             <select id="getEmpByEid" resultType="java.util.HashMap">
    >                 select eid, ename, age, sex from emp where eid = #{eid}
    >             </select>
    >             ```
    >         
    >     3. 查询所有信息，返回一个Map对象：返回Map对象，resultType要写Map对象的全类名。返回的Map对象中，查询出来的信息封装的实体类对象作为值，而键必须要有，因此我们通过@MapKey("字段名")注解指定某个字段的值作为键
    >     
    >         * 接口
    >         
    >             ```
    >             // 获取所有的员工信息
    >             @MapKey("eid") // 设置Map对象的键，这里我们选择以查询的对象的eid作为键
    >             Map<String, Object> getAllEmp();
    >             ```
    >             
    >         * 映射文件
    >         
    >             ```
    >             <!-- Map<String, Object> getAllEmp(); -->
    >             <select id="getAllEmp" resultType="java.util.HashMap">
    >                 select eid, ename, age, sex from emp
    >             </select>
    >             ```
    >             
## 9. MyBatis映射文件中的parameterType
9. MyBatis映射文件中的parameterType
    > 1. 在映射文件中的insert标签和update标签等，它们都有parameterType属性。该属性指定执行sql语句时，在接口中的对应方法传递的参数类型。
    > 
    > 2. MyBatis里面有专门的类型推算机制，因此我们不写parameterType属性也可以。**因为如果我们自己写可能写错类型，因此该属性千万别写**。 
    > 
## 10. MyBatis获取参数值的两种方式${}和#{}
10. MyBatis获取参数值的两种方式${}和#{}
    > 1. #{}：大部分情况使用
    > 
    >    底层使用的是PreparedStatement对象进行数据库操作，#{}实际上是通配符。**因为是给通配符赋值的方式，因此字符串不用加单引号**
    >    
    > 2. ${}：在特殊情况使用，例如模糊查询、批量修改和删除
    > 
    >    底层使用的是Statement对象进行数据库操作，${}括号中实际上是和SQL语句拼接的内容。**因为是拼接方式，如果需要拼接字符串，使用该方式则必须把${}用单引号引起来，例如：```insert into emp values(null, '${param1}', ${param2}, '${param3}')```**。
    >   
    >     
## 11. MyBatis实现添加时获取自动生成的主键
11. MyBatis实现添加时获取自动生成的主键
    > 1. 主键生成方式
    > 
    >     * 支持主键自增：例如MySql数据库和SQL Server数据库
    >     
    >     * 不支持主键自增：例如Oracle数据库
    >     
    > 2. 假设有个需求：插入一条新数据，立刻获取该数据的主键。
    > 
    >    我们第一个想到的可能是通过name或其他属性获取，但是name或其他属性可能重名；第二个想到可以通过SQL中的max()函数获取，该方法在面对多线程高并发时就无法实现了。
    >    
    >    原生的JDBC可以实现该功能，通过设置conn.preparedStatement("带通配符的SQL", 非0的int值一般写1)，在执行完ps.executeUpdate()方法后，使用ps.getGenerateKeys()获取ResulSet结果集rs，之后rs.next()指针后移，re.getInt(1)返回的就是数据主键。
    >    
    >    MyBatis封装了JDBC，因此也提供了获取主键值的方式
    > 
    > 3. 获取主键的值
    > 
    >     1. 对于可以主键自增的数据库：
    >     
    >        在映射文件中，对于insert标签和update标签：
    >        
    >        1、添加useGeneratedKeys="true"属性。该属性默认开启，但是建议写上
    >        
    >        2、添加keyProperty属性，属性值为：将主键赋给实体类中的属性属性名，例如方法传入Emp对象，keyProperty="eid"
    >        
    >        3、SQL执行后，就会自动将主键赋给对象中的keyProperty指定的属性，通过getter方法获取即可。例如上述的emp.getEid()
    >        
    >    2. 对于不可以主键自增的数据库
    >    
    >        在映射文件中，在insert标签和update标签：
    >        
    >        1、在标签体中，先添加selectKey标签，在selectKey标签体中写查询语句，selectKey标签将会首先运行，id会被设置：
    >        
## 12. MyBatis获取不同类型参数的参数值
12. MyBatis获取不同类型参数的参数值
    > 1. 方法参数为一个字符串、基本数据类型、基本数据类型的包装类
    > 
    >     * #{}：括号中可以写任意的字符，但是建议写成相同参数名。因为#{}是通配符赋值，传递一个参数就只会和唯一的?绑定。
    >     
    >     * ${}：括号中必须写value或_parameter。字符串要注意单引号拼接问题。
    >     
    > 2. 方法参数为一个JavaBean时
    > 
    >     * #{}：括号中写属性名。MyBatis会通过getter方法获取属性值然后赋给对应位置的通配符。
    >     
    >     * ${}：括号中写属性名。MyBatis会通过getter方法获取属性值然后拼接SQL。字符串要注意单引号拼接问题。
    >     
    > 3. 方法参数为多个字符串、基本数据类型、基本数据类型包装类
    > 
    >     * **多个参数MyBatis会默认将参数放入map集合中，map集合的键为0, 1, ...或 param1, param2, ...，以参数为值**
    > 
    >     * #{}：括号中必须写param1, param2, ...或0, 1, 2, ...，它们代表第几个参数。MyBatis通过括号中写的，将第几个参数传给#{}对应的通配符。为保持一致，一般#{}中写param1, param2, ...
    >     
    >     * ${}：括号中必须写param1, param2, ...，它们代表了第几个参数。不能使用0, 1, 2...，因为它们在${}中被认为是普通字符。MyBatis通过括号中写的，将第几个参数与SQL拼接。字符串要注意单引号拼接问题。
    >     
    > 4. 传入Map集合为方法参数
    > 
    >     * #{}：写入Map集合的键名。MyBatis通过键名寻找Map中的值，赋给通配符。
    >     
    >     * ${}：写入Map集合的键名。MyBatis通过键名寻找Map中的值，拼接SQL。字符串要注意单引号拼接问题。
    >     
    > 5. 命名参数方式：方法参数为多个字符串、基本数据类型、基本数据类型包装类。**但是我们为每个参数都添加@Param("键名")注解。**我们以后就不用传统的多个参数方式，而采用命名参数方式。
    > 
    >     * MyBatis会将参数放入map集合中，并且根据@Param("键名")注解，在Map集合中以该键名作为键，参数作为值。
    >     
    >     * #{}：写入@Param("键名")的键名。MyBatis通过键名寻找Map中的值，赋给通配符。
    >     
    >     * ${}：写入@Param("键名")的键名。MyBatis通过键名寻找Map中的值，拼接SQL。字符串要注意单引号拼接问题。
    >     
    > 6. 传入List/Array为方法参数
    > 
    >    * MyBatis会将List/Array放入Map集合中，List以字符串"list"为键，Array以字符串"array"为键
    >    
## 13. 命名参数方式传递参数进行数据库操作
13. 命名参数方式传递参数进行数据库操作
    > 1. 具体见参见视频
    > 
    > 2. 部分步骤：1、MyBatis中有一个Command对象，该对象的name属性记录了SQL的Mapper接口全类名和具体执行SQL的方法名，形式为```com.yuu.mapper.UserMapper.getUserByUid```；该对象的type属性记录了SQL的类型，类型包括：SELECT, DELETE, INSERT, UPDATE。2、通过switch语句，对command.getType()的type属性进行判断
    > 
## 14. 多对一自定义映射
14. 多对一自定义映射
    > 1. 多对一的建立
    >
    >     1. 数据库中建立两张表，在多这一方的表上，指定外键字段
    >     
    >     2. 建立两个实体类对应两张表，多的一方的实体类中，添加一个属性为另一个实体类
    >     
    >     3. 建立一个多对一的Mapper接口，书写多对一的查询语句
    >     
    >     4. 建立一个多对一映射文件，书写多对一的SQL语句
    >     
    >     5. 注册映射文件
    >     
    > 2. resultMap
    >
    >     1. 介绍
    >       
    >         由于MyBatis默认的简单映射resultType为只要字段名和属性名一致就可以赋值。
    >         但是进行多表联查时，简单映射无法满足条件，因此我们需要进行高级映射。resultMap就是用来完成高级映射的。
    >         
    >         因此，我们需要在多表联查的select标签上，不使用resultType属性，而使用resultMap属性
    >         
    >         resultMap就是用来自定义映射的，也叫高级映射。
    >         
    >     2. resultMap标签：专门用来做高级映射，resultMap标签体中有id标签，result标签，association标签，Collection标签
    >     
    >         * id标签：用来设置主键的映射关系。column属性：值为主键的字段名；property属性：值为对象中的属性名。
    >         
    >         * result标签：用来设置其他字段的映射关系。column属性：值为查询的其他字段名；property属性：值为对象中属性名。
    >         
    >             * property属性的属性值支持级联操作，因此字段名如果映射到某个对象的某个属性，则只需要将property的属性值写成某个对象全类名.属性名
    >             
    >         * association标签：专门用来做多对一、一对一关系。property属性：无法通过字段名赋值的属性；javaType属性：无法通过字段名赋值的属性对应的java对象全类名。select属性：使用多表查询的分布查询方式用到，找到一个SQL语句用查询出来的结果为property属性赋值。association标签也需要设置id标签和result标签 
    >         
    >             * id标签：用来设置主键的映射关系。column属性：值为主键的字段名；property属性：值为对象中的属性名。
    >             
    >             * result标签：用来设置其他字段的映射关系。column属性：值为查询的其他字段名；property属性：值为对象中属性名。
    >             
    >         * collection标签：专门用来做一对多、多对多关系。下面会讲。
    >         
    >     3. resultMap标签完成多对一、一对一的高级映射的三种方式
    >     
    >         1. 只使用id标签和result标签。因为通过result标签的property属性的级联特性，其实就可以完成多表联查的赋值。但是该方式不是最好的，以后也不用该方式。
    >         
    >         2. 使用id标签和result标签设置主键属性和非主键属性，无法通过字段名直接赋值的属性，使用association标签，设置property属性，设置javaType属性，然后继续在association标签中设置id标签和result标签。该方式较为常用，属于一次查询所有表的信息并封装。
    >         
    >             ```
    >             <resultMap id="empDept" type="com.yuu.bean.Emp">
    >                     <id column="eid" property="eid" />
    >                     <result column="ename" property="ename" />
    >                     <result column="age" property="age" />
    >                     <result column="sex" property="sex" />
    >                     <!-- 利用association标签完成查询 -->
    >                     <association property="dept" javaType="com.yuu.bean.Dept">
    >                         <id property="did" column="did" />
    >                         <result property="dname" column="dname" />
    >                     </association>
    >                 </resultMap>
    >                 <select id="getAllEmp" resultMap="empDept" >
    >                     select emp.eid, emp.ename, emp.age, emp.sex, emp.did, dept.dname from emp left join dept on emp.did = dept.did
    >                 </select>
    >             ```
    >         
    >         3. 使用分步查询方式：如果有多个映射文件，多个映射文件中都有查询语句。则我们可以先查询一个表中的信息，然后根据查询的信息获取另一个表的信息。
    >         
    >             * 实现方式：1、使用id标签和result标签设置主键属性和非主键属性。无法通过字段名直接赋值的属性；2、使用association标签，设置property属性；设置select属性，找到为property属性赋值的SQL语句，设置select属性值：SQL语句对应的Mapper接口全类名.SQL语句对应的Mapper接口的方法名，例如```<association property="dept" select="java.yuu.mapper.UserMapper.getUnameByUid" />```。设置column属性，属性值为用哪一个字段作为分步查询条件，**必须保证此条件是从数据库查询过的字段名**
    >             
    >                 ```
    >                 <resultMap id="empDept" type="com.yuu.bean.Emp">
    >                         <id column="eid" property="eid" />
    >                         <result column="ename" property="ename" />
    >                         <result column="age" property="age" />
    >                         <result column="sex" property="sex" />
    >                         <!-- 利用association标签的select属性，找到一个SQL为property属性赋值。 -->
    >                         <!-- select属性决定用哪个SQL语句查询数据 -->
    >                         <!-- column属性决定用哪个字段作为分步查询的条件 -->
    >                         <association property="dept" select="com.yuu.mapper.DeptMapper.getDnameByDid" column="did" />
    >                     </resultMap>
    >                     <!-- 先查询emp表的全部信息，然后通过resultMap中的映射查询一个表的信息 -->
    >                     <select id="getAllEmp" resultMap="" >
    >                         select eid, ename, age, sex, did from emp
    >                     </select>
    >                 ```
    >         
    >     4. 使用
    >     
    >         1. 在映射文件的全局标签mapper标签体中，写入resultMap标签
    >     
    >         2. 指定resultMap标签的type属性和id属性，type属性为要自定义映射关系的对象的全类名，id属性为给resultMap属性的值。
    >     
    >         3. 在resultMap标签体中，自定义映射设置
    >            
    >         4. 设置select标签中的resultMap属性的属性值
    >     
    > 3. 使用resultMap标签的注意事项：
    >
    >    resultMap标签中有```<constructor>```标签，该标签用于配置类中构造方法的映射，```<idArg>```是主键，且允许多个主键，```<arg>```则是pojo的属性，column对应的是表中的字段，javaType对应的是pojo属性的类型。
    >
    >    如果没有配置<constructor>标签，默认创建实体类对象时会通过无参构造创建。
    >
    >    因为如果在类中如果没写构造方法，默认有无参构造，但是一旦写了有参构造，默认不提供无参构造了。所以如果实体类中只有有参构造，且没有配置```<constructor>```标签，MyBatis就无法创建实体类对象了。**因此，实体类中一定要写无参构造**。
    >
## 15. 分步查询的延迟加载
15. 分步查询的延迟加载
    > 1. 介绍
    >
    >    延迟加载也叫懒加载
    >
    >    分步查询中，我们实际是使用了多条SQL语句进行查询的。如果我们可以做到什么时候用什么时候加载，这就是懒加载
    >
    >    懒加载只针对分步查询有效
    >
    > 2. 设置延迟加载
    >
    >    在MyBatis的配置文件内，settings标签体中，设置setting标签：1、name="lazyLoadingEnabled"，控制是否开启懒加载；2、name="aggressiveLazyLoading"，控制是否查询所有字段。要开启懒加载需要同时设置这两个属性
    >    
    >    设置setting标签，name="lazyLoadingEnabled"，value="true"；同时设置setting标签，name="aggressiveLazyLoading"，value="false"，开启懒加载
    >    
    >     ```
    >    <settings>
    >        <setting name="lazyLoadingEnabled" value="true"/>
    >        <setting name="aggressiveLazyLoading" value="false"/>
    >    </settings>
    >     ```
    >    
## 16. 一对多自定义映射
16. 一对多自定义映射
    > 1. 前置
    >
    >     1. 修改一的一方实体类，写一个存放多的一方实体类的集合。
    >     2. 利用上述多对一的接口，在接口中写一对多的查询方法
    >     3. 利用上述的多对一映射文件，书写一对多的SQL语句
    >     
    > 2. resultMap
    >
    >     1. 介绍
    >     
    >        一对多查询时，也不能使用resultType属性，也需要使用resultMap自定义映射
    >        
    >     2. resultMap的书写 
    >     
    >         1. id标签和result标签，用来书写主键和非主键的可以用字段名直接复制的属性
    >         2. collection标签处理存放多个实体类的属性。collection标签的property属性，属性值为存放多个实体类的属性；ofType属性，存放的实体类的全类名。collection标签也需要写id标签和result标签。
    >         
    >             1. id标签和result标签，用来书写主键和非主键的可以用字段名直接复制的属
    >     3. 具体案例
    >     
    >         ```
    >         <!-- Dept getTrueDeptByDid(String did); -->
    >             <resultMap id="deptMap" type="com.yuu.bean.Dept">
    >                 <id column="did" property="did" />
    >                 <result column="dname" property="dname" />
    >                 <collection property="emps" ofType="com.yuu.bean.Emp">
    >                     <id column="eid" property="eid" />
    >                     <result column="ename" property="ename" />
    >                     <result column="age" property="age" />
    >                     <result column="sex" property="sex" />
    >                 </collection>
    >             </resultMap>
    >             <select id="getTrueDeptByDid" resultMap="deptMap" >
    >                 select dept.did, dept.dname, emp.eid, emp.ename, emp.age, emp.sex from dept left join emp on emp.did = dept.did where dept.did = #{did}
    >             </select>
    >         ```
    >     
    > 3. 一对多的分步查询
    >
    >     1. 在多对一接口中，写只查询一个表信息的方法。在EmpDeptMapper接口中写
    >     
    >         ```
    >         // 获取指定过的部门信息
    >         Dept getOnlyDeptByDid(String did);
    >         ```
    >         
    >     2. 在多对一接口中，写根据上一个SQL查询的字段作为条件查询的方法。在EmpDeptMapper接口中写：
    >     
    >         ```
    >         // 根据did获取对应的全部员工信息
    >         List<Emp> getEmpListByDid(String did);
    >         ```
    >         
    >     3. 在EmpDeptMapper.xml映射文件中写SQL
    >     
    >         ```
    >         <!-- List<Emp> getEmpListByDid(String did); -->
    >             <select id="getEmpListByDid" resultType="com.yuu.bean.Emp" >
    >                 select eid, ename, age, sex from emp where did = #{did}
    >             </select>
    >         ```
    >         
    >     4. 在EmpDeptMapper.xml映射文件中写分步查询的SQL
    >     
    >         ```
    >         <!-- Dept getOnlyDeptByDid(String did); -->
    >             <resultMap id="deptByDid" type="com.yuu.bean.Dept" >
    >                 <id property="did" column="did" />
    >                 <result property="dname" column="dname" />
    >                 <collection property="emps" select="com.yuu.mapper.EmpMapper.getEmpListByDid" column="did" />
    >             </resultMap>
    >             <select id="getOnlyDeptByDid" resultMap="deptByDid" >
    >                 select did, dname from dept where did = #{did}
    >             </select>
    >         ```
    >     
    > 4. 分步查询中，如果需要传入多个条件作为下一个SQL的条件。
    > 
    >    association标签和collection标签中的column属性，底层也是由Map集合形成的。因此如果要传入多个条件，只需要让column的属性值为Map格式即可：```column="{did=did, dname=dname}"```
    >         
## 17. 分步查询延迟加载控制fetchType
17. 分步查询延迟加载控制fetchaType
    > 1. 如果在MyBatis配置中配置了延迟加载，则该对全部的分步查询都有效
    > 
    > 2. 如果我们想单独指定某个分步查询是延迟加载，则我们只需要在association标签和collection标签上写入fetchType="lazy"即可。如果想单独指定某个分步查询非延迟加载，设置fetchType="eager"即可
    > 
## 18. MyBatis动态SQL
18. MyBatis动态SQL
    > 1. 简介
    >
    >    动态SQL是为了简化拼装SQL的操作
    >    
    >    MyBatis采用功能强大的基于OGNL的表达式简化操作
    >    
    > 2. OGNL
    >
    >     1. 简介
    >     
    >        OGNL（Object Graph Navigation Language），对象图导航语言。它是强大的表达式语言，通过它来操作对象属性，类似于EL，SqEL
    >        
    >     2. OGNL中，表示且的语句叫and，表示或的语句叫or，其他的!=，<=等都一样
    >     
    >     3. **特别注意：OGNL中，==只能判断数值或空字符串''，因此字符串形式的数值都不能加''，必须写成普通数值，无法做普通字符串比较。!=可以判断数值，也可以判断空字符串''**
    >     
    > 3. 多条件查询
    >    
    >    如果页面没有设置某个条件，则SQL语句中一定不能有该条件。因此写SQL需要对条件判断
    >    
    >    对于页面中非单选和复选框，例如input:text等，服务器端应该判断两次，是否为null和是否value=""
    >    
    >    对于复选框和单选框则只需判断是否value=""
    > 
### 1. 动态SQL之if
1. 动态SQL之if
    > 1. 动态SQL之if
    >    
    >     1. 语法格式
    >     
    >         ```
    >         <if test="OGNL判断逻辑">
    >            符合逻辑的代码
    >         </if>
    >         ```
    >         
    >     2. 例子
    >     
    >         ```
    >         <select id="getEmpListByCondition" resultType="com.yuu.bean.Emp">
    >                 select eid, ename, age, sex, did from emp
    >                 where 1 = 1
    >                 <if test="eid != null">
    >                     and eid = #{eid}
    >                 </if>
    >                 <!-- 注意，因为OGNL是写在双引号中，因此字符串要用单引号 -->
    >                 <if test="ename != null and ename != ''">
    >                     and ename = #{ename}
    >                 </if>
    >                 <if test="age != null" >
    >                     and age = #{age}
    >                 </if>
    >                 <!-- OGNL中==只能判断数值，因此即使是字符串形式的数值都不能加''，必须写成普通数值 -->
    >                 <if test="sex == 1 or sex == 0">
    >                     and sex = #{sex}
    >                 </if>
    >             </select>
    >         ```
    >     
### 2. 动态SQL之where
2. 动态SQL之where
    > 2. 动态SQL之where
    >
    >     1. 介绍
    >     
    >        where标签可以添加where关键字并且去掉语句前面多余的and。
    >        
    >        使用了where标签，就不用像之前一样写where 1 = 1 了。
    >        
    >        直接将where换成where标签
    >        
    >     2. 用法
    >     
    >         ```
    >         <where>
    >             所有的where查询条件
    >         </where>
    >         ```
    >         
    >     3. 实例
    >     
    >         ```
    >         <select id="getEmpListByCondition" resultType="com.yuu.bean.Emp">
    >                 select eid, ename, age, sex, did from emp
    >                 <where>
    >                 	<!-- 不需要写where 1 = 1 了，所有的where条件都直接用and 条件即可 -->
    >                     <if test="eid != null">
    >                          and eid = #{eid}
    >                      </if>
    >                      <!-- 注意，因为OGNL是写在双引号中，因此字符串要用单引号 -->
    >                     <if test="ename != null and ename != ''">
    >                          and ename = #{ename}
    >                      </if>
    >                      <if test="age != null" >
    >                         and age = #{age}
    >                      </if>
    >                     <!-- OGNL中==只能判断数值，因此即使是字符串形式的数值都不能加''，必须写成普通数值 -->
    >                     <if test="sex == 1 or sex == 0">
    >                         and sex = #{sex}
    >                     </if>
    >                 </where>
    >             </select>
    >         ```
    >     
### 3. 动态SQL之trim
3. 动态SQL之trim
    > 3. 动态SQL之trim
    >
    >     1. 介绍
    >     
    >        trim标签，截取与拼接
    >        
    >        它也可以实现where标签的功能，且更为强大
    >        
    >     2. 用法
    >     
    >         * trim标签可以写的属性：
    >         
    >             1. prefix属性：前缀，在操作的SQL语句前加入
    >             
    >             2. suffix属性：后缀，在操作的SQL语句后加入
    >             
    >             3. prefixOverrides属性：前缀重写，把操作的SQL语句前的某些内容去掉。如果要处理多个内容，只需要prefixOverrides="内容1|内容2|..."
    >             
    >             4. suffixOverrides属性：后缀重写，把操作的SQL语句后的某些内容去掉。如果要处理多个内容，只需要suffixOverrides="内容1|内容2|..."
    >             
    >         * 使用：
    >         
    >             ```
    >             <trim prefix="xxx" suffix="xxx" prefixOverrides="xxx" suffixOverrides="xxx">
    >             	条件查询语句
    >             </trim>
    >             ```
    >         
    >     3. 实例
    >     
    >         ```
    >         <select id="getEmpListByCondition" resultType="com.yuu.bean.Emp">
    >                 select eid, ename, age, sex, did from emp
    >                 <!--
    >                     and 放在后面，可能导致SQL语句and多余。该情况where标签无法解决，因此使用trim标签。
    >                     让trim标签前面拼接where，去掉SQL语句后多余的and或者or即可。
    >                 -->
    >                 <trim prefix="where" suffixOverrides="and|or">
    >                     <if test="eid != null">
    >                          eid = #{eid} and
    >                      </if>
    >                      <!-- 注意，因为OGNL是写在双引号中，因此字符串要用单引号 -->
    >                     <if test="ename != null and ename != ''">
    >                          ename = #{ename} and
    >                      </if>
    >                      <if test="age != null" >
    >                          age = #{age} or
    >                      </if>
    >                     <!-- OGNL中==只能判断数值，因此即使是字符串形式的数值都不能加''，必须写成普通数值 -->
    >                     <if test="sex == 1 or sex == 0">
    >                         sex = #{sex}
    >                     </if>
    >                 </trim>
    >             </select>
    >         ```
    >     
### 4. 动态SQL之set
4. 动态SQL之set
    > 4. 动态SQL之set
    >
    >     1. 介绍
    >     
    >        set标签主要用于解决修改操作的SQL语句中多出逗号的问题
    >        
    >        set标签可以取代SQL的修改语句中的set关键字，并且可以解决多出的逗号问题
    >        
    >        set标签可以被trim标签代替，因此一般不使用
    >        
    >     2. 用法
    >     
    >         ```
    >         <set>
    >         修改语句
    >         </set>
    >         ```
    >         
    >     3. 实例
    >     
    >         ```
    >         <update id="updateEmpByCondition">
    >                 update emp
    >                 <set>
    >                     <if test="ename != null and ename != ''">
    >                         ename = #{ename},
    >                     </if>
    >                     <if test="age != null">
    >                         age = #{age},
    >                     </if>
    >                     <!-- 如果最后的这个不符合条件，则前面的会多出逗号。set标签可以去掉多出的逗号 -->
    >                     <if test="did != null">
    >                         did = #{did}
    >                     </if>
    >                 </set>
    >                 where eid = #{eid}
    >             </update>
    >         ```
    >     
### 5. 动态SQL之choose
5. 动态SQL之choose
    > 5. 动态SQL之choose
    >
    >     1. 介绍
    >     
    >        choose标签主要用于分支判断，类似于java中的switch case
    >        
    >        choose标签体中，有when标签和otherwise标签。when标签类似于case，otherwise标签类似于default。其中otherwise标签不是必须的，就像default不是必须的一样。
    >        
    >     2. 用法
    >     
    >         ```
    >         <choose>
    >         	<when test=""></when>
    >         	...
    >         	<otherwise></otherwise>
    >         </choose>
    >         ```
    >         
    >     3. 实例
    >     
    >         ```
    >         <!-- 根据eid，ename，age，sex中的一个来查询员工信息 -->
    >         <select id="getEmpListByChoose" resultType="com.yuu.bean.Emp">
    >                 select eid, ename, age, sex, did from emp
    >                 <where>
    >                     <choose>
    >                         <when test="eid != null">
    >                             eid = #{eid}
    >                         </when>
    >                         <when test="ename != null and ename != ''">
    >                             ename = #{ename}
    >                         </when>
    >                         <when test="age != null">
    >                             age = #{age}
    >                         </when>
    >                         <when test="sex == 1 or sex == 0">
    >                             sex = #{sex}
    >                         </when>
    >                         <otherwise>
    >                             eid &lt;= 10
    >                         </otherwise>
    >                     </choose>
    >                 </where>
    >             </select>
    >         ```
    >         
    >         ```
    >         <!-- 添加员工信息，并保证可以把sex的1|0存储时替换成男|女 -->
    >         <!-- void addEmp(Emp emp); -->
    >             <insert id="addEmp">
    >                 insert into emp values(
    >                                        null,
    >                                        #{ename},
    >                                        #{age},
    >                                        <choose>
    >                                            <when test="sex == 1">'男',</when>
    >                                            <when test="sex == 0">'女',</when>
    >                                        </choose>
    >                                        1
    >                                       )
    >             </insert>
    >         ```
    >         
    >     4. xml中，```<```、```>```等需要转义。```<```对应```&lt;```，```>```对应```&gt;```
### 6. 动态SQL之foreach
6. 动态SQL之foreach
    > 6. 动态SQL之foreach
    >
    >     1. 介绍
    >     
    >        foreach标签用于循环迭代
    >        
    >        例如在进行批量操作时，经常用到
    >        
    >     2. 用法
    >     
    >         * foreach标签的可用属性
    >         
    >             1. collection属性：要迭代的集合或数组。**注意，如果是List集合和数组，MyBatis对List和Array作为方法参数时，以list/array为键放入Map集合中传递，因此，这里要用list/array获取。或者可以在List和Array参数上添加@Param("别名")注解起个别名，然后获取别名即可**
    >             
    >             2. item属性：从当前集合中迭代出的元素别名
    >             
    >             3. open属性：设置循环体的开始内容
    >             
    >             4. close属性：设置循环体的结束内容
    >             
    >             5. separator属性：设置每一次循环之间的分隔符
    >             
    >             6. index属性：迭代的是List集合，代表下标；迭代的是Map集合，代表元素的key
    >         
    >     3. 实例：批量删除的两种方式
    >     
    >         ```
    >         <!-- 批量删除，根据传入的eid字符串进行 -->
    >          <!-- void deleteEmpByEmpList(String emps); 最终传入的字符串形式为"1,2,3..."-->
    >             <delete id="deleteEmpByEmpList">
    >                 delete from emp where eid in ('${value}')
    >             </delete>
    >         ```
    >         
    >         ```
    >         <!-- 批量删除，根据传入的List集合进行 -->
    >         <!-- void deleteEmpByEmpList(List<Integer> eids);-->
    >         <!-- void deleteEmpByEmpList(List<Integer> eids);-->
    >             <delete id="deleteEmpByEmpList">
    >                 delete from emp where eid in 
    >                 <foreach collection="list" item="eid" separator="," open="(" close=")">
    >                     #{eid}
    >                 </foreach>
    >             </delete>	
    >         ```
    >         
    >     4. 批量操作
    >     
    >         1. C：insert，批量添加。
    >         
    >             * 批量添加SQL：```insert into emp values(), (), (), ...```
    >         
    >             * 批量添加例子：
    >         
    >                 ```
    >                 <!--
    >                         // 批量添加，根据传入的Emp对象的List集合进行
    >                         void  addEmpByEmpList(@Param("emps")List<Emp> emps);
    >                      -->
    >                     <insert id="addEmpByEmpList" >
    >                         insert into emp values
    >                         <foreach collection="emps" item="emp" separator=",">
    >                             (
    >                              null,
    >                              #{emp.ename},
    >                              #{emp.age},
    >                              <choose>
    >                                  <when test="emp.sex == 1">'男',</when>
    >                                  <when test="emp.sex == 0">'女',</when>
    >                              </choose>
    >                              1
    >                              )
    >                         </foreach>
    >                     </insert>
    >                 ```
    >         
    >         2. R：select，批量查询
    >         
    >         3. U：update，批量修改。批量修改有两种情况，把每条数据修改成相同内容、每条数据各自修改
    >         
    >             * 每条数据修改成相同内容例子：一条update的SQL语句，只需把条件放入in()中
    >         
    >                 ```
    >                 <!--
    >                         // 批量修改，都改成相同内容
    >                         void updateByEid(@Param("eids")List<Integer> eids);
    >                     -->
    >                     <update id="updateByEid">
    >                         update emp set ename = #{ename}, age = #{age}, sex = #{sex} where eid in
    >                         <foreach collection="eids" item="eid" separator="," open="(" close=")">
    >                             #{eid}
    >                         </foreach>
    >                     </update>
    >                 ```
    >         
    >             * 每条数据各自修改不同内容例子：需要有多条update的SQL语句
    >         
    >                 ```
    >                 <!--
    >                         // 批量修改，每条都是不同内容
    >                         void updateByEmpList(@Param("emps")List<Emp> emps);
    >                     -->
    >                     <update id="updateByEid">
    >                         <foreach collection="emps" item="emp">
    >                             update emp set ename = #{emp.ename}, age = #{emp.age}, sex = #{emp.sex} where eid = #{emp.eid};
    >                         </foreach>
    >                     </update>
    >                 ```
    >                 
    >                 * **特别注意：因为#{}底层使用的是PreparedStatement预编译对象，但是预编译对象每次只可以预编译一个SQL语句。因此如果直接使用上述foreach会报错。我们可以设置JDBC配置，即jdbc.properties配置文件文件中jdbc.url=jdbc:mysql:///test?allowMultiQueries=true来开启预编译多个SQL语句，这样使用上述foreach预编译多个SQL就不会报错了**。jdbc.properties配置文件中如下：
    >                 
    >                     ```
    >                     jdbc.driver=com.mysql.jdbc.Driver
    >                     jdbc.url=jdbc:mysql:///test?allowMultiQueries=true
    >                     jdbc.username=root
    >                     jdbc.password=root
    >                     ```
    >         
    >         4. D：delete，批量删除
    >         
    >     5. 当传入参数为对象的List集合或对象的Array数组时，用foreach遍历后，想要通过#{}或${}获取遍历后对象的属性，则需要对item设置的对象别名使用级联操作，大括号中使用级联操作，即#{别名.属性}或${别名.属性}
    >     
### 7. 动态SQL之SQL
7. 动态SQL之SQL
    > 1. 介绍
    >
    >    用来设置一段SQL片段，即公共SQL，可以被当前映射文件中所有的SQL访问。
    >    
    >    其他SQL中想用公共的SQL，只需要使用include标签引入即可
    >    
    > 2. 用法
    >
    >     ```
    >     <sql id="自定义id">
    >     	SQL片段
    >     </sql>
    >     ```
    >
    >     ```
    >     <include refid="sql片段的id"></include>
    >     ```
    >
    > 3. 实例
    >
    >     ```
    >     <!-- 定义一个查询的SQL片段，给其他查询语句使用 -->
    >     <sql id="empColumns">
    >     	select eid, ename, age, sex from emp
    >     </sql>
    >     ```
    >     
    >     ```
    >     <select id="getEmpListByCondition" resultType="com.yuu.bean.Emp">
    >             <!-- 其他查询语句中使用SQL片段-->
    >             <include refid="empColumns"></include>
    >             <trim prefix="where" suffixOverrides="and|or">
    >                 <if test="eid != null">
    >                      eid &lt;= #{eid} and
    >                  </if>
    >                  <!-- 注意，因为OGNL是写在双引号中，因此字符串要用单引号 -->
    >                 <if test="ename != null and ename != ''">
    >                      ename = #{ename} and
    >                  </if>
    >                  <if test="age != null" >
    >                      age = #{age} or
    >                  </if>
    >                 <!-- OGNL中==只能判断数值，因此即使是字符串形式的数值都不能加''，必须写成普通数值 -->
    >                 <if test="sex == 1 or sex == 0">
    >                     sex = #{sex}
    >                 </if>
    >             </trim>
    >         </select>
    >     ```
    >     
## 19. MyBatis缓存
19. MyBatis缓存
    > 1. 介绍
    > 
    >    MyBatis提供了缓存机制。缓存可以极大地提升查询效率
    >    
    >    如果开启缓存，则查询时先从缓存中寻找数据，没有则将数据从数据库查数据，并将数据放入缓存，然后从缓存中取出数据。
    >    
    > 2. MyBatis缓存分为一级缓存和二级缓存
    > 
    >     1. 一级缓存：默认开启，SqlSession级别的缓存。
    >     
    >         1. SqlSession级别：使用SqlSession执行查询SQL，则查询的内容会存储在缓存中，下次同一个SqlSession执行相同的SQL，则直接从该SqlSession对应的缓存中取数据。
    >         
    >         2. 一级缓存失效的几种情况：
    >         
    >             1. 不同的SqlSession对应不同的一级缓存
    >             
    >             2. 同一个SqlSession但是查询条件不同
    >             
    >             3. 同一个SqlSession两次查询期间，进行了任何一次增删改操作，无论增删改操作成功与否，都会自动清空缓存
    >             
    >             4. 同一个SqlSession两次查询期间，手动清空了缓存。使用SqlSession中的clearCache()方法手动清空缓存。
    >         
    >     2. 二级缓存：默认不开启，映射文件级别的缓存
    >     
    >         1. 映射文件级别：某个映射文件使用了二级缓存，则无论用哪个SqlSession，只要使用了该映射文件，就会缓存。
    >         
    >         2. 二级缓存的使用
    >         
    >            默认不开启，需要手动配置。
    >            
    >            手动配置二级缓存：MyBatis的配置文件中，在```<settings>```标签中添加```<setting name="cacheEnabled" value="true" />```，即可开启二级缓存
    >            
    >            **MyBatis提供二级缓存的接口和实现，缓存实现要求POJO实现Serializable接口**
    >            
    >            **二级缓存只有在SqlSession提交或者关闭时才会生效**
    >            
    >        3. 二级缓存使用的步骤
    >        
    >            1. MyBatis全局配置文件中开启二级缓存，在```<settings>```标签中添加```<setting name="cacheEnabled" value="true" />```
    >            
    >            2. 需要使用到二级缓存的映射文件处，使用```<cache>```标签配置缓存。直接在需要开启二级缓存的映射文件中，写入```<cache />```，该映射文件就可以使用二级缓存
    >            3. 注意，POJO必须实现Serializable接口
    >            
    >        4. ```<cache />```标签中可用的属性：这些属性都有默认值，因此可以不用设置属性
    >        
    >            1. eviction属性：定义缓存回收策略。默认为LRU。eviction属性值有以下几种：
    >            
    >                * LRU：最近最少使用的，移除最长时间不被使用的对象。eviction属性默认值就是LRU
    >                
    >                * FIFO：先进先出，按对象进入缓存的顺序来移除它们
    >                
    >                * SOFT：软引用，移除基于垃圾回收器状态和软引用规则的对象
    >                
    >                * WAKE：弱引用，更积极的移除基于垃圾回收期状态和弱引用规则的对象
    >                * LRU和FIFO经常使用，SOFT和WAKE不经常使用
    >            
    >            2. flushInterval属性：定义缓存的刷新间隔，单位是毫秒。默认情况不设置，也就是没有刷新间隔，如果缓存放满了，则根据eviction定义的回收策略清理部分缓存。
    >            
    >            3. size属性：定义了引用数目，正整数。代表了最多可以存放多少个引用对象。该值绝对不能写过大，否则会导致内存溢出。
    >            
    >            4. readOnly属性：只读，属性值为true/false。默认为false。
    >            
    >                * true：只读缓存。会给所有的调用者返回缓存对象的相同实例，因此这些对象不允许被修改。提供了非常大的性能优势。
    >                
    >                    * true，会返回给所有调用者相同的实例，可以修改但是不建议修改，如果修改会导致脏读等情况，因此直接要求不允许修改。
    >                
    >                * false：读写缓存。会返回缓存对象的拷贝（通过对象的序列化来实现），这样慢一些，但是安全。默认值为false。
    >                
    >            5. type属性：设置第三方缓存。默认不使用第三方缓存
    >            
    >        5. 使用二级缓存
    >        
    >           当给使用了二级缓存后，控制台会输出缓存命中率的日志信息```DEBUG 01-18 14:27:29,352 Cache Hit Ratio [com.yuu.mapper.EmpMapper]: 0.0  (LoggingCache.java:62) ```。
    >           
    >           缓存命中率指的是：缓存命中率 = 执行的所有SQL中去缓存取数据的SQL / 执行的全部SQL
    >           
    >           因为二级缓存只有在SqlSession关闭或者提交时才生效，因此如果要测试命中率，需要手动提交或关闭SqlSession。
    >           
### 1. 缓存的相关属性设置
1. 缓存的相关属性设置
    > 1. 全局settings中的setting:cacheEnabled
    >
    >    用来定义是否开启二级缓存
    >    
    > 2. select标签中的useCache属性：主要用来在二级缓存开启的情况下，设置当前select标签不使用二级缓存
    >
    >    配置该select标签是否使用二级缓存。一级缓存一直使用。
    >    
    >    默认为true，意思是只要映射文件可以使用二级缓存，则该select标签就会使用二级缓存
    >    
    >    如果定义useCache属性为false，则映射文件开启二级缓存，该select标签也不会使用
    >    
    > 3. 增删改查标签的flushCache属性
    >
    >    增删改（insert标签、delete标签、update标签）默认flushCache属性为true。**执行增删改SQL语句，默认清空一级缓存和二级缓存**
    >    
    >    查（select标签）默认flushCache属性为false。执行查SQL，不清空缓存
    >    
    > 4. **SqlSession对象的clearCache()方法只会清空一级缓存**
    > 
### 2. 第三方缓存
2. 第三方缓存
    > 1. 介绍
    >
    >    为了提高扩展性，MyBatis定义了缓存接口Cache。我们可以通过实现Cache接口来自定义二级缓存。
    >    
    > 2. EhCache
    >
    >     1. 介绍
    >     
    >       纯Java的进程内缓存框架，具有快速、精干等特点。
    >     
    >       是Hibernate中默认的CacheProvider
    >     
    >     2. 整合EhCache
    >     
    >         1. 导入jar包：EhCache包，整合包，日志包
    >         
    >             * ehcache-core-xx.xx.x.jar
    >             
    >             * mybatis-ehcahce-xx.xx.x.jar
    >             
    >             * slf4j-api-x.x.x.jar
    >             
    >             * slf4j-log4j12-x.x.x.jar
    >         
    >         2. 定义EhCache的配置文件ehcache.xml
    >         
    >             ```
    >             <?xml version="1.0" encoding="UTF-8"?>
    >             <ehcache xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    >                      xsi:noNamespaceSchemaLocation="http://ehcache.org/ehcache.xsd">
    >                 <!-- 磁盘保存路径 -->
    >                 <diskStore path="D:\IDEAhome\Mybatis\cache" />
    >             
    >                 <defaultCache
    >                         maxElementsInMemory="1000"
    >                         maxElementsOnDisk="10000000"
    >                         eternal="false"
    >                         overflowToDisk="true"
    >                         timeToIdleSeconds="120"
    >                         timeToLiveSeconds="120"
    >                         diskExpiryThreadIntervalSeconds="120"
    >                         memoryStoreEvictionPolicy="LRU">
    >                 </defaultCache>
    >             </ehcache>
    >              
    >             <!-- 
    >             属性说明：
    >             l diskStore：指定数据在磁盘中的存储位置。
    >             l defaultCache：当借助CacheManager.add("demoCache")创建Cache时，EhCache便会采用<defalutCache/>指定的的管理策略
    >              
    >             以下属性是必须的：
    >             l maxElementsInMemory - 在内存中缓存的element的最大数目 
    >             l maxElementsOnDisk - 在磁盘上缓存的element的最大数目，若是0表示无穷大
    >             l eternal - 设定缓存的elements是否永远不过期。如果为true，则缓存的数据始终有效，如果为false那么还要根据timeToIdleSeconds，timeToLiveSeconds判断
    >             l overflowToDisk - 设定当内存缓存溢出的时候是否将过期的element缓存到磁盘上
    >              
    >             以下属性是可选的：
    >             l timeToIdleSeconds - 当缓存在EhCache中的数据前后两次访问的时间超过timeToIdleSeconds的属性取值时，这些数据便会删除，默认值是0,也就是可闲置时间无穷大
    >             l timeToLiveSeconds - 缓存element的有效生命期，默认是0.,也就是element存活时间无穷大
    >              diskSpoolBufferSizeMB 这个参数设置DiskStore(磁盘缓存)的缓存区大小.默认是30MB.每个Cache都应该有自己的一个缓冲区.
    >             l diskPersistent - 在VM重启的时候是否启用磁盘保存EhCache中的数据，默认是false。
    >             l diskExpiryThreadIntervalSeconds - 磁盘缓存的清理线程运行间隔，默认是120秒。每个120s，相应的线程会进行一次EhCache中数据的清理工作
    >             l memoryStoreEvictionPolicy - 当内存缓存达到最大，有新的element加入的时候， 移除缓存中element的策略。默认是LRU（最近最少使用），可选的有LRU（最不常使用）和FIFO（先进先出）
    >              -->
    >             ```
    >         
    >         3. 配置```<cache>```标签中的type属性为EhCache提供的Cache接口实现类
    >         
    >             ```
    >             <cache type="org.mybatis.caches.ehcache.EhcacheCache"
    >             ```
    >             
## 20. 逆向工程
20. 逆向工程
    > 1. 介绍
    >    
    >    为一个java项目，通过表生成实体类、映射文件、Mapper接口
    >    
    > 2. 使用
    >
    >     1. 导入jar包
    >     
    >         * MyBatis的三个jar包：
    >         
    >             * log4j.jar
    >             
    >             * mybatis-xx.xx.x.jar
    >             
    >             * mybatis-connector-java-xx.xx.x.jar
    >             
    >         * 逆向工程jar包：
    >         
    >             * mybatis-generator-core-xx.xx.x.jar
    >     
    >     2. 配置MyBatis配置文件、log4j配置文件、jdbc配置文件
    >     
    >     3. 创建逆向工程的配置文件。假设自定义配置文件名称为mbg.xml，文件放在项目根目录中
    >     
    >         ```
    >         <?xml version="1.0" encoding="UTF-8"?>
    >         <!DOCTYPE generatorConfiguration
    >                 PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN"
    >                 "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd">
    >         
    >         <generatorConfiguration>
    >         
    >             <!--
    >              targetRuntime常用值:
    >                 MyBatis3Simple(只生成基本的CRUD和少量的动态SQL)
    >                 MyBatis3(生成完整的CRUD，包含CriteriaAPI方法Example后缀的方法)
    >              -->
    >             <context id="localhost_mysql" targetRuntime="MyBatis3">
    >         
    >                 <!-- 不生成注释 -->
    >                 <commentGenerator>
    >                     <property name="suppressAllComments" value="true" />
    >                 </commentGenerator>
    >         
    >                 <jdbcConnection driverClass="com.mysql.jdbc.Driver"
    >                                 connectionURL="jdbc:mysql:///test?characterEncoding=utf8&amp;serverTimezone=UTC&amp;useSSL=true"
    >                                 userId="root"
    >                                 password="root">
    >                     <!-- 如果连接的是mysql需要加上这个配置，应为mysql不支持catalog和schema，如果多个库中有相同名称的表，会重复生成代码 -->
    >                     <property name="nullCatalogMeansCurrent" value="true" />
    >                 </jdbcConnection>
    >         
    >                 <javaTypeResolver >
    >                     <property name="forceBigDecimals" value="false" />
    >                 </javaTypeResolver>
    >         
    >                 <!-- 生成实体类 -->
    >                 <javaModelGenerator targetPackage="com.yuu.bean" targetProject="./src">
    >                     <property name="enableSubPackages" value="true" />
    >                     <property name="trimStrings" value="true" />
    >                 </javaModelGenerator>
    >         
    >                 <!-- 生成XML -->
    >                 <sqlMapGenerator targetPackage="com.yuu.mapper" targetProject="./conf">
    >                     <property name="enableSubPackages" value="true" />
    >                 </sqlMapGenerator>
    >         
    >                 <!-- 生成Mapper接口 -->
    >                 <!-- 生成的Mapper类型：ANNOTATEDMAPPER（注解）、MIXEDMAPPER（混合）、XMLMAPPER（XML） -->
    >                 <javaClientGenerator type="XMLMAPPER" targetPackage="com.yuu.mapper"  targetProject="./src">
    >                     <property name="enableSubPackages" value="true" />
    >                 </javaClientGenerator>
    >         
    >                 <!-- 完全限定一张表：catalog名称.schema名称.表名(如果多个库中有同名的表必须配置)
    >                     其实Mysql根本不支持catalog和schema，建议不要配置这两个，使用jdbcConnection标签中的nullCatalogMeansCurrent配置项解决
    >                 -->
    >                 <!-- 一个table标签对应着数据库中一个表 -->
    >                 <table tableName="emp" domainObjectName="Emp"></table>
    >                 <table tableName="dept" domainObjectName="Dept"></table>
    >         
    >             </context>
    >         </generatorConfiguration>
    >         ```
    >     
    >     4. 运行逆向工程代码，逆向生成实体类、映射文件、Mapper接口
    >     
    >         ```
    >         @Test
    >             public void test1() throws Exception{
    >                 List<String> warnings = new ArrayList<String>();
    >                 boolean overwrite = true;
    >                 //指定逆向工程配置文件
    >                 File configFile = new File("D:\\IDEAhome\\Mybatis_mbg\\mbg.xml");
    >                 ConfigurationParser cp = new ConfigurationParser(warnings);
    >                 Configuration config = cp.parseConfiguration(configFile);
    >                 DefaultShellCallback callback = new DefaultShellCallback(overwrite);
    >                 MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings);
    >                 myBatisGenerator.generate(null);
    >             }
    >         ```
    >     
    > 3. targetRuntime设置MyBatis3(生成完整的CRUD，包含CriteriaAPI方法Example后缀的方法)
    >
    >     1. Mapper接口中部分方法的使用：以Emp表举例，Emp表生成EmpMapper接口，生成Emp实体类和EmpExample实体类
    >     
    >         1. selectByExample(EmpExample empExample) -- 根据条件查询，查询条件由EmpExample对象提供。传入selectByEmample()的参数为null，就是查询所有信息
    >         
    >             * 查询所有信息
    >             
    >                 ```
    >                 // 根据EmpExample设置的条件查询
    >             List<Emp> emps = mapper.selectByExample(null);
    >                 ```
    >             
    >             * EmpExample对象中的createCriteria()可以创建一个EmpExample.Criteria对象，该对象可以为EmpExample对象设置条件
    >             
    >                 ```
    >                 EmpExample empExample = new EmpExample();
    >                 // 通过EmpExample创建EmpExample.Criteria对象。
    >                 // EmpExample.Criteria对象的方法设置查询条件
    >                 EmpExample.Criteria criteria = empExample.createCriteria();
    >                 criteria.andAgeBetween(200, 2000).andEnameLike("%秦%").andSexEqualTo("1");
    >                 // 根据EmpExample设置的条件查询
    >                 List<Emp> emps = mapper.selectByExample(empExample);
    >                 ```
    >                 
    >             * EmpExample对象中的or(Criteria criteria2)方法，该方法表示ExpExample对象中的原有条件或or()方法传入的条件来查询，表示或的意思。
    >             
    >                 ```
    >                 EmpExample empExample = new EmpExample();
    >                 
    >                 // 通过EmpExample创建EmpExample.Criteria对象。
    >                 // 设置第一个条件
    >                 EmpExample.Criteria criteria1 = empExample.createCriteria();
    >                 criteria1.andAgeBetween(200, 2000).andEnameLike("%秦%");
    >                 
    >                 // 设置另一个条件
    >                 EmpExample.Criteria criteria2 = empExample.createCriteria();
    >                 criteria2.andDidEqualTo(2);
    >                 
    >                 // 将两个条件用或连接
    >                 empExample.or(criteria2);
    >                 
    >                 // 根据EmpExample设置的条件查询
    >                 List<Emp> emps = mapper.selectByExample(empExample);
    >                 ```
    >             
    >          2. selectByPrimaryKey(Integer primaryKey) -- 根据传入的主键的值查询数据
    >         
    >              * 实例
    >              
    >                  ```
    >                  Emp emp = mapper.selectByPrimaryKey(16);
    >                  ```
    >                  
## 21. MyBatis分页插件PageHelper
21. MyBatis分页插件PageHelper
    > 1. MyBatis插件
    >
    >    MyBatis插件就是Interceptor接口的实现类，Interceptor在Spring中叫拦截器，MyBatis中叫插件。使用插件需要导入相应的jar包。
    >    
    >    所有的插件都是实现了Interceptor接口。
    >    
    > 2. 分页插件PageHelper
    >
    >     1. 使用
    >     
    >         1. 需要的jar包
    >     
    >             * jsqlparse-xx.x.x.jar
    >         
    >             * pagehelper-xx.x.x.jar
    >             
    >         2. MyBatis配置文件中配置分页插件：
    >         
    >             ```
    >             <plugins>
    >                 <plugin interceptor="com.github.pagehelper.PageHelper"></plugin>
    >             </plugins>
    >             ```
    >             
    >             * **特别注意：在PageHelper5以上版本中MyBatis的插件指定不为PageHelper，应该使用PageInterceptor**
    >             
    >                 ```
    >                 <plugins>
    >                 <plugin interceptor="com.github.pagehelper.PageInterceptor"</plugin>
    >                 </plugins>
    >                 ```
    >             
    >          3. 使用分页插件
    >         
    >             在调用Mapper接口中，和查询方法有关的方法前，开启分页查询。
    >             
    >             调用PageHelper类中的静态方法startPage(int pageNum, int pageSize)，该方法确定查找第pageNum页，pageSize条数据。
    >             
    >             使用Mapper接口中的方法查询分页数据，该方法必须返回List集合以便于下一步操作。
    >             
    >             new一个PageInfo对象，选择两个参数的构造器，将分页信息存储起来
    >             
    >              ```
    >             SqlSession sqlSession1 = sqlSessionFactory.openSession(true);
    >             EmpMapper mapper = sqlSession1.getMapper(EmpMapper.class);
    >             // 开启分页查询，选定分页查询的页码和每页展示的信息数量
    >             PageHelper.startPage(2, 2);
    >             // 进行分页查询并将结果放入一个List集合
    >             List<Emp> allEmp = mapper.getAllEmp();
    >             // 创建一个PageInfo对象，将全部的分页信息存储进去
    >             PageInfo<Emp> pageInfo = new PageInfo<Emp>(allEmp, 5);
    >              ```
    >             
    >         4. PageInfo对象详解
    >         
    >             1. 介绍
    >             
    >                存储了分页的全部信息，全部存在于对象属性中，可以通过getter方法获取属性值。
    >                包含了很多判断的方法
    >             
    >             2. 创建
    >             
    >                 通过new来直接创建，泛型为查询的数据的实体类，有两个重要的重载的构造器。
    >             
    >                 第一个构造器是一个参数的，传入查询数据的List集合作为参数，例如```PageInfo<Emp> pageInfo = new PageInfo<>(empList)```
    >             
    >                 第二个构造器是两个参数的，第一个参数是查询出的List集合，第二个是一共包括当前页允许多少个页码被看见，例如```PageInfo<Emp> pageInfo = new PageInfo<>(empList, 5)```。
    >                 
    >             3. PageInfo对象的属性
    >             
    >                全部见名知意，不在这里列出
    >             
    >         5. 我们可以定义一个分页工具类PageUtil<T>，里面定义一个getPageInfo(PageInfo<T> pageInfo, HttpServletRequest request)方法，用来根据分页信息直接把分页的String写好，直接发给客户端用即可。
    >         
    >             ```
    >             public class PageUtil<T> {
    >                 /**
    >                  * 根据传入的分页信息对象PageInfo，直接返回分页的字符串，客户端直接使用即可
    >                  * @param pageInfo 分页信息对象
    >                  * @param <T> 请求数据的实体类
    >                  * @return 分页字符串，类似于 首页 上一页 1 2 3 4 5 下一页 末页
    >                  */
    >                 public static <T> String getPageInfoString(PageInfo<T> pageInfo) {
    >                     // 获取项目路径
    >                     String path = "ssm/";
    >                     // 创建字符串缓冲区拼接分页字符串
    >                     StringBuilder stringBuilder = new StringBuilder();
    >             
    >                     // 拼接首页
    >                     stringBuilder.append("<a href='"+ path +"emps/1' >首页</a>");
    >                     stringBuilder.append("&nbsp;&nbsp;&nbsp;");
    >             
    >                     // 拼接上一页
    >                     // 判断是否有上一页
    >                     if (pageInfo.isHasPreviousPage()) {
    >                         // 有
    >                         stringBuilder.append("<a href='"+ path +"emps/"+ pageInfo.getPrePage() +"'>上一页</a>");
    >                     } else {
    >                         // 没有
    >                         stringBuilder.append("上一页");
    >                     }
    >                     stringBuilder.append("&nbsp;&nbsp;&nbsp;");
    >             
    >                     // 拼接中间的页码
    >                     for (int i :
    >                             pageInfo.getNavigatepageNums()) {
    >                         // 判断是否为当前页码
    >                         if (i == pageInfo.getPageNum()) {
    >                             // 是当前页
    >                             stringBuilder.append(""+ i +"");
    >                         } else {
    >                             // 不是当前页
    >                             stringBuilder.append("<a href='"+ path +"emps/"+ i +"'>"+ i +"</a>");
    >                         }
    >                         stringBuilder.append("&nbsp;&nbsp;&nbsp;");
    >                     }
    >             
    >                     // 拼接下一页
    >                     // 判断是否有下一页
    >                     if (pageInfo.isHasNextPage()) {
    >                         // 有
    >                         stringBuilder.append("<a href='"+ path +"emps/"+ pageInfo.getNextPage() +"'>下一页</a>");
    >                     } else {
    >                         // 没有
    >                         stringBuilder.append("下一页");
    >                     }
    >                     stringBuilder.append("&nbsp;&nbsp;&nbsp;");
    >             
    >             
    >                     // 拼接末页
    >                     stringBuilder.append("<a href='"+ path +"emps/"+ pageInfo.getPages() +"'>末页</a>");
    >             
    >                     return stringBuilder.toString();
    >                 }
    >             }
    >             ```
    >             
# 4. SSM整合
4. SSM整合
    > 1. 整合注意事项
    >
    >     1. 不同的MyBatis版本整合时适配包都不同   
    >        
    >        | MyBatis-Spring  | MyBatis         | Spring          |
    >        | --------------- | --------------- | --------------- |
    >        | 1.0.0 and 1.0.1 | 3.0.1 to 3.0.5  | 3.0.0 or higher |
    >        | 1.0.2           | 3.0.6           | 3.0.0 or highe  |
    >        | 1.1.0 or higher | 3.1.0 or higher | 3.0.0 or highe  |
    >        | 1.3.0 or higher | 3.4.0 or higher | 3.0.0 or highe  |
    >        
    >     2. 整合思路和步骤
    >
    >         1. 导入jar包。
    >
    >             * 使用Maven解决依赖：
    >
    >         2. 搭建SpringMVC
    >
    >             * web.xml中，配置：DispatcherServlet，HiddenHttpMethodFilter，CharacterEncodingFilter
    >             
    >             * SpringMVC.xml中，配置：扫描控制层组件，视图解析器，Default Servlet，MVC驱动，MultipartResolver，拦截器
    >
    >         3. 整合SpringMVC和Spring
    >
    >             * web.xml中，配置ContextLoaderListener，context-param
    >             
    >             * spring.xml中，配置：扫描组件（排除控制层）
    >
    >         4. 搭建MyBatis
    >
    >             * 核心配置文件
    >             
    >             * Mapper接口和映射文件
    >             
    >         5. spring整合MyBatis。
    >
    >             * 在MyBatis核心配置文件中：
    >             
    >                删除配置的数据源
    >             
    >                删除事务管理
    >
    >                删除environments标签，因为数据源和事务都交给spring了
    >             
    >                MyBatis中的typeAliases标签，也可以在Spring中作为SqlSessionFactoryBean的属性被管理。可以删除typeAliases标签
    >             
    >                MyBatis中的mappers标签，也可以在Spring中作为SqlSessionFactoryBean的属性被管理。可以删除mappers标签
    >             
    >             * 在spring.xml中：
    >             
    >                properties资源信息引入
    >                
    >                datasource数据源配置
    >                
    >                事务管理器配置
    >                
    >                开启事务驱动
    >                
    >                配置SqlSessionFactoryBean：MyBatis-Spring整合包提供的，能让Spring管理的bean。该bean就是用于创建SqlSessionFactory对象，从而创建最重要的SqlSession对象来操作数据库。
    >                
    >                 ```
    >                <!-- 管理MyBatis操作数据库的会话对象SqlSession -->
    >                    <bean class="org.mybatis.spring.SqlSessionFactoryBean">
    >                        <!-- 设置MyBatis配置文件的路径 -->
    >                        <property name="configLocation" value="classpath:mybatis-config.xml" />
    >                        <!--
    >                            设置数据源。
    >                            因为数据源交给了spring管理，因此MyBatis配置文件中没有数据源
    >                            SqlSession是管理数据库连接的，因此需要数据源，所以我们这里需要设置使用spring管理的数据源
    >                        -->
    >                        <property name="dataSource" ref="dataSource"></property>
    >                        <!-- 管理typeAliases。typeAliases是给某个类设置别名，typeAliasesPackage就是给一个包下的所有类设置别名，默认别名就是类名-->
    >                        <property name="typeAliasesPackage" value="com.yuu.ssm.bean"></property>
    >                        <!-- 管理mappers。设置映射文件完整的路径 -->
    >                        <!--
    >                            因为是路径，因此要用classPath:，并且中间用/做路径分割。
    >                            因为是需要全部的映射问价你，因此文件名直接为*.xml就代表文件夹下的全部xml文件
    >                        -->
    >                        <property name="mapperLocations" value="classpath:com/yuu/ssm/mapper/*.xml"></property>
    >                    </bean>
    >                 ```
    >                
    >                配置MapperScannerConfigurer：MyBatis-Spring整合包提供的管理所有Mapper接口实现类的bean。只要配置了Mapper接口所在的包，就可以将Mapper接口的所有实现类交给Spring管理，Service层自动装配时可以装配任意的Mapper接口，因为所有Mapper接口的实现类都被Spring管理了，可以自动装配给Mapper接口。
    >                
    >                 ```
    >                <!-- 配置Mapper接口实现类的管理 -->
    >                    <bean class="org.mybatis.spring.mapper.MapperScannerConfigurer">
    >                        <!-- 指定Mapper接口所在的包 -->
    >                        <property name="basePackage" value="com.yuu.ssm.mapper"></property>
    >                    </bean>
    >                 ```
    >
    >     3. 有趣的小细节：HTML中的script标签必须写成双标签，单标签没效果
    >
    >     4. **SpringMVC获取复选框中的值方式：只有两种，String作为参数，String[]数组作为方法参数，参数名和复选框name属性相同或者使用@PathVariable()注解。String作为方法参数时，传入的复选框值形式为"value1,value2,value3,..."；String[]作为方法参数时，传入的复选框值全放在字符串中。**
    >
    >     5. 延伸思考，客户端传入的多个元素，如果name属性相同，则可以通过String作为参数或者String[]作为参数来获取。
    >     
# 5. SpringSecurity
5. SpringSecurity
    > 1. 介绍
    > 
    >    权限控制框架
    >    
    >    融合了Spring技术栈，提供JavaEE应用的整体安全解决方案
    >    
    >    SpringSecurity为JavaEE的企业应用软件提供了全面的安全服务
    >    
    >    SpringSecurity可以无缝整合Spring应用，
    >    
    >    SpringBoot底层默认使用SpringSecurity，因此我们需要学习使用SpringSecurity
    >    
    > 2. 重要概念
    > 
    >     1. 认证：authentication，身份验证
    >     
    >        身份认证，是建立主体（principal）的过程，主体就是指用户、设备或在应用中执行其他动作的系统。也就是证明“你是谁”。
    >        
    >     2. 授权：authorization，授权
    >     
    >        授权，是指确定主体是否允许执行系统中某个动作的过程，也就是“你能做什么”
    >     
    > 3. 支持的身份认证模式
    > 
    >    在身份验证级别，SpringSecurity支持广泛的认证模型。这些认证模型一般由第三方提供，要么由相关标准机构开发。
    >    
    >    此外，SpringSecurity提供了一套自己的身份验证功能。
    >    
    >     * SpringSecurity当前支持的与所有这些技术的身份验证做集成：
    >    
    >         1. HTTP BASIC 身份验证标头
    >         
    >         2. HTTP Digest 身份验证标头
    >         
    >         3. HTTP X.509 客户端证书交换
    >         
    >         4. LDAP 非常常见的跨平台身份验证方式，特别是在大型环境中
    >         
    >         5. 基于表单的身份验证 用于简单的用户界面需求
    >         
    >         6. openID 身份验证
    >         
    >         7. 基于预先建立的请求标头的身份验证
    >         
    >         8. Jasig中央认证服务 （也成为了CAS，一种流行的开源单点登录系统）
    >         
    >         9. 远程方法调用（RMI）和HttpInvoker（Spring远程协议）的透明身份验证上下文传播
    >         
    >         10. 自动“记住我”身份验证
    >         
    >         11. 匿名身份验证（允许每个未经过身份验证自动承担特定的安全身份）
    >         
    >         12. Runas身份验证
    >         
    >         13. Java身份验证和授权服务（JAAS）
    >         
    >         14. JavaEE容器身份验证 （如果需要，可以使用容器管理身份验证）
    >         
    >         15. Java开源单点登录（JOSSO）
    >         
    >         ...
    >    
    > 4. SpringSecurity模块划分
    > 
    >     * Core-spring-security-core.jar：核心模块。
    >     
    >        核心认证、授权功能、支持jdbc-user功能、支持独立的Spring应用
    >        
    >     * Remoting-spring-security-remoting.jar：远程交互模块
    >     
    >        一般不需要。可以使用SpringRemoting功能简化远程客户端交互
    >        
    >     * Web-spring-security-web.jar：Web安全模块
    >     
    >        web项目使用，基于URL的访问控制(access-control)
    >        
    >     * Config-spring-security-config.jar：java配置模块
    >     
    >        必须的依赖包。包含解析xml的方式和java注解方式来使用SpringSecurity功能
    >        
    >     * LDAP-spring-security-ldad.jar：ldap(轻量目录访问协议)支持模块
    >     
    >        可选的依赖包。提供ldpa支持
    >        
    >     * ACL-spring-security-acl.jar：ACL支持
    >     
    >        ACL支持，细颗粒度的资源访问控制。
    >        
    >     * CAS-spring-security-cas.jar：CAS整合支持
    >     
    >        CAS(Central Authentication Service)中央认证服务，ApereoCAS整合
    >        
    >     * OpenID-spring-security-openid.jar：OpenID认证方式支持
    >     
    >        OpenID Web身份认证支持。用于针对外部OpenID服务器对用户进行身份验证。QQ、微信、微博等第三方认证登录
    >        
    >     * Test-spring-security-test.jar：测试模块
    >     
    >     快速的测试SpringSecurity应用
    >     
    > 5. 框架使用方式：第三种最为重要，要重点掌握
    >     1. 
    >     2. 
    >     3. 重点掌握。细分角色和权限，将用户、角色、权限、资源都采取数据库存储，并且自定义过滤器，替代默认的FilterSecurityInterceptor过滤器，并分别实现AccessDecisionManager、InvocationSecurityMetadataSourceServic和UserDetailService，并在配置文件中进行相应配置
    >     4. 
    >     
## 1. 准备SpringSecurity环境
1. 准备SpringSecurity环境
    > 1. 引入需要的jar包：
    >
    >     ```
    >     <dependency>
    >                 <groupId>org.springframework.security</groupId>
    >                 <artifactId>spring-security-web</artifactId>
    >                 <version>4.2.10.RELEASE</version>
    >             </dependency>
    >             <dependency>
    >                 <groupId>org.springframework.security</groupId>
    >                 <artifactId>spring-security-config</artifactId>
    >                 <version>4.2.10.RELEASE</version>
    >             </dependency>
    >             <!-- 标签库 -->
    >             <dependency>
    >                 <groupId>org.springframework.security</groupId>
    >                 <artifactId>spring-security-taglibs</artifactId>
    >                 <version>4.2.10.RELEASE</version>
    >             </dependency>
    >     ```
    >     
    > 2. 在web.xml中，配置SpringSecurity的过滤器：filter-name必须为SpringSecurityFilterChain，filter-class为DelegatingFilterProxy，并且配置过滤url-pattern为```/*```
    >
    >     ```
    >     <filter>
    >         <filter-name>SpringSecurityFilterChain</filter-name>
    >         <filter-class>org.springframework.web.filter.DelegatingFilterProxy</filter-class>
    >       </filter>
    >       <filter-mapping>
    >         <filter-name>SpringSecurityFilterChain</filter-name>
    >         <url-pattern>/*</url-pattern>
    >       </filter-mapping>
    >     ```
    >
    > 3. 自己写一个配置类，继承WebSecurityConfigurerAdapter。在自定义的配置类中，加入@Configuration注解，表明该类为配置类；加入@EnableWebSecurity，表明启用权限框架
    >
    >     ```
    >     @Configuration // 声明当前类为一个配置类。配置类相当于XML文件
    >     @EnableWebSecurity // 声明式配置，启用SpringSecurity安全机制
    >     public class AppWebSecurityConfig extends WebSecurityConfigureAdaptor{
    >     
    >     }
    >     ```
    >     
    > 4. 此时，SpringSecurity就完全保护了整个项目。无论是**任何请求，包括url、转发**，访问任何东西，都无法直接访问，都会跳转到SpringSecurity自带的登录页面中。
    >
## 2. SpringSecurity默认登录页面详解
2. SpringSecurity默认登录页面详解
    > 1. SpringSecurity自带的默认登录页面
    > 2. 默认表单跳转到```/login```来做登录判决
    > 3. 默认表单中用户框的name属性为username；密码框的name属性为password
    > 4. 默认表单中有一个隐藏域，name为_csrf，value为SpringSecurity给的一个token
## 3. SpringSecurity实验
### 1. 实验一：授权首页和静态页面
1. 实验一：授权首页和静态页面
    > 1. 使用了SpringSecurity，则默认一切请求都不允许访问，都要跳转到SpringSecurity自带的登录页面中。
    >
    > 2. 进入继承了WebSecurityConfigurerAdapter的配置类
    >
    > 3. 在配置类中，重写configure(HttpSecurity http)方法。重写的方法中：取消默认配置；并且写上逻辑。
    >
    >     ```
    >     @Override
    >     protected void configure(HttpSecurity http) throws Exception {
    >     
    >     	// super.configure(http); // 默认的权限规则，任何请求都受到限制
    >     	
    >     	http.authorizeRequestRequest() // 授权请求
    >     		.antMatchers("/static/**", "/index.jsp").permitAll() // 设置匹配的资源放行。ant即ant风格。**在ant风格中，表示所有子路径
    >     		.anyRequest().authenticated(); //剩余任何资源都需要认证
    >     		
    >     }
    >     ```
    >
### 2. 实验二：默认及自定义登录页
2. 实验二：默认及自定义登录页
    > 1. 实验一中，虽然解决了静态资源和公共页面的访问问题，但是，如果访问了不存在的资源或者没有访问权限的资源，会报404或403.
    >
    > 2. 我们在重写的configure(HttpSecurity http)方法中，添加默认跳转到登录页，解决权限不够报403页面的问题
    >    
    > 3. 因为SpringSecurity默认我们登录时，必须提交CSRF与Session中存在的来比对，防止跨站请求。我们可以暂时禁用CSRF，让我们没有提交CSRF也可以进入Controller进行登录验证。
    >
    >     ```
    >     @Override
    >     protected void configure(HttpSecurity http) throws Exception {
    >     
    >     	// super.configure(http); // 默认的权限规则，任何请求都受到限制
    >     	
    >     	http.authorizeRequestRequest() // 授权请求
    >     			.antMatchers("/static/**", "/index.jsp").permitAll() // 设置匹配的资源放行。ant即ant风格。**在ant风格中，表示所有子路径
    >     			.anyRequest().authenticated(); //剩余任何资源都需要认证
    >     		
    >     	// http.formLogin(); // 默认跳转到SpringSecurity自带的登录页
    >     	// http.formLogin().loginPage("/index.jsp"); // 默认跳转到指定登录页
    >     	http.formLogin()
    >     			.loginPage("/index.jsp") //默认跳转到指定登录页。
    >     			.usernameParameter("loginacct") // 告知SpringSecurity登录表单中，用户框的name属性
    >     			.passwordParameter("password") // 告知SpringSecurity密码框的name属性
    >     			.loginProcessingUrl("/admin/doLogin") // 告知SpringSecurity跳转到登录页面的url
    >     			.defaultSucessUrl("/admin/index.html"); // 告知SpringSecurity登录成功后跳转的url
    >     	
    >     	http.csrf().disable(); // 暂时禁用CSRF
    >     }
    >     ```
    >     
### 3. 实验三：自定义表单登录逻辑分析
3. 实验三：自定义表单登录逻辑分析
    > 1. 当登录失败时，会回到指定的登录页面。并且，在登录页面的url后，会附带有?error参数，例如：```http://localhost:8080/spring-security/doLogin?error```
    > 
    > 2. 可以使用```${SPRING_SECURITY_LAST_EXCEPTION.message}```，在登录页面取出错误消息。取出的错误消息，和SpringSecurity自带的登录页面中，登录失败后出现的错误消息一样。
    > 
### 4. 实验四：自定义认证用户消息
4. 实验四：自定义认证用户消息
    > 1. 我们可以指定认证用户消息，来做登录验证。使用基于内存的认证，这样的用户验证是在内存中的，是写死的，只是用于临时的效果展示。
    >
    > 2. 自定义认证用户消息，需要在配置文件类中，重新重写一个configure()方法，方法参数变为了AuthenticationManagerBuilder。
    >
    >     ```
    >     @Override
    >     protected void configure(AuthenticationManagerBuilder auth) throws Exception {
    >     
    >     	// super.configure(auth); // 默认的认证，就是不认证
    >     	
    >     	// 基于内存的认证方式，是写死的
    >     	auth.inMemoryAuthentication()
    >     			.withUser("用户名1").password("密码1").roles("角色1"[, "角色2", ...])
    >     			.and()
    >     			.withUser("用户名2").password("密码2").authrities("具有的权限1", "具有的权限2", ...);
    >     			
    >     }
    >     ```
    >
    > 3. SpringSecurity为了防止跨站请求伪造，默认登录表单必须提交CSRF。我们可以暂时禁用CSRF来完成登录效果展示。
    > 
### 5. 实验五：CSRF
5. 实验五：CSRF
    > 1. 要想启用CSRF，前提是要在登录页面的表单中，有name为```_csrf```的隐藏域。SpringSecurity自带的登录页面中，自带有```_csrf```的隐藏域。
    > 
    > 2. 只要在配置类中，重写的configure(HttpSecurity)方法中，不禁用CSRF就启用了CSRF。
    > 
    > 3.  ```_csrf```的隐藏域中，name可以直接用```${_csrf.parameterName}```获取，value直接用```${_csrf.token}```获取。
    > 
    > 4. ```_csrf```是SpringSecurity提供的Token对象，token值是自动生成的。token值不会因为刷新或错误登录而改变；token验证成功，正确登录后，token销毁，回退到登录页面，token值会重新分配；或者重启浏览器，再次访问登录页面，也会重新分配token
    > 
    > 5. token值存在于Session域中，用户登录提交表单后，会先校验token值，如果没有token或者token不一样，则说明是跨站请求或者token已经过期，直接拒绝访问；如果token一致，则校验用户。
    > 
    > 6. 因为token在登录成功后会销毁，因此还可以解决登录页面表单重复提交问题。
    > 
    > 7. CSRF开启后，必须保证所有表单都有```_csrf```的隐藏域。
    > 
### 6. 实验六：用户注销完成
6. 实验六：用户注销完成
    > 1. SpringSecurity帮助我们写好了注销的请求，我们只需要在配置类中重写的configure(HttpSecurity http)方法中，开启注销请求即可。默认注销url：/logout
    >
    >     ```
    >     @Override
    >     protected void configure(HttpSecurity http) throws Exception {
    >     
    >     	// super.configure(http); // 默认的权限规则，任何请求都受到限制
    >     	
    >     	http.authorizeRequestRequest() // 授权请求
    >     			.antMatchers("/static/**", "/index.jsp").permitAll() // 设置匹配的资源放行。ant即ant风格。**在ant风格中，表示所有子路径
    >     			.anyRequest().authenticated(); //剩余任何资源都需要认证
    >     		
    >     	http.formLogin()
    >     			.loginPage("/index.jsp") 
    >     			.usernameParameter("loginacct") 
    >     			.passwordParameter("password") 
    >     			.loginProcessingUrl("/admin/doLogin") 
    >     			.defaultSucessUrl("/admin/index.html"); 
    >     	
    >     	// http.logout(); // 开启默认的注销请求，默认注销请求url：/logout
    >     	http.logout()
    >     			.logoutUrl("处理注销的url") // 告知SpringSecurity自定义注销请求的url
    >     			.logoutSuccessUrl("注销成功后跳转的url"); // 告知SpringSecurity注销成功跳转的url
    >     	
    >     }
    >     ```
    >     
    > 2. 开启了CSRF，则我们注销请求都必须以POST提交，同时请求表单中还需要csrf token
    > 
### 7. 实验七：基于角色的访问控制
7. 实验七：基于角色的访问控制
    > 1. 在配置类中重写的configure(HttpSecurity http)方法中，进行基于角色的访问控制 。超过角色权限的资源访问时，都会报403
    >
    >     ```
    >     @Override
    >     protected void configure(HttpSecurity http) throws Exception {
    >     
    >     	// super.configure(http); // 默认的权限规则，任何请求都受到限制
    >     	
    >     	http.authorizeRequestRequest() 
    >     			.antMatchers("/static/**", "/index.jsp").permitAll() 
    >     			.antMatchers("请求资源的url").hasRole("角色名") // 基于角色的访问控制
    >     			.antMatchers("请求资源的url").hasRole("角色名") // 基于角色的访问控制
    >     			.anyRequest().authenticated(); //剩余任何资源登录后都可以访问
    >     		
    >     	http.formLogin()
    >     			.loginPage("/index.jsp") 
    >     			.usernameParameter("loginacct") 
    >     			.passwordParameter("password") 
    >     			.loginProcessingUrl("/admin/doLogin") 
    >     			.defaultSucessUrl("/admin/index.html"); 
    >     	
    >     	// http.logout(); // 开启默认的注销请求，默认注销请求url：/logout
    >     	http.logout()
    >     			.logoutUrl("处理注销的url") // 告知SpringSecurity自定义注销请求的url
    >     			.logoutSuccessUrl("注销成功后跳转的url"); // 告知SpringSecurity注销成功跳转的url
    >     	
    >     }
    >     ```
    >     
    > 2. **在做基于角色的访问控制时，要注意：**
    >
    >     1. ```.anyRequest().authenticated(); //剩余任何资源登录后都可以访问```，必须要放在最后，表示其余的资源登录后都能访问。如果放在前面，则其他一切角色访问控制等都没用。
    >     
    >     2. 如果设置了所有```"/**"```都可以访问，则对其进行的其他设置都无效了
    >     
### 8. 实验八：自定义访问拒绝处理页面
8. 实验八：自定义访问拒绝处理页面
    > 1. 由于403访问拒绝页面对普通用户不友好，因此我们可以在配置类中重写的configure(HttpSecurity http)方法中，自定义访问拒绝处理页面
    >
    >     ```
    >     @Override
    >     protected void configure(HttpSecurity http) throws Exception {
    >     
    >     	// super.configure(http); // 默认的权限规则，任何请求都受到限制
    >     	
    >     	http.authorizeRequestRequest() 
    >     			.antMatchers("/static/**", "/index.jsp").permitAll() 
    >     			.antMatchers("请求资源的url").hasRole("角色名") // 基于角色的访问控制
    >     			.antMatchers("请求资源的url").hasRole("角色名") // 基于角色的访问控制
    >     			.anyRequest().authenticated(); //剩余任何资源登录后都可以访问
    >     		
    >     	http.formLogin()
    >     			.loginPage("/index.jsp") 
    >     			.usernameParameter("loginacct") 
    >     			.passwordParameter("password") 
    >     			.loginProcessingUrl("/admin/doLogin") 
    >     			.defaultSucessUrl("/admin/index.html"); 
    >     	
    >     	// http.logout(); // 开启默认的注销请求，默认注销请求url：/logout
    >     	http.logout()
    >     			.logoutUrl("处理注销的url") // 告知SpringSecurity自定义注销请求的url
    >     			.logoutSuccessUrl("注销成功后跳转的url"); // 告知SpringSecurity注销成功跳转的url
    >     			
    >     	http.exceptionHandling().accessDeniedPage("访问拒绝后跳转的url"); // 告知SpringSecurity访问拒绝后跳转url 
    >     	
    >     }
    >     ```
    >     
### 9. 实验九：记住我功能
9. 实验九：记住我功能
    > 1. SpringSecurity提供给我们了记住我的功能。
    >
    > 2. 我们先要在配置类中重写的configure(HttpSecurity http)方法中，开启记住我的功能
    >     ```
    >     @Override
    >     protected void configure(HttpSecurity http) throws Exception {
    >     
    >     	// super.configure(http); // 默认的权限规则，任何请求都受到限制
    >     	
    >     	http.authorizeRequestRequest() 
    >     			.antMatchers("/static/**", "/index.jsp").permitAll() 
    >     			.antMatchers("请求资源的url").hasRole("角色名") // 基于角色的访问控制
    >     			.antMatchers("请求资源的url").hasRole("角色名") // 基于角色的访问控制
    >     			.anyRequest().authenticated(); //剩余任何资源登录后都可以访问
    >     		
    >     	http.formLogin()
    >     			.loginPage("/index.jsp") 
    >     			.usernameParameter("loginacct") 
    >     			.passwordParameter("password") 
    >     			.loginProcessingUrl("/admin/doLogin") 
    >     			.defaultSucessUrl("/admin/index.html"); 
    >     	
    >     	// http.logout(); // 开启默认的注销请求，默认注销请求url：/logout
    >     	http.logout()
    >     			.logoutUrl("处理注销的url") // 告知SpringSecurity自定义注销请求的url
    >     			.logoutSuccessUrl("注销成功后跳转的url"); // 告知SpringSecurity注销成功跳转的url
    >     			
    >     	http.exceptionHandling().accessDeniedPage("访问拒绝后跳转的url"); // 告知SpringSecurity访问拒绝后跳转url 
    >     	
    >     	http.rememberMe(); // 开启记住我功能
    >     	
    >     }
    >     ```
    >     
    > 3. 在登录页面的表单中，添加一个复选框为记住我，保证复选框的name为remember-me
    >
    > 4. 至此，记住我功能就完成了
    >
    > 5. 记住我功能，其实还是利用的Cookie，浏览器存储了一个名为remember-me的cookie。如果清理了cookie，则记住我功能失效
    >
    > 6. 如果服务器重启了，则记住我的功能也会失效
    > 
### 10. 实验十：更好的记住我功能
10. 实验十：更好的记住我功能
    > 1. 虽然上述的记住我功能已经不错了，但是我们可以使用更好的记住我功能。
    > 
    > 2. 更好的记住我功能，是基于数据库的。基于数据库版的记住我，可以仅做了解
    > 
    > 3. 在数据库中创建一张表，表名必须叫做
    > 
    > 4. 在配置类中声明数据源
    > 
### 11. 实验十一：认证
11. 实验十一：认证
    > 1. 前面我们已经做过基于内存的认证，但是以后我们的认证肯定是要和数据库交互的。
    >
    > 2. 基于数据库的认证方式有两种
    >
    > 3. 第一种：重写jdbcAuthentication规则（不推荐）
    >
    > 4. 第二种：自定义UserDetailService（推荐）
    >
    >     1. 自定义一个类，实现UserDetailService接口
    >     
    >     2. 重写UserDetailService接口中的loadUserByUsername(String username)。这里暂时使用JdbcTemplate做数据库查询
    >     
    >         ```
    >         @Component
    >         public class UserDetailServiceImpl implements UserDetailService {
    >         	
    >         	@Autowired
    >             JdbcTemplate jdbcTemplate
    >         	
    >         	@Override
    >         	public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
    >         	
    >         		// 1. 自定义查询SQL
    >         		String sql = "SELECT * FROM `t_admin` WHERE loginacct=?";
    >         		
    >         		// 2. 查询用户信息
    >         		Map<String, Object> map = jdbcTemplate.queryForMap(sql, username);
    >         		
    >         		// 3. 将查询到的用户信息封装到SpringSecurity使用的Details中
    >         		// 这里的User是SpringSecurity中的User类。User对象中要封装用户名、密码、用户权限集合三个部分。
    >         		// 注意，如果是角色，角色必须写成"ROLE_角色名"这样的格式，以便SpringSecurity做资源授权时区别角色和权限
    >         		return new User(map.get("loginact").toString, map.get("userpswd").toString, AuthorityUtils.createAuthorityList("ROLE_角色", "权限", ...)); //这里创建权限集合时，角色和权限暂时写死，不查数据库
    >         		
    >         	}
    >         	
    >         }
    >         ```
    >     
    >     3. 使用@Component注解，让Spring管理实现类
    >     
    >     4. 在配置类中，使用@Autowired注解，注入实现类
    >     
    >         ```
    >         @Autowired
    >         UserDetailService userDetailService;
    >         ```
    >     
    >     5. 在配置类中，重写的configure(AuthenticationManagerBuilder auth)方法中，采用数据库验证方式
    >     
    >         ```
    >         @Override
    >         protected void configure(AuthenticationManagerBuilder auth) throws Exception {
    >         
    >         	// super.configure(auth); // 默认的认证，就是不认证
    >         	
    >         	// 基于数据库的认证
    >         	auth.userDetailsService(userDetailService)
    >         			
    >         }
    >         ```
    >         
### 12. 实验十二：自定义MD5加密
12. 实验十二：自定义MD5加密
    > 1. 因为默认的密码校验，按照明文进行的校验，我们需要让SpringSecurity进行密文的校验
    > 2. 密文校验步骤
    >
    >     1. 自定义实现类，实现PasswordEncoder接口
    >     
    >     2. 实现两个方法，一个加密方法，一个判断方法。
    >     
    >         ```
    >         @Component
    >         public class PasswordEncoderImpl implements PasswordEncoder {
    >         
    >         	@Override
    >         	public String encode(CharSequence rawPassword) {
    >         		// 将传入的密码进行加密
    >         		return MD5Util.digest(rawPassword.toString());
    >         	}
    >         	
    >         	@Override
    >         	public boolean matches(CharSequence rawPassword, String encodedPassword) {
    >         		
    >         		// 对登录表单传过来的明文密码进行加密
    >         		String rawPasswordEncode = MD5Util.digest(rawPassword.toString());
    >         		
    >         		// 将加密后的密码和数据库中对应密码进行判断
    >         		return rawPasswordEncode.equals(encodedPassword);
    >         		
    >         	} 
    >         	
    >         }
    >         ```
    >     
    >     3. 使用@Component注解，让Spring管理实现类
    >     
    >     4. 在配置类中，使用@Autowired注解，注入PasswordEncoder实现类
    >     
    >         ```
    >         @Autowired
    >         PasswordEncoder passwordEncoder;
    >         ```
    >         
    >     5. 在配置类中，重写的configure(AuthenticationManagerBuilder auth)方法中，采用数据库验证和密文验证方式
    >     
    >         ```
    >         @Override
    >         protected void configure(AuthenticationManagerBuilder auth) throws Exception {
    >         
    >         	// super.configure(auth); // 默认的认证，就是不认证
    >         	
    >         	// 基于数据库的认证和密文校验
    >         	auth.userDetailsService(userDetailService).passwordEncoder(passwordEncoder);
    >         			
    >         }
    >         ```
    >         
### 13. 实验十三：基于数据库的BCrypt加密
13. 实验十三：基于数据库的BCrypt加密
    > 1. 因为MD5加密方式仍然不是很安全，因此我们采用更安全的BCrypt加密
    >
    > 2. BCrypt加密逻辑：MD5加密+盐+随机值。这样就可以保证，即使是同一个密码的MD5加密值，但是经过加盐和加随机值，每次都是不同的。
    >
    > 3. BCrypt加密SpringSecurity框架已经提供给我们了，BCryptPasswordEncoder类就是SpringSecurity提供给我们做BCrypt加密的。
    >
    > 4. BCrypt加密使用步骤：
    >
    >     1. 配置类中，重写的configure(AuthenticationManagerBuilder auth)方法中采用数据库验证和BCrypt加密验证
    >
    >         ```
    >         @Override
    >         protected void configure(AuthenticationManagerBuilder auth) throws Exception {
    >         
    >         	// super.configure(auth); // 默认的认证，就是不认证
    >         	
    >         	// 基于数据库的认证和BCrypt加密验证
    >         	auth.userDetailsService(userDetailService).passwordEncoder(new BCryptPasswordEncoder());
    >         			
    >         }
    >         ```
    >
    > 5. BCrypt加密明文：
    >
    >     1. new一个BCryptPasswordEncoder对象
    >
    >     2. 使用encode("明文字符串")方法对明文加密
    >
## 4. SpringSecurity源码分析
4. SpringSecurity源码分析：详细分析，参见文档
    > 1. 如何打第一批断点
    >
    >     1. 找到SpringSecurity的入口，即SpringSecurity的过滤器中的doFilter()方法
    >     
    >     2. 找到最底层的入口：即SpringSecurity的配置文件中，调用数据库连接，查询数据库的时候。
    >     
    >     3. 过滤器和底层之间，就是SpringSecurity的源码
    >     
    > 2. 第一批断点中的源码分析：
    >
    >     1. 请求发起，Tomcat会启用一个线程来处理请求
    >     
    >     2. 所有的Listner、Filter、Servlet都是被Tomcat的容器管理的。Controller对象、Service对象、Component对象等才是被Spring的IOC容器管理的。
    >     
    >     3. Tomcat调用SpringSecurity的代理过滤器来处理请求
    >     
    >     4. 代理过滤器调用SpringSecurity中的13个核心过滤器来处理请求
    >     
    >         1. ThreadLocal<T>类：用来存储用户信息，做线程资源共享的。因为普通Java项目没有Request域、Session域等，因此需要ThreadLocal来存储信息。ThreadLocal可以保证线程之间的信息隔离。
    >         
    >         2. 我们知道ThreadLocal仅仅只是个管理类而已，真正的对象存储在Thread里。ThreadLocal会被当作ThreadLocalMap的key，而Thread持有ThreadLocalMap，进而间接持有ThreadLocal
    >         
    >         3. ThreadLocal中，有一个ThreadLocalMap，它使用一个类似于Map的结构也是使用键值对来存储，存储线程共享数据的。ThreadLocalMap会将线程信息作为键，存储的数据作为值存储起来，之后哪个线程来获取就获取到该线程对应存储的值。保证了线程之间的信息隔离。
    >         
    >         4. 一个ThreadLocal只能将一个数据绑定到线程上，想要绑定几个数据，就要创建几个ThreadLocal对象。
    >         
    >         5. ThreadLocal无法解决数据安全问题，数据安全问题一般是靠提升内存，靠着多例的方式，为每一个线程提供一个独立的对象来解决的。
    >         
    >         6. 在MyBatis中，分页插件就使用了线程绑定的技术。```PageHelper.startPage(pageNum, pageSize);```就是在与当前线程绑定，使得Dao层中的方法也可以知道pageNum和pageSize的信息。
    >         
## 5. SpringSecurity框架重要的API
5. SpringSecurity框架重要的API
    > 1. 具体参见文档
    > 
## 6. 细粒度的权限控制
6. 细粒度的权限控制
    > 1. 前置细节：授权有两种，一种通过角色Role，一种直接授予权限Authority
    > 
    > 2. 用户授权：在基于内存的认证时，使用到了
    > 
    >     1. ```.roles("角色1", ...)```
    >     
    >     2. ```.authority("权限1", ...)```
    >     
    > 3. 资源授权：给不同资源授予不同权限，让不同权限的用户可以访问
    > 
    >     1. ```.antMatchers("资源url").hasRole("角色")```：有指定的角色才可以访问
    >     2. ```.antMatchers("资源url").hasAuthority("权限")```：有指定的权限才可以访问
    >     3. ```.antMatchers("资源url").hasAnyRole("角色1", "角色2", ...)```：有其中一种角色可以访问
    >     4. ```.antMatchers("资源url").hasAnyAuthority("权限1", "权限2", ...)```：有其中一种权限可以访问
    >     
    > 4. Role和Authority区别
    > 
    >    在做资源授权时，调用```hasRole("角色")```，SpringSecurity会去查权限时自动添加```ROLE_```前缀，去权限集合中查有没有```"ROLE_角色"```的权限
    >    
    >    在做资源授权时，调用```hasAuthority("权限")```，SpringSecurity会去查权限时直接查有没有"权限"的权限
    >    
    >    因此，我们在从数据库中查找了用户角色和权限，放入权限集合时，对于角色必须加上```ROLE_```前缀，然后再放入。
    >    
    > 5. 细粒度的资源控制：除了上述的```hasRole()```、```hasAuthority()```等，还有以下常见的几种
    > 
    >     * ```authenticated()```：通过认证的用户都可以访问
    >     
    >     * ```permitAll(```)：允许所有人访问，即使未登录
    >     
    >     * ```authorizeRequests()```：更细粒度的控制
    >     
    >     * ```access(String)```： SpEL：Spring表达式
    >     
    >         * access(String)运用
    >         
    >            ```.access("hasRole('大师') AND hasAuthority('user:delete') OR hasIpAddress('192.168.50.15')")```
    >     
    >     * 还有很多，这里不再列举。具体参见文档
    >     
## 7. 细粒度资源控制相应注解
### 1. 开启细粒度资源权限控制注解
1. 开启细粒度资源权限控制注解：在配置类上，加入以下两个注解
    > 1. ```@EnableWebSecurity```：开启SpringSecurity注解
    > 
    > 2. ```@EnableGlobalMethodSecurity(prePostEnabled=true)```：开启全局的方法级别，细粒度权限控制功能
    > 
### 2. 几个权限检查注解
2. 几个权限检查注解：加在Controller层中类的方法上
    > 1. ```@PreAuthorize("细颗粒度访问控制方法")```：方法执行前检查授权。value值为细颗粒度访问控制方法，可以使用SpEL
    > 
    > 2. ```@PostAuthorize("returnObj")```：方法执行后检查，失败直接抛出异常
    > 
    > 3. ```@PostFilter("")```：允许方法调用，但是按照表达式过滤方法结果
    > 
    > 4. ```@PreFilter("")```：允许方法调用，但必须在进入方法前过滤输入的值
    > 
    > 5. ```@Secured('角色名')```：只有指定的角色才可以访问该方法，等价于```@PreAuthorize("hasRole('角色名')")```
    > 
    > 5. 更加具体的注解，参见Spring官方网站中SpringSecurity的官方文档
    > 
## 8. 使用细粒度的权限控制
8. 使用细粒度的权限控制
    > 1. 开启全局的方法级别细粒度权限控制
    > 
    >    在配置类上，加入```@Configuration```、```@EnableWebSecurity```、```@EnableWebSecurity(prePostEnabled=true)```三个注解
    >    
    > 2. 将需要细粒度权限控制的手动授权，全部注释掉
    > 
    >    对于首页、静态资源等需要大范围授权的，在配置文件中进行授权；需要单独授权的，通过注解授权
    > 
    > 3. 给访问资源的Controller中的方法，都添加响应的权限控制注解
    > 
# 6. SSM整合SpringSecurity
6. SSM整合SpringSecurity
    > 1. 导入SpringSecurity的依赖
    >
    > 2. 编写SpringSecurity的配置
    >
    >     1. 配置SpringSecurity的过滤器
    >     
    >     2. 编写配置类
    >     
    >     3. 编写异常的处理器AccessDeniedHandler：
    >     
    >        对于没有访问权限的资源，如果访问了会抛出异常。我们需要自定义一个异常处理器来处理异常。
    >        
    >        可以直接使用匿名内部类来做
    >        
    >        **注意：异常的处理器AccessDeniedHandler，不能放在配置类中重写的configure(HttpSecurity http)方法的最后，否则无法生效**
    >     
    >     4. 编写TAdminUser，继承SpringSecurity的User
    >     
    >        因为普通的SpringSecurity的User中，只能存储用户的密码和用户名。实际开发中，我们需要将登陆后，用户密码进行擦除，然后用户的信息全部封装。因此我们编写一个TAdminUser继承User，在TAdminUser中定义一个成员变量来存储擦除了用户密码的用户信息。
    >        
    >         * TAdminUser例子：
    >        
    >             ```
    >             public class TAdminUser extends User {
    >             
    >                 private TAdmin originalUser; // 保存用户信息
    >             
    >                 public TAdmin getOriginalUser() {
    >                     return originalUser;
    >                 }
    >             
    >                 public void setOriginalUser(TAdmin originalUser) {
    >                     this.originalUser = originalUser;
    >                 }
    >             
    >                 public TAdminUser(TAdmin originalUser, Collection<? extends GrantedAuthority> authorities) {
    >                     super(originalUser.getLoginacct(), originalUser.getUserpswd(), authorities);
    >                     this.originalUser = originalUser;
    >                     originalUser.setUserpswd(""); // 必须保证保存的用户信息中，擦除了密码
    >                 }
    >             
    >                 public TAdminUser(String username, String password, boolean enabled, boolean accountNonExpired,
    >                                   boolean credentialsNonExpired, boolean accountNonLocked, Collection<? extends GrantedAuthority> authorities) {
    >                     super(username, password, enabled, accountNonExpired, credentialsNonExpired, accountNonLocked, authorities);
    >                 }
    >                 
    >             }
    >             ```
    >        
    >     5. 编写UserDetailService的实现类
    >     
    >     6. 让SpringMVC扫描组件
    >     
    > 3. **注意：**
    >
    >    @PreAuthorize不能标注在@Controller上，原因是Security的配置是被spring容器管理（Spring配置文件）。
    >    
    >    Spring配置文件没有扫SpringMVC的东西，导致SpringMVC中的组件不能被Security识别
    >    
    >    解决方法：在web.xml中让springMVC管理spring的容器和springMVC的容器，删除Spring的监听器
    >    
    > 4. 异常处理器
    >
    >    我们使用了匿名内部类来实现了AccessDeniedHandler。
    >    
    >    对于同步请求，我们异常处理应该让其跳转到一个错误页面
    >    
    >    对于异步请求，我们异常处理应该返回一个错误的String
    >    
    >    如何区分同步请求和异步请求呢？我们可以通过请求头中的X-Requested-With来确定。如果是异步请求，则X-Requested-With:XMLHttpRequest；如果是同步请求，则请求头中没有X-Requested-With
    >    
    > 5. SpringSecurity有一个自己的标签库，可以通过SpringSecurity的标签来控制页面的元素
    >
    >     1. 引入SpringSecurity的标签，和jstl标签同样的引入方式
    >     
    >         ```
    >         <%@ taglib prefix="sec" uri="http://www.springframework.org/security/tags" %>
    >         ```
    >     
    >     2. SpringSecurity在认证用户成功后，会把用户信息放入Session域中。我们可以使用SpringSecurity的标签来取出用户信息
    >     
    >         ```
    >         <sec:authentication property="name"/>
    >         ```
    >         
    >         * 注意：这里的property固定写成name
    >         
    >     3. 通过SpringSecurity标签，根据用户权限指定页面一些元素的可见与否。
    >     
    >         ```
    >         <sec:authorize access="SpEl表达式">
    >         	页面元素
    >         </sec:authorize>
    >         ```
    >         
    >     4. 更多参考标签，参见文档或者Spring官网
    >     
# 7. SpringBoot框架
7. SpringBoot框架
    > 1. 概述
    >
    >    SpringBoot设计目的，就是为了简化新Spring应用的初始搭建和开发过程。**习惯优于配置**
    >    
    >    是对Spring的再次封装，底层还是Spring+SpringMVC
    >    
    > 2. SpringBoot优点
    >
    >    快速创建独立运行的Spring项目以及主流框架的集成
    >    
    >    SpringBoot使用了嵌入式Servlet容器，应用无需打成war包
    >    
    >    starters自动依赖与版本控制
    >    
    >    大量的自动配置，简化了开发，也可以修改默认值
    >    
    >    无需配置XML，无代码生成
    >    
    >    准生产环境时的应用监控
    >    
    >    与云计算的天然集成
    >    
## 1. 项目架构-单体应用
1. 项目架构-单体应用
    > 1. 介绍
    > 
    >    所有的代码写在一个项目中，部署在一个Tomcat上。
    >    
    > 2. 优点
    > 
    >    大众熟知、IDE友好、便于共享、易于测试、容易部署
    >    
    > 3. 缺点
    > 
    >    不够灵活、妨碍持续交付、受到技术栈限制、技术债务
    >    
## 2. 项目架构-微服务
2. 项目架构-微服务
    > 1. 介绍
    > 
    >    微服务架构风格，就像是把一个单独的应用程序开发为一套小服务，每个小服务运行在自己的进程中，并使用轻量级机制通信，通常是 HTTP API。
    >    
    >    这些服务围绕业务能力来构建，并通过完全自动化部署机制来独立部署。这些服务使用不同的编程语言书写，以及不同数据存储技术，并保持最低限度的集中式管理。
    >    
## 3. SpringBoot项目-手动创建
3. SpringBoot项目-手动创建
    > 1. 创建Maven工程：普通的Java项目即可
    >
    > 2. 引入POM依赖
    >
    >     1. 引入父工程：所有的SpringBoot都必须依赖于spring-boot-starter-parent父工程
    >     
    >     2. 引入SpringBoot的web依赖
    >     3. 引入SpringBoot插件：打包插件
    >     
    >         ```
    >         <?xml version="1.0" encoding="UTF-8"?>
    >         <project xmlns="http://maven.apache.org/POM/4.0.0"
    >                  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    >                  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    >             <modelVersion>4.0.0</modelVersion>
    >         
    >             <groupId>org.example</groupId>
    >             <artifactId>springboot_byhuman</artifactId>
    >             <version>1.0-SNAPSHOT</version>
    >         
    >             <properties>
    >                 <maven.compiler.source>9</maven.compiler.source>
    >                 <maven.compiler.target>9</maven.compiler.target>
    >             </properties>
    >         
    >             <parent>
    >                 <groupId>org.springframework.boot</groupId>
    >                 <version>2.4.1</version>
    >                 <artifactId>spring-boot-starter-parent</artifactId>
    >             </parent>
    >         
    >             <dependencies>
    >                 <dependency>
    >                     <groupId>org.springframework.boot</groupId>
    >                     <artifactId>spring-boot-starter-web</artifactId>
    >                 </dependency>
    >             </dependencies>
    >             
    >             <build>
    >                 <plugins>
    >                     <plugin>
    >                         <groupId>org.springframework.boot</groupId>
    >                         <artifactId>spring-boot-maven-plugin</artifactId>
    >                     </plugin>
    >                 </plugins>
    >             </build>
    >         
    >         </project>
    >         ```
    >         
    >         * starter就是场景启动器，SpringBoot提供了很多的starter模块。一个starter模块中有很多的jar包
    >         * starter-web模块，引用了SpringMVC和Tomcat
    >         * 因为继承了父工程，因此SpringBoot父工程的依赖管理就被继承了，我们写依赖时，就不用写版本了
    >     
    > 3. 增加控制器
    >    
    >     ```
    >     @Controller
    >     public class HelloController {
    >      
    >     	@ResponseBody
    >     	@GetMapping("/hello")
    >       public String handle() {
    >      	return "HELLO, WORLD!";
    >     	}
    >         	
    >     }
    >     ```
    >     
    > 4. 编写主程序：每一个SpringBoot都有一个主程序，用来启动SpringBoot中的Tomcat
    >
    >     ```
    >     @SpringBootApplication // 声明当前项目为SpringBoot项目
    >     public class SpringBootRun {
    >         
    >         public static void main(String[] args) {
    >             // 启动内置的Tomcat
    >             SpringApplication.run(SpringBootRun.class, args);
    >         }
    >     }
    >     ```
    >     
    > 5. SpringBoot项目可以打包后，在cmd中，使用```java -jar jar包路径```直接运行。因为SpringBoot中自带Tomcat，主程序中的main()方法会被自动执行。
    >    
## 4. SpringBoot模块介绍
4. SpringBoot模块介绍
    > 1. 参见文档
    > 
## 5. 快速创建SpringBoot项目
5. 快速创建SpringBoot项目
    > 1. 使用SpringInitializr来创建
    > 
    > 2. 必须保证我们之后的controller包、service包、dao包放在主程序所在的包下才行。或者我们可以在主程序上加```@ComponentScan()```来扫描所有资源所在的包。但是我们遵循**习惯大于配置**原则，将包放在主程序所在包下最好。
    > 
    > 3. 以后我们都通过这种方式来创建项目最好。
    > 
    > 4. SpringBoot部分目录和文件讲解：
    > 
    >     1. resources下的static目录，级别为根目录，存放静态资源
    >     
    >     2. resources下的templates目录，存放页面文件，例如jsp等文件。
    >     
    >     3. resources下的application.properties文件，用来详细配置当前的SpringBoot项目。当然，如果什么也不写，则SpringBoot使用自己的默认配置
    >     
    >         * 例如，指定项目端口号：```server.port=8081```
    >         
    >         * 例如，指定上下文路径。但是一般不会指定。
    >         
    >         * 例如，指定Session存活时间，以秒为单位：```server.servlet.session.timeout=60```
    >         
    >         * 例如，指定本项目的Tomcat最大线程数量：```server.tomcat.max-threads=500```。
    >         
    >         * 例如，指定本项目的Tomcat的uri编码，解决GET请求中文乱码：```server.tomcat.uri-encoding=UTF-8```
    >         
## 6. yml文件
6. yml文件
    > 1. 介绍
    > 
    >    yml文件是一种比xml、json等更适合做配置的文件格式。
    >    
    > 2. 我们可以在resources文件夹下，创建一个application.yml文件（必须为这个名字），将对该SpringBoot项目的配置写在application.yml文件中。
    > 
    >     * 注意：如果application.properties属性文件中和application.yml文件中配置了相同的配置，最终以application.properties中为主。但是一般没人会在两个文件中配相同的配置。
    >     
    >     * 更多的配置，参见SpringBoot官方文档。
    >     
    > 3. yml文件，也是以键值对的方式存储配置信息，但是会自动进行层级缩进。yml的值支持字面量、对象、数组三种数据类型，一般使用字面量较多。
    > 
    >     * 字面量：包括字符串、数字、布尔
    >     
    >         * 字符串默认不加引号
    >         
    >         * 双引号：加了双引号，不会转移里面的特殊字符，例如```\n```，特殊字符会按照原来的目的表现出来，例如```\n```会直接换行
    >         
    >         * 单引号：加了单引号，会转移里面的特殊字符，例如```\n```会直接转义为普通字符串```\n```
    >         
    >     * 对象：按照行内写法，直接写成```{键: 值, 键: 值, ...}```，就将一个对象写出来了。
    >     
    >     * 数组：按照行内写法，直接写成```[值1, 值2, ...]```，就将一个数组写出来了
    >     
## 7. SpringBoot自动配置原理
7. SpringBoot自动配置原理
    > 1. SpringBoot将大多数的东西已经自动帮我们配置好了，其中最重要的就是```spring-boot-autoconfigure-xx.xx.x.jar```自动配置包。
    > 2. 当我们将需要的starter引入之后，配置包中的对应配置
    > 3. ```@SpringBootConfiguration```注解是基于```@Configuration```注解的，它是SpringBoot封装的Spring的配置类。
    > 4. 在配置类中，对一个方法使用```@Bean```注解，表示该方法就是一个Bean对象，等同于以前在xml文件中交给Spring管理的Bean。方法名就是以前Bean的id名；方法返回的对象，就是以前Bean的class
    > 
## 8. SpringBoot如何配置视图解析器
8. SpringBoot如何配置视图解析器
    > 1. 在SpringBoot的application.properties中或者application.yml配置：
    > 
    >     1. ```spring.mvc.view.prefix=/templates/```
    >     
    >     2. ```spring.mvc.view.suffix=.jsp```
    >     
    > 2. 因为默认视图解析器是InternalResloveViewReslover，它只能解析jsp视图。以后我们开发都是使用的Thymeleaf，Thymeleaf开发的都是html视图，因此我们必须用Thymeleaf的解析器。
    > 3. 使用Thymeleaf的解析器，我们只需要引入Thymeleaf的Starter模块，这样自动配置包就会将Thymeleaf的配置类加载，Thymeleaf的解析器就会替换原本的视图解析器。
    > 
    > 4. 此时我们只需要在application.properties或application.yml中配置Thymeleaf的视图解析路径即可：如果没有配置，默认Thymeleaf视图解析路径为```classpath:/templates/```、```.html```
    > 
    >     1. ```spring.thymeleaf.prefix=classpath:/templates/```
    >     
    >     2. ```spring.thymeleaf.suffix=.html```
    >     
## 9. SpringBoot配置的策略
9. SpringBoot配置的策略
    > 1. 遵循：自定义组件自己配置，否则用默认配置即可。
    > 
# 8. SpringBoot+MyBatis整合
8. SpringBoot+MyBatis整合
    > 1. 整合步骤
    >
    >     1. 创建SpringBoot项目，创建时选择JDBC API、MyBatis、SpringBoot Web这几个组件
    >
    >     2. 添加application.yml文件，配置数据源和MyBatis配置信息（包括配置文件所在和Mapper映射所在）
    >
    >         ```
    >         spring:
    >           datasource:
    >             username: root
    >             password: root
    >             url: jdbc:mysql://192.168.20.128/atcrowdfinding?useSSL=false&useUnicode=true&characterEncoding=UTF-8
    >             driver-class-name: com.mysql.cj.jdbc.Driver
    >         mybatis:
    >           config-location: classpath:mybatis/mybatis-config.xml
    >           mapper-locations: classpath:mybatis/mapper/*.xml
    >         ```
    >
    >     3. 添加MyBatis配置文件和Mapper映射文件
    >
    >     4. 在主程序上，还要添加```@MapperScan("com.yuu.springboot.mapper")```注解，让SpringBoot扫描com.yuu.springboot.mapper包下所有的Mapper接口，然后管理所有Mapper接口的对象
    >
    > 2. SpringBoot声明式事务
    >
    >     1. 之前SSM框架中，声明式事务需要在配置类中配置数据源、切入点表达式等，过于繁琐
    >     2. SpringBoot配置声明式事务，只需要在主程序上，加入```@EnableTransactionManagement```注解，即开启了声明式事务
    >     
    >     3. 之后，SpringBoot中的方法上，只要加入```@Transactional```注解，就给方法加入了事务。如果一个类中所有方法都要开启事务，并且每个方法的事务都相同，则可以直接在类上加入```@Transactional```注解，如果有方法事务不同，则给不同的方法上加入注解即可。
    >     
    > 3. SpringBoot的Mapper注解
    >
    >     1. 因为在Mapper映射文件中，写各种SQL语句还是麻烦，因此我们可以不用Mapper的映射文件了
    >     
    >     2. SpringBoot支持在Mapper接口中的各种方法上，使用```@Select("原先的SQL语句")```、```@Insert("原先的SQL语句")```等，来代替映射文件中的各个简单SQL。当然，如果是复杂的SQL和动态SQL，也还是需要Mapper的映射文件的。
    >     
    >     4. 所以，SpringBoot框架中几乎就没有xml配置文件了，可以用注解来代替很多配置文件的作用。
    >     
    > 4. SpringBoot集成Druid
    >
    >     1. SpringBoot底层默认的数据库连接池为```com.zaxxer.hikari.HikariDataSource```
    >     
    >     2. 如果想要使用Druid数据源，我们需要：
    >     
    >         1. 引入Druid的依赖
    >         
    >         2. 配置Druid。
    >         
    >             1. 在application.yml中，配置数据源。
    >         
    >                ```
    >                spring:
    >                  datasource:
    >                    username: root
    >                    password: root
    >                    url: jdbc:mysql://192.168.20.128/atcrowdfinding?useSSL=false&useUnicode=true&characterEncoding=UTF-8
    >                    driver-class-name: com.mysql.cj.jdbc.Driver
    >                    # 配置Druid数据源
    >                    type: com.alibaba.druid.pool.DruidDataSource
    >                ```
    >             
    >             2. 新建一个配置类，用来配置Druid，同时将Druid交给SpringBoot容器管理
    >             
    >                 1. 创建一个配置类的包
    >                 
    >                 2. 创建Druid配置类
    >                 
    >                     ```
    >                     @SpringBootConfiguration
    >                     public class DruidDataSourceConfiguration {
    >                     
    >                         @ConfigurationProperties(prefix = "spring.datasource")
    >                         @Bean
    >                         public DataSource dataSource() throws SQLException {
    >                             DruidDataSource ds = new DruidDataSource();
    >                             ds.setFilters("stat"); // 配置监控系统拦截的filters
    >                             return ds;
    >                         }
    >                         
    >                     }
    >                     ```
    >     
    > 5. SpringBoot集成Druid的监控系统
    >
    >     1. 集成步骤
    >     
    >         1. 使用Druid配置类配置Druid数据源
    >         
    >         2. 在Druid配置类中，配置Druid的监控
    >         
    >             ```
    >             @SpringBootConfiguration
    >             public class DruidDataSourceConfiguration {
    >             
    >                 @ConfigurationProperties(prefix = "spring.datasource")
    >                 @Bean
    >                 public DataSource dataSource() throws SQLException {
    >                     DruidDataSource ds = new DruidDataSource();
    >                     ds.setFilters("stat"); // 配置监控系统拦截的filters
    >                     return ds;
    >                 }
    >             
    >                 // 配置Druid监控
    >                 // 1. 监控后台的Service
    >                 @Bean
    >                 public ServletRegistrationBean statViewServlet() {
    >                     // 设置哪个路径可以访问Druid监控系统
    >                     ServletRegistrationBean bean = new ServletRegistrationBean(new StatViewServlet(), "/druid/*");
    >                     Map<String, String> initParams = new HashMap<>();
    >                     initParams.put("loginUsername", "admin"); // 设置监控系统登录的用户名
    >                     initParams.put("loginPassword", "123456"); // 设置监控系统登录的密码
    >                     initParams.put("allow", ""); // 默认允许所有访问监控系统
    >                     initParams.put("deny", ""); // 拒绝哪个ip访问监控系统
    >                     bean.setInitParameters(initParams);
    >                     return bean;
    >                 }
    >             
    >                 // 2. 配置web监控的Filter
    >                 @Bean
    >                 public FilterRegistrationBean webStatFilter() {
    >                     FilterRegistrationBean bean = new FilterRegistrationBean();
    >                     bean.setFilter(new WebStatFilter());
    >                     Map<String, String> initParams = new HashMap<>();
    >                     initParams.put("exclusions", "*.js,*.css,/druid/*"); // 排除过滤
    >                     bean.setInitParameters(initParams);
    >                     bean.setUrlPatterns(Arrays.asList("/*")); // 过滤所有
    >                     return bean;
    >                 }
    >             }
    >             ```
    >     
    > 6. SpringBoot集成Web组件
    >
    >     1. 常见的Web组件，例如Filter、Listner等。因为我们SpringBoot中没有web.xml了，因此SpringBoot提供了多个注解来整合Web组件
    >     
    >     2. SpringBoot要想开启注解整合Web组件，要在主程序上添加```@ServletComponentScan```注解
    >     
    >     3. 监听器的注解```@WebListener```
    >     
    >         1. 自定义一个类，实现ServletContextListener
    >         
    >         2. 在自定义类上，添加```@WebListener```即可
    >         
    >     4. 过滤器的注解```@WebFilter(urlPatterns="/*")```，注解中urlPatterns写要过滤的url
    >     
    >         1. 自定义类，实现ServletContextFilter接口
    >         
    >         2. 在自定义类上，添加```@WebFilter(urlPatterns="/*")```注解
    >         
    >     5. Servlet的注解```@WebServlet(urlPatterns="/xxx")```，注解中的urlPatterns写经过该Servlet处理的url。该注解基本不会使用
    >     
    >         1. 自定义类，继承HttpServlet
    >         
    >         2. 在自定义的类上，添加```@WebServlet(urlPatterns="/xxx")```注解
    >     
# 9. 分布式介绍
9. 分布式介绍
    > 1. 介绍
    > 
    >    分布式系统，就是多个独立的计算机的集合
    >    
    > 2. 分布式和集群的联系
    > 
    >    集群指的是：多个服务器集中起来，实现同一个业务
    >    
    >    分布式中，每一个节点都可以做集群；但是，集群不一定是分布式的
    >    
# 10. RPC
10. RPC
    > 1. 介绍
    > 
    >    RPC(Remote Procedure Call)，远程服务调用，是一种进程间的通信方式。
    >    
    >    它是一种技术思想，而不是规范。
    >    
    >    它主要用来解决各个服务之间，相互通信的问题
    >    
    > 2. RPC最重要的两个点：连接的建立、数据的传递
    > 
    > 3. 实现了RPC的框架：Netty
    > 
# 11. 分布式思想和基本概念
11. 分布式思想和基本概念
    > 1. 高并发
    > 
    >     1. 介绍
    >     
    >        通过设计，能够保证系统可以并行处理很多请求，应对大量流量和请求
    >        
    >     2. 高并发衡量指标
    >        
    >         * 响应时间(RT)
    >         
    >         * 吞吐量：系统单位时间处理请求的数量
    >         
    >         * QPS(Query Per Second)、TPS(Transaction Per Second)：每秒查询数、每秒事务数
    >         
    >         * 并发用户数：系统可以同时承载正常使用系统功能的用户数量
    >     
    > 2. 高可用
    > 
    >     1. 服务器集群部署
    >     
    >     2. 数据库主从+双机热备
    >     
    >         * 主从
    >         
    >         * 双主机
    >     
    > 3. 注册中心
    >    
    > 4. 负载均衡
    >    
    >     * 负载均衡的策略：
    >       
    >         1. 轮询策略(Round Robin)
    >            
    >         2. 加权轮询(Wighted Round Robin)
    >            
    >         3. 随机
    >            
    >         4. 哈希
    >            
    >         5. 最小连接数
    >            
    >         6. 最短响应时间
    >     
    > 5. 服务器雪崩：当服务之间复杂调用形成调用链，其中一个出现问题，整个调用链所有服务全部出现问题。
    >    
    > 6. 熔断：某个服务频繁超时，直接将其短路，快速返回mock(虚拟/模拟)值。解决了雪崩问题
    > 
    > 7. 限流：限制某个服务器调用本服务的频率。防爬虫和DDoS攻击
    > 
    > 8. API网关：系统的后端总入口，承载着所有服务的组合、路由转换等工作，除此之外，我们也会把安全、限流、缓存、日志、监控、重试、熔断等机制也交给API网关
    > 
    > 9. 服务跟踪：追踪服务的调用链，记录整个系统的执行过程
    > 
    > 10. 弹性云：ECS弹性计算服务。动态扩容，压榨服务器空闲时间。
    > 
# 11. SpringCloud
11. SpringCloud
    > 1. 介绍
    > 
    >    SpringCloud是一系列框架的有序集合，是分布式系统的整体解决方案。
    >    
    > 2. SpringCloudNetfix
    > 
    >    是SpringCloud的子项目之一，使用它来了解SpringCloud
    >    
## 1. 注册中心(Eureka)
1. 注册中心(Eureka)
    > 1. 介绍
    >
    >    分布式中，最先开发注册中心。
    >    
    >    注册中心本身也是一个服务
    >    
    >    开发了注册中心后，之后的开发的服务在注册中心注册，不同的服务通过注册中心进行远程调用
    >    
    >    注册中心实际开发中，也必须使用主从+双机，即有两个注册中心。
    >    
    > 2. Region和Zone
    >
    >     1. 介绍
    >     
    >        Region相当于一个大区，Zone相当于一个机房。一个Region中可以有多个Zone。
    >        
    >        在SpringCloud中，服务消费者会优先查找在同一个Zone下的服务，之后才回去找其他服务
    >     
    > 3. 注册中心的创建
    >
    >     1. 创建普通的SpringBoot工程，引入Eureka Server
    >     
    >     2. 在主程序上，添加```@EnableEurekaServer```注解
    >     
    >     3. 编写application.yml，并配置
    >     
    >         ```
    >         spring:
    >           application:
    >             name: cloud-eureka-registry-center
    >         
    >         server:
    >           port: 8761
    >         
    >         eureka:
    >           instance:
    >             hostname: localhost # 指定当前注册中心的ip
    >           client:
    >             register-with-eureka: false # 是否在注册中心注册自己。自己就是注册中心，不用注册自己
    >             fetch-registry: false # 是否去注册中心获取其他服务地址。自己是注册中心，是存储其他服务地址的，不用换获取
    >             service-url: 
    >               defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/ # 指定该注册中心的url
    >         ```
    >         
## 2. 具体服务
2. 具体服务
    > 1. 引入Eureka的client依赖、引入web模块
    > 
    > 2. 小插曲：```@RestController```注解，作用于类，相当于```@Controller```+```@Responsebody```的效果
    > 
    > 3. 创建application.yml，在yml文件中配置服务端口等信息，并且配置制定注册到哪个注册中心
    > 
    > 4. 在自己的主程序上，添加```@EnableDiscoveryClient```注解，启动服务注册和发现功能
    >     * 当服务在注册中心注册后，服务和注册中心之间采取心跳机制。每隔一段时间服务给注册中心发送一个心跳信息，告诉注册中心服务正常；如果超时一段时间注册中心没有检测到心跳信息，则判断该服务下线，从服务注册列表中将该服务去除。
    >
## 3. Ribbon
3. Ribbon
    > 1. 介绍
    > 
    >    Spring Cloud Ribbon是一个基于HTTP和TCP的客户端负载均衡工具
    >    
    >    它是一个代理，代理客户端。它指定消费者调用哪一台生产者。因此Ribbon负载均衡加在客户端，使用```@LoadBalanced```注解添加
    >    
## 4. 远程调用
4. 远程调用
    > 1. 如何远程调用
    >
    >     1. 采用RestTemplate进行远程调用
    >     
    >         1. 在客户单的主程序类中，使用```@Bean```注解声明一个RestTemplate，同时，必须要加入```@LoadBalanced```注解开启负载均衡
    >         
    >             ```
    >             @LoadBalanced
    >             @Bean
    >             public RestTemplate getRestTemplate() {
    >             	return new RestTemplate();
    >             }
    >             ```
    >             
    >             * 因为RestTemplate默认集成了Ribbon，因此可以直接使用```@LoadBalanced```注解开启负载均衡，之后使用RestTemplate调用远程时会使用负载均衡。
    >             
    >         2. 在需要远程调用的方法，所在的类中，添加自动装配的RestTemplate
    >         
    >             ```
    >             @Autowired
    >             RestTemplate restTemplate;
    >             ```
    >             
    >         3. 使用声明的RestTemplate进行远程调用
    >         
    >             ```
    >             Movie movie = restTemplate.getForObject("http://CLOUD-PROVIDER-MOVIE/movie/" + moviId, Movie.class);
    >             ```
    >             
    >             * 注意，这里的host必须要写成注册中心的Application的值。
    >         
    >     2. 采用Feign进行远程调用：声明式调用，重点掌握
    >     
    >         1. 在客户端中，引入Feign模块：feign模块用于远程调用，声明式的客户端工具
    >         
    >             ```
    >             <dependency>
    >             	<groupId>org.springframework.cloud</groupId>
    >             	<artifactId>spring-cloud-starter-openfeign</artifactId>
    >             </dependency>
    >             ```
    >             
    >         2. 在客户端主程序上，添加```@EnableFeignClients```注解来启用Feign
    >         
    >         3. 在需要远程调用的方法，所在的类中，添加一个自定义的Feign接口。Feign接口命名规则为```XxxFeign xxxFeign;```，例如```MovieServiceFeign movieServiceFeign```，以便于区分是远程接口还是本地接口。并且对Feign接口开启自动装配。
    >         
    >             ```
    >             @Autowired
    >             MovieServiceFegin movieServiceFeign;
    >             ```
    >             
    >             * 当我们调用这个Feign接口时，框架会帮我们生成Feign接口的代理对象，通过代理对象进行远程调用。框架通过JDK的动态代理来创建代理对象
    >             
    >         4. 编写Feign接口。在Feign接口上，添加```@FeignFeClient()```注解，注解的value指定调用哪一个服务，服务名称必须与注册中心中的Application一致。接口中，定义要调用远程服务的那些接口
    >         
    >             ```
    >             @FeignClient("CLOUD-PROVIDER-MOVIE")
    >             public interface MovieServiceFeign {
    >             
    >                 @GetMapping("/getMovieById/{id}")
    >                 public Movie getMovieById(@PathVariable("id") Integer id);
    >                 
    >             }
    >             ```
    >             
    >         5. 使用Feign接口，调用里面的方法。代理对象就会帮助去调用远程对象。
    >         
    >         6. Feign默认和Ribbon集成，使用Feign远程调用默认自动进行负载均衡。
    >     
    > 2. **注意：服务端的Controller中的方法中，方法参数最好都加上```@RequestParam("")```注解，用来确保远程调用时不出现错误**
    >    
    > 3. **注意：简单参数的远程接口传递，使用```@RequestParam()```、```@PathVariable()```注解；复杂的对象作为参数，使用```@RequestBody```修饰**     
## 5. Hystrix熔断服务
5. Hystrix熔断服务
    > 1. 假设提供服务的服务器集群全部宕机，会怎样
    >
    >    服务器刚刚全部宕机：返回连接超时的错误页面
    >    
    >    服务器宕机一阵子：返回负载均衡没有可轮询的服务器的错误页面
    >    
    > 2. 我们不可以让用户看见这些错误页面，要返回一些默认数据，提示错误信息。这就涉及到了熔断服务
    >
    > 3. Hystrix熔断服务
    >
    >     1. 引入熔断服务的依赖
    >     
    >         ```
    >         <!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-netflix-hystrix -->
    >         <dependency>
    >             <groupId>org.springframework.cloud</groupId>
    >             <artifactId>spring-cloud-starter-netflix-hystrix</artifactId>
    >             <version>2.2.6.RELEASE</version>
    >         </dependency>
    >         ```
    >         
    >     2. 在客户端主程序上，添加```@EnableCircuitBreaker```注解，启用熔断器
    >     
    >     3. 在application.yml文件中，开启Feign对Hystrix的支持
    >     
    >         ```
    >         feign:
    >           circuitbreaker:
    >             enabled: true
    >         ```
    >         
    >     4. 在客户端定义的Feign接口上的```@FeignClient()```注解中，添加。value为远程服务名，fallback为自定义异常处理类的class字节码
    >     
    >         ```
    >         @FeignClient(value = "cloud", fallback = MovieServiceExceptionHandler.class)
    >         public interface MovieServiceFeign {
    >         
    >         	@GetMapping("/getMovieById/{id}")
    >             public Movie getMovieById(@PathVariable("id") Integer id);
    >             
    >         }
    >         ```
    >         
    >     5. 定义异常处理类，异常处理类必须实现Feign接口。异常处理类中，重写的Feign接口的方法，方法返回值就为熔断后，返回的虚假数据。异常处理类要加上```@Component```注解交给SpringBoot管理
    >     
    >         ```
    >         @Component
    >         public class MovieServiceExceptionHandler implements MovieServiceFeign {
    >         	@Override
    >             public Movie getMovieById(@PathVariable("id") Integer id) {
    >             
    >             	Movie movie = new Movie();
    >             	movie.setId(-100);
    >             	movie.setName("无电影");
    >             	
    >             	return movie;
    >             	
    >             };
    >         }
    >         ```
    >         
    >     6. 在需要远程调用的方法中，如果远程调用调不通，则调用异常处理类中的熔断方法返回假数据
    >     
    > 4. 熔断器的监控：Hystrix提供实时监控，会累记所有请求成功和失败的记录
    >
    >     1. 引入actuator模块：actuator是SpringBoot提供，用来监控SpringBoot服务状态的
    >         ```
    >         <!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-actuator -->
    >         <dependency>
    >         	<groupId>org.springframework.boot</groupId>
    >         	<artifactId>spring-boot-starter-actuator</artifactId>
    >         	<version>2.4.2</version>
    >         </dependency>
    >         ```
    >         
    >         * 引入actuator模块后，可以通过服务的ip、端口下，以/actuator上下文路径，下面有很多路径可以监控各种状态。详情参见文档。
    >         
    >     2. 修改application.yml文件，暴露数据监控流
    >     
    >         ```
    >         management:
    >           endpoints:
    >             web:
    >               exposure:
    >                 include: hystrix.stream # 访问/actuator/hystrix.stream可以看到不断更新的监控流      
    >         ```
    >         
    >     3. 引入HystrixDashboard
    >     
    >         ```
    >         <!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-netflix-hystrix-dashboard -->
    >         <dependency>
    >         	<groupId>org.springframework.cloud</groupId>
    >         	<artifactId>spring-cloud-starter-netflix-hystrix-dashboard</artifactId>
    >         	version>2.2.6.RELEASE</version>
    >         </dependency>
    >         ```
    >         
    >     4. 配置文件中还要指定proxy-stream-allow-list
    >     
    >         ```
    >         hystrix:
    >           dashboard:
    >             proxy-stream-allow-list: localhost
    >         ```
    >     
    >     5. 在客户端主程序上，添加```@EnableHystrixDashboard```，开启熔断器监控
    >     
    >     6. 通过服务的ip、端口，/actuator上下文下，通过hystrix.stream路径（例如```http://localhost:8000/hystrix```）。将```http://localhost:8000/actuator/hystrix.stream```输入，点击monitor按钮即可监控
    >     
# 12. SpringSession
12. SpringSession
    > 1. 简介
    >
    >    SpringSession用于解决分布式情况下，Session一致性的问题
    >    
    >    它会对原生Session进行包装，之后使用的Session就是包装后的Session。包装后的Session使用get、set方法，都是在缓存中进行操作
    >    
    > 2. SpringSession使用
    >
    >     1. 确定引入了Redis的依赖
    >     
    >     2. 引入SpringSession的依赖
    >     
    >         ```
    >         <dependency>
    >             <groupId>org.springframework.session</groupId>
    >             <artifactId>spring-session-data-redis</artifactId>
    >         </dependency>
    >         ```
    >         
    >     3. 在application.properties中编写配置
    >     
    >        ```
    >        spring.redis.host=192.168.20.128
    >        spring.redis.jedis.pool.max-idle=100
    >        spring.session.store-type=redis
    >        # 设置缓存中的session数据过期时间
    >        spring.session.timeout=1800
    >        ```
    >        
# 13. Thymeleaf
13. Thymeleaf
    > 1. SpringBoot提供了大量的模板引擎，但是最推荐使用Thymeleaf模板引擎。因为Thymeleaf提供了完美的SpringMVC支持。
    >
    > 2. Thymeleaf简介
    >
    >    Thymeleaf是一个java类库，它是一个xml/xhtml/html5的模板引擎，可以作为MVC应用的view层
    >    
    >    我们可以使用Thymeleaf完全取代jsp
    >    
    >    SpringBoot通过自带的配置类，对Thymeleaf进行自动配置。通过ThymeleafAutoConfiguration类对集成所需要的bean进行自动配置，包括templateResolver，templateEngine，thymeleafViewResolver的配置
    >    
    >    Thymeleaf页面可以直接被浏览器解析，此时页面中的Thymeleaf标签都不会被解析
    >    
    > 3. Thymeleaf简单使用
    >
    >     1. 创建SpringBoot项目，引入Web, Thymeleaf, Eureka Discovery, reids, Session, Feign, Hystrix Dashboard几个模块
    >     
    >     2. 继承自己的父工程
    >     
    >     3. 配置文件：前端项目，没有Druid配置，其他都有，还多了一个Thymeleaf的配置。Thymeleaf配置如下：
    >     
    >         ```
    >         thymeleaf:
    >           prefix: classpath:/templates/
    >           suffix: .html
    >           cache: false # 开发环境禁用缓存
    >         ```
    >         
    >     4. 书写controller层代码
    >     
    >     5. 书写视图
    >     
    > 4. Thymeleaf页面
    >
    >     1. 页面后缀为html
    >     
    >     2. 页面中引入Thymeleaf标签
    >     
    >         ```
    >         <!DOCTYPE html>
    >         <html lang="zh-CN" xmln:th="http://www.thymeleaf.org">
    >         <head>
    >             <meta charset="UTF-8">
    >             <title>Title</title>
    >         </head>
    >         <body>
    >         
    >         </body>
    >         </html>
    >         ```
    >         
    >     3. 使用Thymeleaf标签
    >     
    > 5. Thymeleaf常用标签
    >
    >     1. ```th:text=""```
    >     
    >        用在div、span等标签上，改变标签体中内容为引号内的内容。如果引号中没有内容，则替换标签体中为空
    >        
    >     2. ```th:任意html中属性```
    >     
    >        用来替换标签中的原生属性。例如```<a href="" th:href=""></a>```，可以替换a标签的href属性
    >        
    >     3. ```th:each="变量名:迭代的数组或集合"```
    >     
    >        用在标签上，用来迭代域中的数组或者集合。它会进行不断的迭代，每次迭代都会迭代标签，同时将迭代的数据放入变量中。
    >        
    >        如果我们想把迭代后的数据放入标签体中，我们可以配合使用```th:text="${变量名}"```即可。或者在标签体中，使用OGNL表达式的可解析方式。
    >        
    >    4. 引入静态资源
    >    
    >       我们可以对link标签、script标签等，使用```th:原生属性="@{路径}"```的方式来引入文件。
    >       
    >       ```@{}```也是OGNL表达式的一种，它有个好处，就是如果路径以```/```开头，可以自动添加应用程序上下文在路径前。
    >    
    > 6. OGNL表达式
    >
    >     1. 介绍
    >     
    >        和Thymeleaf标签配合使用，使用在Thymeleaf标签的引号中，可以直接解析
    >        
    >        和EL表达式类似
    >        
    >        html标签的原生属性的属性值，不支持OGNL表达式
    >        
    >     2. 部分简单使用
    >     
    >         1. 获取request域中数据：```${键名}```。OGNL表达式不同于EL表达式，请求域中数据直接写键名即可。```${}```中可以写简单的表达式。
    >         
    >         2. 获取Session域中数据：```${session.键名}```
    >         
    >         3. 如果想直接使用OGNL表达式是不行的，解析器不会解析。我们可以使用```[[${xxx}]]```的方式，将OGNL表达式写在两个方括号中，则会解析表达式
    >         
    >     3. **更多具体使用，参见Thymeleaf官方文档**
    >     
    > 7. 引入公共页面
    >
    >     1. 创建公共html页面
    >     
    >     2. 使用div标签，将公共的标签片段放入div标签中
    >     
    >     3. 在div标签上，使用```th:fragement="自定义一个片段名"```来标记该div标签
    >     
    >     4. 在其他页面需要引入公共标签片段的地方，引入公共代码块，常见的有三种
    >     
    >         1. 使用div标签做包含
    >         
    >            在div上使用```th:include="~{include/include::自定义的片段名}"``` 来引入。将公共页面div中的代码片段引入到这个div中
    >            
    >            ```include/include```可以理解成视图解析的过程，根据配置的Thymeleaf的prefix和suffix来找到```include/include```对应的公共页面；
    >            
    >            ```::自定义的片段名```就是公共页面中，公共标签片段所在div上的```thfragement="自定义一个片段名"```
    >            
    >         2. 使用div标签替换
    >         
    >            在div上使用```th:replace="~{include/include::自定义的片段名}"```来替换。即将公共页面的div和标签片段都拿来，替换这个div
    >            
    >         3. 使用div标签插入
    >         
    >            在div上使用```th:insert="~{include/include::自定义的片段名}"```。即将公共页面的div和标签片段，插入该div中
    >     
    > 8. **更多Thymeleaf相关知识点，参考文档**
    >    
    > 9. 优先级排序：```th:if```大于```th:each```大于```th:原生属性```
    > 
    > 10. OGNL表达式中，不同作用的表达式可以配合使用，例如```@{xx/xx/xx/${xx.Xx}}```
    > 
    > 11. Thymeleaf标签中，字符串和```${xx.Xxx}```取出的值拼接：1，可以用+拼接，```'ABC-' + ${xx.Xxx}```；2，可以使用||拼接，```|ABC-${xx.Xxx}|```
    >     
## 1. WebMvcConfigurer接口
1. WebMvcConfigurer接口
    > 1. 介绍
    > 
    >    用来定制SpringMVC中的一些细节功能
    >    
    > 2. 使用
    > 
    >     1. 自定义一个类，实现WebMVCConfigurer接口
    >     
    >     2. 使用```@Component```注解，把该类交给SpringBoot管理
    >     
    > 3. WebMvcConfigurer接口中的部分方法
    > 
    >     1. addInteceptors(InteceptorRegistry registry)
    >     
    >        用来配置拦截器
    >        
    >     2. addViewController(ViewControllerRegistry registry)
    >     
    >        用来配置一些只做页面跳转的url。例如一个/index请求只是要跳转到index.html页面
    >        
    >        如何使用：```registry.addViewController("url").setViewName("视图名称")```
    >        
# 14. SVN
14. SVN
    > 1. 介绍
    >
    >    集中式版本控制工具
    >    
    > 2. 好处
    >
    >    1、备份项目；2、代码还原；3、协同修改；4、多版本项目文件管理；5、追溯问题代码的编写人和编写时间；6、权限控制
    >
    > 3. SVN架构
    >
    >    SVN架构分为两部分，一个SVN仓库，多个用户的电脑。
    >
    >    项目最初会被项目经理等高级人员**检入(checkin)**SVN仓库，开发人员**下载(upload)**项目修改，**提交(commit)**修改后的项目，反复多次后，最终由高级人员**检出(checkout)**成品项目放入开发环境。
    >
    > 4. 安装SVN和使用
    >
    >     1. 点击直接安装。最后在cmd中输入```svn --version```可以看到版本号即可。
    >
    >     2. 准备一个目录，作为SVN根仓库。根仓库中，一般会有如下几个仓库目录：BI(存放经营分析系统)、CRM(存放客户关系管理系统)、OA(存放自动化办公系统)。我们不同功能的项目放入不同的仓库中。
    >
    >     3. 初始化具体的仓库。在cmd中输入命令：```svnadmin create 仓库绝对路径```
    >         * 初始化仓库后，具体的仓库目录中会自动创建如下几个目录：conf(存放版本库所使用的配置文件的目录)、db(存放存储版本数据的数据库文件的目录)、hooks(存放版本库钩子程序的目录)、locks(存储库锁目录，用来跟踪库的访问者)、format文件(存储一个整数的文件，此整数代表库层次版本结构)、README文件(版本库自述文件)
    >         
    >         * 钩子程序：不需要调用，会自动触发的程序
    >         
    >     4. 启动SVN服务端：使用命令```svnserve -d -r 根仓库绝对路径```。-d表示后台执行；-r表示版本库根目录
    >        
    >         * SVN服务端，默认监听3690端口。可以在cmd中输入```netstat -an```来查看3690端口是否被监听
    >         	
    >         * SVN命令行启动后，不能关闭命令行窗口。因此我们可以注册SVN服务为Windows服务达到后台运行并且自启动的目的。
    >         
    >         * 在cmd中使用Windows的命令：```sc create 自定义服务名称 binpath= "svnserve.exe的绝对路径 --service -r 仓库绝对路径" start=auto depend=Tcpip```。**注意：该命令必须具有管理员权限**
    >     
    > 5. SVN权限
    > 
    >    SVN的每一个仓库，都需要在配置文件中开放一系列权限才能被外界使用。
    >    
    >    在conf/svnserve.conf中，开放anon-access=write，即开放匿名写权限
    >    
    > 6. SVN客户端工具：TortoiseSVN
    > 
    >     1. 安装
    >     
    >     2. 空白位置可以直接使用
    >     
    > 7. SVN冲突
    > 
    >    当多个用户同时操作同一个文件时，就会产生冲突
    >    
    >    如何解决冲突？右键冲突文件，解决冲突后，保存，**然后标记冲突已经解决**。
    >    
    >    之后就可以顺利提交了
    >    
# 15. Nginx
15. Nginx
    > 1. Nginx简介
    >
    >     1. 介绍
    >     
    >        Nginx是一个高性能的Http和反向代理服务器。特点是占用内存小，并发能力强
    >        
    >     
    >     2， Nginx和Tomcat关系
    >     
    >        Nginx可以作为静态页面web服务器，同时还支持CGI协议的动态语言，例如perl、php，但是不支持Java
    >     
    >        Java只能与Tomcat配合使用，因此Java开发Tomcat和Nginx是合作关系
    >     
    >        Nginx和Apache服务器是竞争关系
    >     
    >     3. Nginx三大功能
    >     
    >         * 反向代理
    >         
    >            区别于正向代理，正向代理代理客户端，多个客户端可以通过正向代理服务器访问服务端；反向代理代理服务器端，客户端访问了代理服务器，代理服务器决定让其访问哪个服务端
    >            
    >            反向代理的好处：1、服务器端真实ip和端口不会直接暴露，更加安全；2、服务器端集群，但是不会让客户端感知到
    >            
    >         * 负载均衡
    >         
    >            因为反向代理了多台服务器端，因此就可以对多台服务器端进行负载均衡
    >            
    >         * 动静分离
    >         
    >           动态资源和静态资源分离，静态资源放在文件系统服务器，动态资源放在Tomcat服务器上，通过Nginx统一代理
    >    
    > 2. Nginx安装
    >
    >    Linux上软件有四种安装方式：rpm安装、yum安装、直接解压然后配置环境变量、解压后编译安装
    >    
    >    Nginx在Linux上安装，是第四种解压后编译安装
    >    
    >    Nginx有四个压缩包，它们彼此之间有依赖关系，需要严格按照顺序解压编译安装：pcre-8.37.tar.gz、openssl-1.0.1.t.tar.gz、zlib-1.2.8.tar.gz、nginx-1.11.1.tar.gz
    >    
    >    Linux下，软件默认安装到/usr/local/下；我们进入/usr/local中可以看到nginx的目录。在nginx目录下的sbin目录中，有nginx启动文件，因为此时启动文件不在六个Linux的bin/sbin目录下，因此要用./nignx来启动启动文件；启动后，使用ps命令可以看到nginx的worker进程和master进程被启动，worker进程用来执行nginx工作，master进程用来管理worker进程
    >    
    >    Linux下，在/usr/locl/nginx/sbin目录下，使用./nginx启动nginx；使用./nginx -s stop停止nginx；使用./nginx -s reload重新加载nginx
    >    
    >     * gcre编译安装过程：解压缩；进入解压后目录，执行./configure，如果提示要c++编译环境，就先去安装c++编译环境，然后执行./configure；回到pcre目录下，执行make进行编译，然后执行make install进行安装
    >     * openssl编译安装：解压缩；进入解压后目录，执行./config；make进行编译，执行make install进行安装，编译安装两个命令可以合起来make && make install
    >     * zlib编译安装：解压缩；进入解压后目录，执行./configure；make && make install
    >     * nginx编译安装：解压缩；进入解压后目录，执行./configure；make && make install
    >    
    > 3. Nginx例子
    >
    >     * 搭建Nginx的反向代理负载均衡小例子：
    >     
    >        先在本地启动几个Tomcat服务，保证端口号不同
    >
    >        在虚拟机下，去/usr/local/nginx/conf下，配置nginx.conf文件来新增反向代理和负载均衡：
    >
    >        配置完成后，在/usr/local/nginx/sbin下，使用./nginx -s reload命令重新加载nginx
    >
    >         ```
    >     http{
    >     ...
    >         upstream myTestServer{
    >         	ip hash;
    >         	server 192.168.20.1:8010 weight=1;
    >         	server 192.168.20.1:8020 weight=1;
    >         }
    >     ...
    >         server{
    >         	location{
    >         		...
    >         		proxy_pass http://myTestServer;
    >         		proxy_connect_timeout 10;
    >         	}
    >         	...
    >         }
    >     ...
    >     }
    >         ```
    >        
    >     * 结合Redis配置负载均衡：
    >
    > 4. Nginx原理和配置
    >    
    >     1. Nginx原理
    >     
    >         1. Mster-Worker机制
    >         
    >            Nginx中，Master进程会管理和监控所有的Worker进程，想要有几个Worker进程可以在配置文件中配置。Worker进程是真正干活的，它管理所有的Tomcat。
    >         
    >            当新的Client请求访问Nginx，Master会通知所有的Worker，Worker会抢占该Client。Worker抢到后，如果是静态资源请求，会直接调用文件系统中静态资源返回给Client；如果是动态请求，Worker会将请求发给Tomcat服务器处理
    >         
    >          2. Master-Worker机制的好处
    >     
    >             1、对于每个Worker来说，都是独立的进程，不需要加锁，节省了锁带来的开销，同时在排查问题时也会很方便；
    >         
    >             2、采用独立的进程，可以让不同服务之间不会影响，一个进程退出后，其他进程还在工作，服务不会中断，Master会很快启动新的Worker进程。如果一个Worker因为异常停止工作，该Worker的请求会失败，但是不会影响到其他Worker上的请求
    >         
    >             3、可以进行热加载，如果一个Worker上有任务，其他Worker会先重新加载，有任务的Worker任务完成后，对其单独进行一次加载
    >         
    >          3. Nginx中Worker数量设置：
    >     
    >             Nginx中Worker数量和服务器CPU保持一致，因为**Nginx和Redis一样使用了IO多路复用技术**，每个独立的Worker都是一个独立的进程，但每个进程中只有一个主线程，通过异步非阻塞方式来处理请求，每个Worker会把CPU的性能发挥到极致。
    >         
    >             因此Worker数和CPU数一致最好，不会浪费CPU，也不会因CPU频繁切换导致资源浪费。
    >         
    >          4. Nginx中一次请求会占用Worker的几个连接数？（面试常考）
    >     
    >             会占用2个或4个，如果访问静态资源，一来一回2个；如果访问动态资源，连接Worker1个，Worker发送给Tomcat1个，Tomcat返回给Worker1个，Worker返回给用户1个，总共4个。
    >         
    >             但是一般会这么问：假设一个Nginx中有n个Worker，每个Worker有m个连接，问最大的并发量是多少。```最大并发量=n*m/4```或```最大并发量=n*m/2```
    >         
    >      2. Nginx配置：详细版配置的解读。详细版不允许替换原有Nginx配置，因为详细配置中有一些是冲突的
    >     
    >          ```
    >          # 安全权限问题，建议使用nobody，不要使用root
    >          # user nobody;
    >          
    >          # worker数量，和服务器CPU数量一致最为合适，以4个为例
    >          worker_process 4;
    >          
    >          # Worker绑定CPU，以4个为例
    >          worker_cpu_affinity 0001 0010 0100 1000;
    >          
    >          # error_log path(存储路径) level(日志级别，有debug|info|notice|warn|error|crit，从左往右详细程度递减，默认为crit)
    >          # error_log logs/error.log notice
    >          # error_log logs/error.log info
    >          
    >          # 进程id的存储位置
    >          # pid       logs/nginx.pid
    >          
    >          # nginx事件模块
    >          events {
    >          	
    >          	# 每个Worker的最大连接数
    >          	worker_connections 1024;
    >          	
    >          	# 使用多路IO复用
    >          	user epoll;
    >          	
    >          	# 当一个Worker抢占到一个连接后，是否可以让其获取更多的连接，默认是off。访问人数多，开启；访问人数少，关闭
    >          	muti_accept on;
    >          	
    >          	# 开启Nginx的抢占锁机制，默认是on。访问人数少，开启抢占锁，资源分配合理；访问人数多，关闭抢占锁，资源最大化利用
    >          	accept_mutex on;
    >          }
    >          
    >          # http模块
    >          http {
    >          	
    >          	# 当收到静态资源请求时，根据MIME类型来判断是否能够让Worker自己处理这些请求。引入可以自己处理的静态资源的MIME类型列表
    >          	include mime.types;
    >          	
    >          	# 如果无法通过引入的MIME列表找到对应的映射，使用以下默认值
    >          	default_type application/octet-stream;
    >          	
    >          	# 访问日志位置
    >          	access_log logs/host.access.log main;
    >          	
    >          	# 日志中的主要变量，运维需要了解的
    >          	log_format main xxx;
    >          	
    >          	# 开启直接从磁盘到网络的文件传输，适用于有大型文件进行传输的情况下，提高IO效率
    >          	sendfile on;
    >          	
    >          	# 超时时间设置
    >          	keepalive_timeout 65;
    >          	
    >          	# 开启或者关闭gzip模块。压缩文件模块
    >          	# gzip on;
    >          	
    >          	# 设置允许压缩的最小字节数
    >          	# gzip_min_length 1k;
    >          	
    >          	# 设置gzip压缩比，从1到9，压缩比小速度快；压缩比大处理起来慢
    >          	# gzip_comp_level 4;
    >          	
    >          	# 匹配MIME类型进行压缩。无论是否制定，text/html一定会压缩的。一般制定文本系列等类型，图片、视频等压缩后效果不大
    >          	# gzip_types types text/plain text/css application/json ...;
    >          	
    >          	# 动静分离。
    >          	# 服务器的静态资源缓存，最大缓存到内存中的文件，不活跃期限
    >          	open_file_cache max=655350 inactive=20s;
    >          	
    >          	# 活跃期间内最少使用次数，否则视为不活跃
    >          	open_file_cache_min_uses 2;
    >          	
    >          	# 验证缓存内资源是否活跃的时间间隔
    >          	open_file_cache_valid 30s;
    >          	
    >          	# 反向代理，负载均衡。重点
    >          	upstream myTestServer{
    >          		
    >          		# 1、轮询（默认）
    >              	# 每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。
    >              	
    >              	# 2、指定权重
    >             	    # 指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。
    >             	    
    >             	    # 3、IP绑定 ip_hash
    >              	# 每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。
    >              	
    >              	# 4、备机方式 backup
    >              	# 正常情况不访问设定为backup的备机，只有当所有非备机全都宕机的情况下，服务才会进备机。在server xxx.xx.xx:xxx weight=xx后添加backup就标记该服务器为备机
    >              	
    >              	# 5、fair（第三方）
    >              	# 按后端服务器的响应时间来分配请求，响应时间短的优先分配。
    >                  
    >              	# 6、url_hash（第三方）
    >              	# 按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。
    >          
    >          
    >                ip_hash;
    >                server 192.168.161.132:8080 weight=1;
    >                server 192.168.161.132:8081 weight=1;
    >                
    >                #fair
    >          
    >                #hash $request_uri
    >                #hash_method crc32
    >          		
    >          	}
    >          	
    >          	# 该Nginx服务器的设置
    >          	server {
    >          	
    >          		 #监听端口号
    >                   listen       80;
    >          
    >                   #服务名
    >                   server_name  192.168.20.128;
    >          
    >                   #字符集
    >                   #charset utf-8;
    >          
    >          
    >          
    >          		# 非常非常重要
    >          	    #location [=|~|~*|^~] /uri/ { … }   
    >          	    # = 精确匹配
    >          		# ~ 正则匹配，区分大小写
    >          		# ~* 正则匹配，不区分大小写
    >          		# ^~  关闭正则匹配
    >          	
    >          		#匹配原则：
    >          	 
    >          		# 1、所有匹配分两个阶段，第一个叫普通匹配，第二个叫正则匹配。
    >          		# 2、普通匹配，首先通过“=”来匹配完全精确的location
    >                  #   2.1、 如果没有精确匹配到， 那么按照最大前缀匹配的原则，来匹配location
    >                  #   2.2、 如果匹配到的location有^~,则以此location为匹配最终结果，如果没有那么会把匹配的结果暂存，继续进行正则匹配。
    >                  # 3、正则匹配，依次从上到下匹配前缀是~或~*的location, 一旦匹配成功一次，则立刻以此location为准，不再向下继续进行正则匹配。
    >                  # 4、如果正则匹配都不成功，则继续使用之前暂存的普通匹配成功的location.
    >          		
    >          		location / {   # 匹配任何查询，因为所有请求都已 / 开头。但是正则表达式规则和长的块规则将被优先和查询匹配。
    >          		
    >          	   	    #定义服务器的默认网站根目录位置。这里前面没有/，说明是Linux下的相对路径，相对于Nginx的安装目录/usr/local/nginx。
    >          	   	    # root有一个规则，就是location匹配的目录，必须拼接到root后目录的后边，例如location /test/ { root html;}，必须保证/usr/local/nginx/html/test/存在
    >                      root   html;
    >                      
    >          	    	#默认访问首页索引文件的名称
    >          	    	index  index.html index.htm;
    >          
    >          	   	    #反向代理路径
    >                      proxy_pass http://myTestServer;
    >          
    >          	    	#反向代理的超时时间
    >                      proxy_connect_timeout 10;
    >          
    >                      proxy_redirect default;       
    >          
    >                   }
    >          
    >                   location  /images/ {    
    >          	   		 root images ;
    >          		 }
    >          
    >          	 	 location ^~ /images/jpg/ {  # 匹配任何已 /images/jpg/ 开头的任何查询并且停止搜索。任何正则表达式将不会被测试。 
    >          	   	 	root images/jpg/ ;
    >          		 }
    >          		 
    >                   location ~*.(gif|jpg|jpeg)$ { 
    >          	      	 #所有静态文件直接读取硬盘
    >                       root pic ;
    >          	      
    >          	     	 #expires定义用户浏览器缓存的时间为3天，如果静态页面不常更新，可以设置更长，这样可以节省带宽和缓解服务器的压力。缓存的地方，在用户的电脑中
    >                       expires 3d; #缓存3天
    >                   }
    >          
    >          
    >                  #error_page  404              /404.html;
    >          
    >                  # redirect server error pages to the static page /50x.html
    >                  #
    >                  error_page   500 502 503 504  /50x.html;
    >                  location = /50x.html {
    >                      root   html;
    >                  }	
    >          
    >          	}
    >          	
    >          }
    >          ```
    >          
# 16. Git
16. Git
    > 1. Git简介和安装
    >
    >     1. Git简介
    >     
    >        Git是目前世界上最先进的分布式版本控制工具
    >        
    >     2. 集中式版本控制系统的缺陷：
    >     
    >        1、版本管理的服务器一旦崩溃，硬盘损坏，代码如何恢复？
    >        
    >        2、集中式版本控制要求程序员上传的代码必须是完整版本的，但是如果要对开发中做小版本管理，以便追溯查询，怎么办？
    >        
    >        3、系统正在上线运行，时不时要修改bug，要增加好几个功能要几个月，如何管理几个版本？
    >        
    >        4、如何管理一个分步在世界各地的、互不认识的大型团队？
    >        
    >     3. Git安装
    >     
    >        安装Git命令行工具。
    >        
    >        安装完后，任意位置单击右键，选择Git Bash打开Git命令行，使用git命令来设置配置，设置使用git的用户名和用户邮箱：```git config --global user.name "用户名"```、```git config --global user.email "邮箱地址"```
    >        
    >         * git的信息都保存在C:/用户/zsy/.gitconfig中
    >     
    > 2. Git实战
    >
    >     1. 打开Git Bash命令行
    >     
    >     2. 进入项目所在的目录：```cd /d/IDEAHome/test```
    >     
    >     3. 初始化，创建版本库：```git init```，项目所在目录此刻就被Git管理起来了，项目目录下会多出一个.git目录，.git目录就是该项目的本地仓库，存储了项目的所有版本
    >     
    >     4. 提交文件：
    >     
    >         1. 将文件添加到暂存区：```git add 文件名```。如果确定该目录下的文件全部都是要提交的，可以使用```git add *```暂存所有文件。一般配置文件等都是不能提交的，因此不建议使用暂存所有文件的写法
    >         
    >         2. 提交文件到本地库：```git commit```，输入该命令后，会进入vim编辑器中，要填写注释。注释写完后，使用```:wq```保存退出，暂存区的文件都被提交了。
    >         
    >             * 可以使用```git commit -m "注释的内容"```，不用进入vim就可以写注释然后直接提交
    >         
    >     5. 查看文件提交记录：```git log 文件名```，查看历史记录；```git log --pretty=oneline 文件名```，简易信息查看
    >     
    >     6. 版本回退：```git reset --hard HEAD^```，回退一个版本；```git reset --hard HEAD~n```，回退n个版本
    >     
    >     7. 版本穿越：先查看历史记录的版本号，```git reflog 文件名```；执行```git reset --hard 版本号```，穿越到版本号为xxx的版本
    >     
    >     8. 还原文件：```git checkout -- 文件名```，将本地的文件还原为库中的文件
    >     
    >     9. 删除文件：```rm -rf 文件名```，先将本地文件删除；```git add 文件名```，删除图片；```git commit -m "删除图片"```，删除成功。注意，Git操作都可以通过版本穿越将文件复原，因此提交的文件一定要慎重
    >     
    > 3. Git的工作区、暂存区、本地库
    >
    >    工作区就是本地硬盘目录
    >    
    >    暂存区就是.git目录下，index文件。因此暂存区也叫作索引
    >    
    >    本地库就是.git目录，它是Git的本地版本库
    >    
    > 4. Git分支
    >
    >     1. 介绍
    >     
    >        假如一个项目已经上线，但是又有新的需求，因此需要一边对上线版本进行修改，一边又要对版本进行需求添加，如何管理几个版本？这就需要分支了。
    >        
    >        Git的Master分支和多个其他分支互不影响，例如主分支用来运行产品，一个分支用来修改bug，改完后和主分支合流；一个分支用来添加功能，添加完后和分支合流
    >        
    >     2. 分支的操作
    >     
    >         * 如何创建分支：```git branch 分支名 ```
    >         
    >         * 查看分支：```git branch -v```
    >         
    >         * 切换分支：```git checkout 分支名```。创建分支最好的方式```git checkout -b 分支名```可以直接创建分支并进入分支。
    >         
    >         * 合并分支：先切换到主分支```git checkout master```；合并分支```get merge 待合并分支名```
    >         
    >         * 删除分支：先切换到主分支```git checkout master```；删除分支```git branch -D 分支名```
    >         
    >     3. 合并分支的冲突和解决冲突
    >     
    >         1. 冲突：
    >         
    >            如果master在修改一个地方，另一个分支也在修改同样的地方，合并分支时就会冲突。，提示CONFILICT关键字，并且命令行后缀变为master|MERGING状态
    >            
    >         2. 解决
    >         
    >             1. 定位冲突位置```git diff```
    >             
    >             2. vim修改文件中冲突位置，保存文件
    >             
    >             3. 再次提交文件```git add 文件```、```git commit -m "冲突解决"```
    >     
    > 5. GitHub简介和实操
    >
    >     1. 注册Github
    >     
    >     2. 增加远程地址：```git remote add 远端代号 远端地址```，远端代号是指远程连接代号，一般origin作为代号，也可以自定义；远端地址指的是默认远程连接的url
    >     
    >     3. 推送项目到远程库：```git push 远端代号 本地分支名称```
    >     
    >     4. 将项目从远程库拷贝到本地：```git clone 远端项目url 新目录名```，这样Git就会自动在当前目录下创建新目录然后将远端项目放进去
    >     
    >     5. 进入项目目录，配置git config：```git config user.name "用户名"```，```git config user.email "用户邮箱"```
    >     
    >     6. 本地开发后，重新推送项目到远程库：```git push 远端代号 本地分支名称```
    >     
    >         * 注意：如果直接推送会报错告诉没有权限。我们要去GitHub上设置权限。我们要添加项目合作伙伴，发送项目合作邀请，接受了邀请才能推送项目。
    >         
    >     7. 获取GitHub更新了的项目：```git pull 远程代号 远端分支名 ```
    >     
    >     8. 如果有多个人同时推送项目，并且修改的是同一段的代码，在下一次更新项目后，就会出现冲突。需要手动解决冲突，然后重新推送项目
    >     
    > 6. SSH
    >
    >     1. 介绍
    >     
    >        由于每次提交都需要输入用户名和密码，很麻烦，因此我们可以使用SSH
    >        
    >     2. 使用
    >     
    >         1. 查看是否之前有ssh密钥生成：在git bash中，输入```cd ~/.ssh```查看是否有该文件夹，有则删除。
    >         
    >         2. 生成GitHub账户的SSH密钥，SSH密钥生成后分为公钥和私钥，存储在~/.ssh中：在git bash中输入```ssh-keygen -t rsa -C GitHub账号名```
    >         
    >         3. 将公钥复制，粘贴到GitHub账户全局设置中的SSH中
    >         
    >         4. 将项目的SSH连接复制，然后建立新的SSH连接远程代号：```git remote add originssh ssh连接```
    >         
    >         5. 之后使用ssh连接的远程代号来提交
    >
    > 7. Git工作流
    >
    >     1. 介绍
    >     
    >        简单来说，就是一个项目组中的成员在工作中统一使用Git的方式
    >        
    >        有两种：集中式工作流、GitFlow工作流
    >        
    >        集中式工作流，直接使用SVN会更好。这里主要指的是GitFlow工作流
    >        
    >     2. GitFlow工作流
    >     
    >         1. 介绍
    >         
    >            Gitflow工作流通过为功能开发、发布准备和维护设立了独立的分支，让发布迭代更加顺畅。
    >            
    >         2. GitFlow工作流分支具体见视频
    >         
    >    3. 分支实战
    >




