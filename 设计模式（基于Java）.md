# 设计模式（DP，DesignPattern）

## 1. 设计模式的七大原则
1. 设计模式的七大原则

   > 1. 使用设计模式设计的目的
   >
   >    1、可重用性高（相同功能的代码不用重复写）；
   >
   >    2、可读性高（编程规范性高）；
   >
   >    3、可扩展性高（需要增加新功能时方便，也叫作可维护性）；
   >
   >    4、可靠性高（当增加新功能后，对原有功能无影响）
   >
   >    最终使得程序高内聚，低耦合
   >
   > 2. 设计模式七大原则：就是程序员在编程时必须遵守的原则，是设计模式的基础。具体参见D:/编程学习用书/设计模式/图解设计模式.docx
   >
   >     * 单一职责原则：
   >     
   >       1. 介绍
   >     
   >          一个类只负责一个职责
   >     
   >     * 接口隔离原则：
   >     
   >       1. 介绍
   >     
   >          类对其他类的依赖，建立在依赖最小的接口上
   >     
   >     * 依赖倒转原则：
   >     
   >       1. 介绍
   >     
   >          面向接口编程；以抽象来搭建整体架构，比用具体进行架构更加稳定
   >          
   >       2. 依赖传递的3种方式
   >       
   >           1. 接口传递：接口A依赖了其他接口B，实现类通过实现接口A，传递依赖了B
   >           
   >           2. 构造方法传递：如果类中有成员变量B，通过构造器注入B，则类传递依赖B
   >           
   >           3. setter方法传递：如果类有成员变量B，通过某个方法注入B，则类传递依赖B  
   >           
   >       3. 依赖倒转原则的注意事项
   >       
   >           1. 底层的类，尽量有抽象类的父类或者自身实现了接口，这样程序稳定性更好。即类不要孤零零的单独存在
   >           
   >           2. 参数、变量的声明类型，尽量为接口或者抽象类，这样我们变量引用和实际完成工作的对象之间，耦合度不高，利于程序扩展和优化
   >           
   >           3. 继承时，遵循里氏替换原则
   >       
   >     * 里氏替换原则
   >     
   >         1. OO(面向对象)中的继承性思考与说明
   >     
   >             1. 继承时，父类中实现了的方法，其实有着某些规则和契约，如果子类继承了父类，虽然不强制要求子类遵循这些契约，但是如果子类任意修改父类实现了的方法，会对整个继承体系造成破坏
   >             2. 继承虽然给程序带来便利，但是也有相应的弊端。例如程序的可移植性降低；增加对象之间的耦合度；如果一个类被其他的类继承，该类作出修改，则要考虑到所有的子类
   >               
   >             3. 因此，在编程中，如何正确使用继承至关重要
   >            
   >         2. **里氏替换原则，就是告诉程序员，如何正确使用类继承**
   >     
   >         3. 里氏替换原则介绍
   >     
   >            继承会让两个类的耦合度变高，因此在**子类中尽量不要重写父类的方法**
   >            
   >            在适当的情况下，可以将子类和父类中冲突的方法(子类想要重写的父类方法)向上提取成一个基类
   >            
   >            如果子类仍然想要使用父类方法，通过聚合，组合，依赖父类来解决问题。
   >     
   >     * 开闭原则
   >     
   >         1. 开闭原则介绍
   >     
   >            **开闭原则是编程中最基础，也是最重要的原则。即对扩展开放(可以扩展提供方，如扩展更多实现类、修改现有实现类)，对修改关闭(指的是，对使用接口的地方，不允许修改)**
   >     
   >            一个实体如类，它的方法、模块应该允许扩展，但是不允许修改。使用抽象构建架构，用抽象的实现来扩展细节
   >     
   >            软件需要变化，尽量通过扩展实体的行为来改变，而不是修改原有代码
   >     
   >            **编程中使用其他设计模式、遵循其他规则的目的，就是满足开闭原则**
   >     
   >     * 迪米特法则
   >     
   >         1. 介绍
   >     
   >            类和类之间关系越密切，耦合度越高
   >     
   >            **迪米特法则，又叫最少知道原则。被依赖的类不管多复杂，对外只提供public方法，其他信息不外露**
   >     
   >            **迪米特法则最简单的定义：类只和直接朋友通信。直接朋友就是类中的成员变量、方法的参数、方法的返回值，局部变量不是直接朋友。因此，陌生的类不要作为局部变量出现。**
   >     
   >     * 合成复用原则
   >     
   >         1. 介绍
   >     
   >            类和类之间，尽量使用合成或聚合方式，尽量不要用继承
   >     
   > 3. 总结
   > 
   >    设计模式核心思想就是：
   >    
   >    1、应用中经常变化的和不变的要分开，不要混在一起
   >    
   >    2、针对接口编程
   >    
   >    3、要为了交互对象的解耦而设计
   >            
## 2. UML类图

2. UML类图

   > 1. 介绍
   >
   >    UML，统一建模语言，本身是一套符号
   >    
   >    是用来进行分析和设计的语言工具。
   >    
   > 2. 使用UML建模，常用的UML建模工具为Rational Rose
   > 
   > 3. UML基本介绍。
   > 
   >     * Note：注释
   >     
   >     * Class：表示一个类
   >     
   >     * Interface：表示一个接口
   >     
   >     * Dependency：表示依赖(使用)
   >     
   >     * Association：表示关联
   >     
   >     * Generalization：表示泛化(继承)
   >     
   >     * Realization：表示实现
   >     
   >     * Aggregation：表示聚合。一个类A中，有成员变量类B，类A中有Setter方法可以注入类B的实例，就说明类A聚合类B
   >     
   >     * Composite：表示组合。一个类A中，有成员变量类B，并且成员变量类B直接new类B的实例，说明类A组合类B
   >     
   > 4. UML类图：<img src="D:\JavaZiLiao\designpattern\UMLpicture.png" width="454px" height="366px">
   > 
   > 5. UML图分类
   > 
   >     1. 用例图(User Case)
   >     
   >     2. 静态结果图：其中类图最为关键
   >     
   >     3. 动态行为图：

## 3. 类的关系
3. 类的关系
    > 1. 类之间的六种关系
    >
    >     1. 依赖关系：
    >     
    >        只要类中使用到了对方，就说它们之间有依赖关系。如果没有对方，编译都通过不了
    >        
    >     2. 泛化关系(继承关系)
    >     
    >        依赖关系的特例。如果一个类继承另一个类，就说明类泛化另一个类
    >        
    >     3. 实现关系
    >     
    >        依赖关系的特例。如果一个类实现了另一个类或者接口，就说他们有实现关系
    >        
    >     4. 关联关系：
    >     
    >        依赖关系的特例。关联关系描述了类与类的关系，具有导航型和多重性，即双向关系或者单向关系。
    >        类与类之间的关联关系有如下几种：
    >        
    >        单向一对一
    >        
    >        双向一对一
    >        
    >     5. **聚合关系**
    >     
    >        关联关系的特例，具有多重性和导航性。聚合关系表示了整体和部分的关系，整体和部分可以分开。
    >        
    >        例如一个类A通过setter方法注入到另一个类B中成为成员变量，则该类聚合到另一个类
    >        
    >     6. **组合关系**
    >     
    >         关联关系的特例，具有多重性和导航性。组合关系表示了不可分割的整体和组合的关系，同生同死。
    >         
    >         例如一个类A通过new成为类B的成员变量，因为类B初始化时类A就会初始化，类A和B类不可分割，该类组合到另一个类；
    >         
    >         再比如，如果一个类A中定义了类B，类Bsetter方法注入到类A，如果要删除类A的实例时同时必须删除类B的实例，则类A和类B由聚合关系升级到组合关系
    >         
## 4. 设计模式概述
4. 设计模式概述
    > 1. 介绍
    >
    >    设计模式是程序员在面对同类软件工程设计问题所总结出来的有用的经验，模式不是代码，而是某类问题的通用解决方案，设计模式（Design pattern）代表了最佳的实践
    >    
    >    设计模式共有23种
    >    
    > 2. 设计模式类型
    >
    >     * 创建型模式：站在类的角度，专注于如何创建一个对象。单例模式、抽象工厂模式、原型模式、建造者模式、工厂模式
    >     * 结构型模式：站在软件的结构来考虑，如何让软件更有伸缩性。适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式
    >     * 行为型模式：站在方法的角度，让方法设计更加合理。模版方法模式、命令模式、访问者模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式（Interpreter 模式）、状态模式、策略模式、职责链模式(责任链模式)
    >     
    > 3. **最重要，一定要掌握的模式：单例模式，工厂模式，装饰模式，代理模式，观察者模式**

## 5. 单例模式
5. 单例模式
   > 1. 理论
   >
   >    1. 介绍
   >
   >       单例模式(Singleton)，只有一个实例的意思。应用于只需要一个实例的场景下。比如各种Factory、Manager。
   >
   >       理论上有八种实现单例模式的方式
   >
   >    2. 单例模式使用场景
   >    
   >       需要频繁创建和销毁的对象，创建对象非常耗时或者消耗资源(即重量级对象)，经常使用的对象，工具类的对象，频繁访问数据库或文件的对象(比如数据源、Session工厂等)用到
   >
   >    3. 单例模式实现方式
   >
   >       1. 静态常量，饿汉式：
   >
   >           * 介绍：
   >
   >              类加载到内存后，就直接实例化一个对象，JVM保证线程安全
   >
   >              简单、实用。比较推荐工作中实用
   >    
   >              唯一缺点：不管该实例是否使用，都会在类加载内存时就创建。（但是一般没人会创建实例但是不用）
   >              
   >           * 实战
   >           
   >               ```
   >                /**
   >                 * 饿汉式单例模式
   >                   */
   >                    class Mgr01 {
   >               
   >                   private static final Mgr01 INSTANCE = new Mgr01(); // 饿汉式直接创建一个静态常量存放实例
   >               
   >                   private Mgr01() {} // 私有化构造函数，无法通过new来创建实例，保证单例
   >               
   >                   // 开放一个静态方法，用来返回单一实例
   >                      public static Mgr01 getInstance() {
   >                       return INSTANCE;
   >                      }
   >               
   >                   }
   >               ```
   >    
   >         2. 静态代码块，饿汉式
   >         
   >             * 介绍
   >               
   >                类加载到内存后，就直接实例化一个对象，JVM保证线程安全
   >                
   >             * 实战
   >             
   >                 ```
   >                 /**
   >                   * 静态代码块，饿汉式
   >                   */
   >                class Mgr01 {
   >             
   >                    private static Mgr01 INSTANCE; 
   >                 
   >                    static {
   >                    	instance = new Mgr01();
   >                    }
   >                 
   >                    private Mgr01() {} 
   >                 
   >                    // 开放一个静态方法，用来返回单一实例
   >                     public static Mgr01 getInstance() {
   >                        return INSTANCE;
   >                     }
   >             
   >                }
   >                ```
   >             
   >         3. 懒汉式(线程不安全)
   >         
   >             * 介绍
   >             
   >                什么时候使用到什么时候初始化实例
   >                
   >                缺点：虽然达到了初始化的目的，但是会造成多线程非单例问题。因为当多个线程同时第一次使用实例时，会多次实例化，导致不同线程使用不同的实例，造成非单例
   >               
   >             * 实战
   >             
   >                 ```
   >                 /**
   >                  * 懒汉式
   >                  */
   >                 public class Mgr02 {
   >                 
   >                     private Mgr02() {} // 单例模式都会保证构造函数私有，防止外界通过new来得到实例
   >                 
   >                     private static Mgr02 INSTANCE; // 定义一个静态成员变量来存放单一实例。因为final修饰的变量必须初始化，要么直接初始化，要么使用静态代码块初始化，因此无法使用final
   >                 
   >                     public static Mgr02 getInstance() {
   >                     if (INSTANCE == null) {
   >                             INSTANCE = new Mgr02(); // 当使用时才初始化实例，并且通过非空判断保证只会实例化一次
   >                     }
   >                 
   >                         return INSTANCE;
   >                     }
   >                     
   >                     /**
   >                      * 检验多线程时，不同线程的实例不同。
   >                      * 因为同一个类的不同对象，hash值一定是不同的，因此我们可以使用hashCode()方法来检验
   >                      */
   >                     public static void main(String[] args) {
   >                         for (int i = 0; i < 100; i++) {
   >                             new Thread( () -> 
   >                                 System.out.println(Mgr02.getInstance().hashCode())
   >                             ).start();
   >                         }
   >                     }
   >                     
   >                 }
   >                 ```
   >             
   >         4. 懒汉式，加锁(线程安全)
   >         
   >             * 介绍
   >             
   >                加锁保证线程安全
   >                
   >                缺点：效率太低
   >                
   >             * 实战
   >             
   >                 ```
   >                 /**
   >                  * 懒汉式加锁
   >                  */
   >                  public class Mgr03 {
   >             
   >                      private Mgr03() {} // 单例模式都会保证构造函数私有，防止外界通过new来得到实例
   >             
   >                      private static Mgr03 INSTANCE; // 定义一个静态成员变量来存放单一实例。因为final修饰的变量必须初始化，要么直接初始化，要么使用静态代码块初始化
   >              
   >                      public synchronized static Mgr03 getInstance() {
   >                 
   >                          if (INSTANCE == null) {
   >                             INSTANCE = new Mgr03(); // 当使用时才初始化实例，并且通过非空判断保证只会实例化一次
   >                          }
   >             
   >                          return INSTANCE;
   >                      }
   >                 }
   >                 ```
   >             
   >         5. 懒汉式，同步代码块(线程不安全)
   >    
   >             * 介绍
   >    
   >                保证线程安全
   >                
   >                缺点：线程不安全
   >                
   >             * 实战：
   >             
   >                 ```
   >                 public class Mgr03 {
   >                 
   >                      private Mgr03() {} 
   >                 
   >                      private static Mgr03 INSTANCE; 
   >                  
   >                      public static Mgr03 getInstance() {
   >                 		
   >                            if (INSTANCE == null) {
   >                                synchronized(Mgr03.class) {
   >                                    INSTANCE = new Mgr03(); 
   >                               }
   >                            }
   >                 
   >                          return INSTANCE;
   >                      }
   >                 }
   >                 ```
   >             
   >         6. DCL，双检索饿汉式
   >    
   >             * 介绍
   >    
   >                利用双重检索机制，完善饿汉式
   >                
   >                企业内部用到的多
   >                
   >             * 实战
   >    
   >                 ```
   >                 public class Mgr03 {
   >                 
   >                 	private Mgr03() {} // 单例模式都会保证构造函数私有，防止外界通过new来得到实例
   >                 
   >                      private volatile static Mgr03 INSTANCE; // 定义一个静态成员变量来存放单一实例。因为final修饰的变量必须初始化，要么直接初始化，要么使用静态代码块初始化
   >                  
   >                      public static Mgr03 getInstance() {
   >                      
   >                            if (INSTANCE == null) {
   >                            	  synchronized(Mgr03.class) {
   >                            	      if (INSTANCE == null) {
   >                                       INSTANCE = new Mgr03();
   >                                   }
   >                               }
   >                            }
   >                 
   >                          return INSTANCE;
   >                      }
   >                 }
   >                 ```
   >    
   >         7. 静态内部类
   >    
   >             * 介绍
   >    
   >                通过在类中写一个静态内部类，在静态内部类中定义静态成员变量初始化该类的实例。当需要使用实例时，返回静态内部类中的静态成员变量
   >    
   >                JVM保证单例
   >    
   >                加载外部类时，不会加载内部类，实现了懒加载
   >    
   >                缺点：无
   >    
   >             * 实战
   >    
   >                 ```
   >                /**
   >                  * 静态内部类方式
   >                  */
   >                 public class Mgr06 {
   >                     
   >                     private Mgr06() {}
   >                     
   >                     private static class Mgr06Holder {
   >                         private static final Mgr06 INSTANCE = new Mgr06(); 
   >                     }
   >                 
   >                    public static Mgr06 getInstance() {
   >                     return Mgr06Holder.INSTANCE;
   >                    }
   >                     
   >                }
   >                ```
   >    
   >         8. 枚举类方式
   >    
   >             * 介绍：
   >               
   >                在Java创始人写的```<<Effective Java>>```书中提到的单例方式实现
   >               
   >               通过让类变为枚举类，其中定义一个枚举值，即可实现
   >               
   >               不但可以解决多线程非单例问题，还可以防止反序列化。防止反序列化意思是，因为Java允许通过反射将类加载到内存然后使用构造方法反序列化直接生成实例的，枚举类没有构造方法，自然无法通过反射然后反序列化生成实例
   >               
   >               完美中的完美
   >               
   >             * 实战
   >    
   >                 ```
   >                 /**
   >                   * 让类变为枚举类方式
   >                  */
   >                  public enum Mgr07 {
   >                  
   >                      INSTANCE;
   >                  
   >                  }
   >                 ```
   >    
   > 2. 单例模式，在JDK源码中的体现
   >
   >     1. 我们在JDK中发现，java.lang.Runtime就是经典的单例模式应用案例
   >     
   >     2. 它使用的是饿汉式的形式，实现的单例
   >     
## 6. 工厂模式
### 1. 简单工厂
1. 简单工厂模式
    > 1. 披萨订购需求
    > 
    >    披萨有多个种类，披萨制作工序很多。要求：完成披萨订购，保证披萨易于扩展、便于维护
### 2. 工厂方法
### 3. 抽象工厂

## 2. 策略模式

2. 策略模式：同时了解Java中的Comparable接口和Comparator接口

   > 1. 理论
   >
   >    1. 引言：一步一步引出策略模式
   >
   >       假设我们需要一个sort()方法对传入的一个数组进行排序，我们不知道该数组数据类型是什么，int、float、double都有可能，如何设计该方法？
   >
   >       第一个想到的是，利用Java的重载，设计多个方法名为sort方法，参数不同，以达到对上述几个类型的数组都可以排序的目的。但是这显然不现实，因为同样的算法需要实现多次。
   >
   >       
   >
   >       因此，我们思考：
   >
   >       如果有一个Comparable接口，该接口有个泛型T和方法comparaTo(T t)，如果我们让需要进行比较的类都实现该接口，然后书写comparaTo(T t)的该对象和传入的T类型对象的比较策略；让sort()方法参数为该接口的数组，里面是按照comparaTo(T t)方法进行比较排序的逻辑，根据多态，我们就可以让多个对象根据sort()方法进行比较排序了。
   >
   >       
   >
   >       这样还有缺陷，就是每个comparaTo()方法需要每个类进行定义，不够灵活。因此我们换个更灵活的思路：
   >
   >       如果还有一个Comparator接口，该接口有个泛型T和方法comparaTo(T t1, T t2)，comparaTo(T t1, T t2)方法可以根据既定策略比较传入的两个对象的大小。如果我们让sort()方法参数为泛型T和该比较接口，sort()方法中是按照接口中的comparaTo(T t1, T t2)方法进行比较的逻辑。这样，我们就可以对任意的对象，使用任意Comparator接口的实现类，就可以做到对任意对象，使用任意比较策略进行比较了。这个Comparator接口就是使用了策略模式
   >
   >       
   >
   >       Java中自带有Comparable接口、Comparator接口。Comparator接口使用了策略模式
   >       小扩展：Java8之后，支持了Lambda表达式，因此，如果我们自己定义了Comparator接口，接口中只有一个比较的方法，我们在使用时完全可以使用Lambda表达式来传入实例
   >
   >    2. 介绍
   >
   >       策略模式(Strategy)，一个策略接口，多个实现的策略类，策略模式封装了一个策略的多个实现方式。策略模式保证了策略的高扩展性，但是不会修改到业务代码
   >
   > 2. 实战
   >
   >    * 一个方法，对一个对象数组从大到小排序。比较大小有很多中，如体重大小、高低大小、身材大小。见D:/DesignPattern
   >
   >      

## 3. 工厂系列

3. 工厂系列：简单工厂、静态工厂、工厂方法、抽象工厂，最终了解SpringIOC

   > 1. 理论
   >
   >    1. 定义
   >
   >       任何可以产生对象的方法或者类，都可以称之为工厂。
   >
   >       不要死扣概念
   >
   >       **单例也是一种工厂**
   >
   >       为什么可以通过new来创建对象，还需要工厂呢？因为：1、可以灵活的控制生产对象的过程；2、控制生产出来对象的各种权限(例如使用权，谁可以使用该对象)，修饰生产的对象、添加日志
   >
   >    2. 简单工厂：
   >
   >       1. 介绍：
   >
   >          一个工厂类，该类中有工厂方法，方法返回需要的对象。在这些方法中，我们可以定义一些对返回对象的权限、修饰等，最后再return对象。
   >
   >    3. 静态工厂
   >    
   >        1. 介绍
   >        
   >           静态方法返回一个具体的对象
   >        
   >    4. 工厂方法
   >    
   >        1. 介绍
   >        
   >           工厂接口，接口中有生产类的方法。具体的工厂实现该工厂接口，重写里面的生产方法来成产产品。例如一个生产车的工厂接口，里面有生产车的方法，假设有奔驰工厂实现了接口，生产奔驰；宝马工厂实现接口，生产宝马，等等。
   >           
   >        2. 缺陷：
   >        
   >           产品族的话不好扩展
   >
   >    3. 抽象工厂
   >
   >       1. 前言：
   >
   >          例如交通工具、食物、武器，里面不同种类可以组合形成多个产品族，例如车、面包、手枪可以组成一个普通的人的产品族，魔法扫帚、魔法面包、魔杖可以组成魔法师的产品族。如果有多个产品族，每个产品族中有多个类，不同的客户使用不同的产品族中的类的对象。
   >
   >          如果要扩展产品族，如何扩展？我们可以这样考虑：
   >
   >          如果我们定义了一个抽象工厂，n个抽象类，抽象工厂中有n个抽象方法制造抽象类，这些抽象类组成一个产品族。
   >
   >          如果我们定义具体的工厂继承了抽象工厂，具体的n个类继承n个抽象类，则我们就可以一直定义具体工厂和具体的类，只要继承了抽象工厂和抽象类，就能生产若干个具体的产品族。
   >          使用也很简单，只要用多态的写法获取抽象工厂，然后使用抽象工厂的方法创建抽象类，根据多态我们就能获取具体的工厂生产的具体的类了。只用改变等号右边的具体工厂，就可以产生多个产品族的产品。
   >
   >          如果我们将具体的工厂和具体的类放入配置文件，就只用改变配置文件，就可以用不同的工厂，生产多个产品族的产品。
   >
   >       2. 介绍
   >
   >          抽象工厂解决了扩展性问题，只要利用继承和多态，就可以一直扩展具体工厂进而扩展产品族。
   >    
   >   3. SpringIOC的Bean工厂
   >   
   >       1. 介绍
   >
   > 2. 小的总结
   >
   >    1. 抽象工厂和抽象类，我们可以使用接口吗？可以，不过从语义上来讲，抽象比接口好
   >    
   >    2. 抽象和接口如何使用：一般名词使用抽象，形容词使用接口。例如food，是对现实中一类类似事物的抽象，因此使用抽象abstract；Movable，可移动的东西很多，不是一类事物的抽象，因此使用接口interface
   >    
   >    3. 抽象工厂和工厂方法使用场景：
   >    
   >       工厂方法好处在于，产品的扩展性很好，只需要实现接口，即可产生新产品，但是在产品族维度，不好扩展
   >       
   >       抽象工厂好处在于，产品族的扩展性很好，只需要新建工厂，新建产品族中的各个产品，然后继承抽象工厂和抽象类即可，但是在产品维度，不好进行扩展。
   >       
## 4. 门面和调停者
4. 门面和调停者
   > 1. 理论
   > 
   >     1. 介绍
   >     
   >        门面模式(Facade)，一个用来封装一个庞大系统中关系的模式，它对外提供操作系统的接口。
   >        
   >        调停者模式(Mediator)，一个用来协调系统内具体的事务的模式，它对内管理一个庞大系统中的所有事务，系统所有事务通过调停者与系统其它事务产生联系
   >        
   >        门面和调停者可以是一个东西，同时兼具对内调解和对外服务的功能。
   >        
   >        门面和调停者让庞大系统中的各个事物解耦
   >        
   >     2. 调停者最著名的应用：消息中间件(MQ)
   >        
## 5. 装饰器
5. 装饰器
   > 1. 理论
   >
   >     1. 前言
   >     
   >        假设我们有一个轿车类，我们想给轿车类添加外壳属性，添加火焰喷射器属性，添加武器属性等等，如何做？
   >        
   >        第一个想到的是，我们写多个类，继承轿车类，然后添加属性。但是这样不灵活，被装饰者和装饰物之间耦合度太高了
   >        
   >        进一步，我们想到，是否可以抽取一个装饰的类，装饰类中有各种装饰的属性，方法传入轿车类，就可以将某个装饰属性装饰给轿车。但是如果有个飞机、火车等，就无法装饰了；并且每个装饰之间无法互相装饰
   >        
   >        最终，我们想到，如果有个大类，火车、飞机、轿车继承该大类，装饰类也继承该大类，装饰类中的装饰方法用来装饰大类。根据多态，装饰类就可以装饰所有的继承了大类的交通工具；也因为装饰自己继承了大类，因此装饰之间也可以互相装饰
   >        
## 6. 责任链模式
6. 责任链模式
   > 1. 理论
   > 
   >     1. 问题
   >     
   >        在论坛上中发表文章：文章传给管理员审批，管理员审批后传给后台，后台传给数据库入库。

